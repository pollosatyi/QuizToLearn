using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Xml.Schema;
using static System.Net.WebRequestMethods;

namespace QuizToLearn
{
    internal class ListQA
    {
        public List<(string, string)> listQA { get; set; }
        public ListQA()
        {
            listQA = new List<(string, string)>()
            {
                ("0. Что такое git-flow?"," это модель ветвления для Git, которая предлагает стандартизированный подход к управлению ветками в проекте.\n"+
                                          "Основные ветки в Git-flow:\n"+
                                           "master. В нем стабильный код. Хранит в себе версии релизов \n"+
                                           "develop. Основная ветка для разработки.В нее сливаются все ветки feature и из нее создаются release ветки\n"+
                                           "feature.Создаются  от develop и сливаются в develop.\n "+
                                            "release. Создаются от develop.Тестирование и документация. Сливается в master и develop\n"+
                                            "hotfix. Создаются для исправления багов. Сливаются в master и develop"),

                ("1. Чем git-flow отличается от trunk-based development?","это методология разработки, при которой вся команда работает в одной основной ветке (trunk или main)\n" +
                                                                        ", а изменения интегрируются как можно чаще (в идеале — несколько раз в день).\n" +
                                                                        " Это противоположность Git-flow, где используется множество долгоживущих веток."),

                ("2. Почему git-flow может тормозить команды, работающие по Scrum?","В Git-flow фичи разрабатываются в изоляции, а мержатся в develop только после полной готовности.\n" +
                                                                                  "merge часто происходит в ручную из за большого обьема кода\n "+
                                                                                  "У Scrum принцип \"работющий код каждый спринт\"\n"+
                                                                                  "Что подразумевает частный и простой merge "),

                ("3. Как установить git-flow на macOS через brew?","Проверить через терминал установлен и обновлен Homebrew\n" +
                                                                 " в терминале brew install git-flow.\n"),

                ("4. Как проверить, установлен ли git-flow и его версия?","which git-flow выдает путь где установлен git-flow\n"+
                                                                           "git-flow version выдает версию"  ),


                ("5.Можно ли использовать git-flow без установки расширения? ","Можно в ручную создать ветки и управлять ими с помощью гит\n "),




                ("6.Как проинициализировать git-flow?","git flow init"),

                ("7.Какие ветки создаются при инициализации?","Две ветки получают названия\n"+
                                                                "main (или master) — стабильная ветка для релизов.\n"+
                                                               "develop — основная ветка для разработки.\n"+
                                                               "Остальные просто получают префикс.\n"+
                                                               "feature/ —  ветка фич.\n"+
                                                               "release/ — ветка релизов\n"+
                                                                "hotfix/ — ветка срочных исправлений.\n"),

                ("8.Что произойдёт, если репозиторий уже содержит другие ветки?","Если уже есть ветки то git flow init не повредит их\n"+
                                                                                 "Init настроит git flow,учитывая существующую структуру\n"+
                                                                                 "Если изначально были ветки main или developer\n"+
                                                                                 "они остаются вместо создания новых\n"+
                                                                                 "При отсутствии developer создается от main\n "+
                                                                                 "Если совпадают старые вспомогательные остаются\n"+
                                                                                  "а новые создаются с префиксом\n"),

                ("9.Почему develop должна быть защищена в CI/CD? ","Нужно поддерживать стабильность ветки develop\n "+
                                                                   "Все коммиты должны делаться через merge/pullRequests\n "+
                                                                   "Это снижает риск поломанного коммита и делает историю измений контролируемой\n"+
                                                                   "иначе весь процесс теряет смысл\n"),

                ("10.Как начать фичу?","Переключится на develop git checkout develop\n"+
                                       "Убедиться что локальная ветка соответствует удаленной git pull origin develop\n"+
                                       "Создать новую фичу ветку и перейти на неё git checkout -b feature/new-feature-name\n"+
                                       "Добавить код и сделать коммит git add . git commit -m\n"+
                                       "Снова проверить обновления из develop git pull origin develop\n"+
                                       "Запушить ветку и открыть Merge/PullRequests  git push origin feature/newFeature\n"+
                                       "Затем зайти в git host и запросить слияние\n"+
                                       "После удачного слияния удаляем ветку локально: git branch -d feature/newFeature\n "+
                                       "и на удаленном сервере git push origin --delete feature/newFeature\n"),

                ("11. Что делает feature finish?","Код из feature/NewFeature, объединяется с develop через merge/pullRequests\n"+
                                                   "Удаляется ветка локально и удаленно\n"),

                ("12.Что произойдёт при feature finish, если есть незакоммиченные изменения?","выйдет ошибка. Можно сделать коммит \n"+
                                                             "git commit -m\n"+
                                                             "Или сделать временные сохраненее\n"+
                                                             "git stash\n"+
                                                             "git flow finish feature/newFeature\n"+
                                                             "git pop - возвращение изменений\n"+
                                                             "можно удалить изменения\n"+
                                                             "git reset --hard\n"),

                ("13.Как работать с фичей вдвоём?","один разработчик создает feature\n"+
                                                "git flow feature start newFeature\n"+
                                                "Пушим ветку на сервер\n"+
                                                "git push -u origin feature newFeature\n"+
                                                "второй разработчик получает актуальные ветки\n"+
                                                "git fetch --all\n"+
                                                "переходим на feature\n"+
                                                "git checkout feature\n"+
                                                "подтягиваем последние изменения\n"+
                                                "git pull origin feature\n"),
                ("14.Как начать релиз?","Ветка develop стабильна\n"+
                                         "Тесты проходят (CI/CD зелёный)\n"+
                                         " Версия проекта обновлена\n"+
                                         "git checkout develop\n"+
                                         "git pull origin develop\n"+
                                         "git flow release start new\n"
                                         ),
                ("15.Что делает release finish","смержит release в main\n"+
                                                "смержит release в develop\n"+
                                                "удалит release\n"+
                                                "переключит на develop\n"),

                ("16.Что делать, если хотфиксы уже в master,\n"+
                "а develop отстаёт?",
                                                       "Есть два способа:\n"+
                                                       "Первый способ:\n"+
                                                       "Merge master в develop\n"+
                                                       "git checkout develop\n"+
                                                       "git pull origin develop\n"+
                                                       "git merge master\n"+
                                                       "git push origin develop\n"+
                                                       "Второй способ:\n"+
                                                       "Перенос хотфиксов по одному. Cherry pick хотфиксов\n"+
                                                       "git checkout develop\n"+
                                                       "git pull origin develop\n"+
                                                       "git cherry-pick <хеш хотфикса>\n"+
                                                       "git push origin develop\n"),

               ("18.Когда использовать hotfix?","Когда критический баг в production, а релиз ожидается не скоро\n"),

               ("19.Что делает hotfix finish","Завершает ветку hotfix\n"+
                                               "merge в master и develop\n"+
                                               "а также делается теги\n"+
                                               "возвращение в исходную ветку\n"),

                ("19.Какие есть альтернативы GitHub?","GitLab, Bitbucket, Azure DevOps"),

                ("20.Можно ли работать в команде без GitHub?","Если только использовать свой сервер или одну папку с проектом"),

                ("21.Что такое origin в контексте GitHub?","Алиас псевдоним для адреса вашего  на удаленного репозитория\n"+
                                                           "Сокращенная ссылка чтоб не вводить полный url адрес каждый раз\n"),

                ("22.Что происходит при git add .","В индекс(staging area) добавляются:\n"+
                                                    "Новые файлы untracked\n"+
                                                    "Измененные файлы modified\n"+
                                                    "Удаленные файлы deleted\n"+
                                                    "Технически:\n"+
                                                    "git вычисляет хеш каждого файла и сохраняет его временной зоне\n "+
                                                    "данные файлов записываются в объектную базу Git(папка .git/objects\n"),

                ("23.В чём разница между git commit и git commit -a","git commit требует git add\n"+
                                                                     "git commit -a добавляет в коммит  все изменения  tracked файлов\n"+
                                                                     "добавление новых untracked требует git add\n"),

                ("24.Что делает git add -p?","Это инструмент для интерактивного выбора изменений,\n"+
                                              "которые нужно добавить в staging area\n"+
                                              "Позволяет разбить изменения в файле на кусочки(hunks)\n"+
                                              "и выбрать какие попадут в коммит, а какие нет\n "+
                                              "не работает для новых файлов\n"),

                ("25.Что такое индекс в Git?","Индекс это промежуточная область(staging area или cache),\n"+
                                              "где Git временно хранит изменения перед тем как они попадут в коммит\n"+
                                              "Untracked - новый файл, еще не отслеживаемый\n"+
                                              "Modified - файл изменён, но не добавлен в индекс\n"+
                                              "Staged - изменения добавлены в индекс(готовы к коммиту)\n"+
                                              "Committed - изменения сохранены в репозиторий\n "+
                                              "git reset удаляет изменения в индексе\n"+
                                              "git diff --cached Показывает изменения добавленные в индекс\n"),

                ("26.Можно ли сделать коммит без git add","Можно с помощью команды git commit -a\n"),

                ("27.Что делает git checkout branch-name?","переключение на указанную ветку в git"),

                ("28.Как переключиться на предыдущий коммит?","git checkout Head~1\n"+
                                                              "git checkout SHA 1\n"+
                                                              "просмотр изменений git show HEAD~1\n"),

                ("29.Как вернуться к последнему коммиту после checkout на хеш? ","git switch - переключение на предыдущую\n"+
                                                                                  "git switch имя ветки\n"+
                                                                                  "git checkout имя ветки\n"+
                                                                                  "Если название ветки неизвестно\n"+
                                                                                  "git reflog в сообщение будет написано названии ветки\n"),

                ("30.В чём разница между git switch и git checkout?","switch новая команда для простого и понятного переключения между ветками\n"+
                                                                     "откажется работать если есть незакоммичные изменения\n"+
                                                                     "требуется явного --merge или --discard-changes\n"+
                                                                     "checkout попытается сохранить изменеия автоматически\n"),

                ("31.Как найти хеш нужного коммита?","git log\n"+
                                                     "--oneline - сокрашенная хеш и сообщение\n"+
                                                     "--graph с визуализации ветвления\n"+
                                                     "-n 5 последние пять коммитов\n"+
                                                     "-- author \n+" +
                                                     "--grep\n по сообщению"),

                ("32.Как создать аннотированный тег?","git tag -a имя -m \"сообщение\"\n"+
                                                      "git push origin имя - отправка\n"+
                                                      "git push origin --tags - отправка всех\n"),

                ("33.Как перейти к тегу?","git checkout имя\n"+
                                           "git switch --detach имя\n"),

                ("34.Как посмотреть все теги?","git tag\n"
                                               + "или git ls-remote --tags удаленные,\n"+
                                              "git tag -n аннотированные теги\n"),

                ("35.В чём разница между легковесным и аннотированным тегом?","Разницами между тегами заключается в способе их хранения и дополнительной информации\n"+
                                                                               "Легковесный тег Lightweight Tag это указатель на конкретный коммит\n"+
                                                                               "не содержит дополнительной информации\n"+
                                                                               "git tag имя тега\n"+
                                                                               "Аннотированный тег Annotated Tag это полноценный объект в Git, который хранит:\n"+
                                                                               "Имя тега\n"+
                                                                               "Сообщение(как у коммита)\n"+
                                                                               "Автор тега\n"+
                                                                               "Дату создания\n"+
                                                                               "Указатель на коммит\n+" +
                                                                               "Может быть подписан GPG(для верификации)\n"+
                                                                               "git tag -a имя тега -m соббщение тега\n"),

                ("36.Как отправить тег в удалённый репозиторий?","git push origin имя тега\n"+
                                                                 "git push origin --tags  -отправка всех тегов\n"),

                ("37.Как создать и сразу перейти в новую ветку?","git checkout -b имя ветки\n"+
                                                                 "git switch -c имя ветки\n"+
                                                                 "git checkout -b имя ветки источник\n"),

                ("38.Как посмотреть список всех веток?","git branch - только локальные\n"+
                                                        "git branch -r только удаленные ветки\n"+
                                                        "git branch -a все ветки\n"+
                                                        "git branch -vv подробный вывод(с коммитами и связями)\n"+
                                                        "git show-branch графическое представление\n"+
                                                        "git log --oneline --graph --all история всех веток в виде графа\n"),

                ("39.Как создать ветку от определённого коммита?","git branch имя ветки хеш\n"+
                                                                  "git checkout -b новая ветка хеш коммита - с переходом\n"+
                                                                  "git switch -c новая ветка хеш коммита - с переходом\n"),

                ("40.Что делает git switch -c name?","создание ветки с переходом\n"),

                ("41.Где хранятся ссылки на ветки?","Вся информации о ветках локальных и удаленных хранится в папке .git\n"+
                                                    "Каждая ветка это файл, содержащий SHA-1 хеш последнего коммита в этой ветке\n"+
                                                    ".git/refs/heads\n"+
                                                    ".git/refs/remotes/origin\n"),

                ("42.Что делает git merge feature?","объединяет изменения из ветке feature в текущую\n"+
                                                     "git checkout main\n"+
                                                     "git merge feature\n"+
                                                    "Fast-Forward Merge(быстрая перемотка)\n"+
                                                    "Если main не имеет новых коммитов после ответвления feature:\n"+
                                                    "Git просто перемещает указатель main на последний указатель feature\n"+
                                                    "История остается линейной(без нового коммита)\n"+
                                                    "Recursive merge(Рекурсивное слияние)\n"+
                                                    "Если в main и feature есть изменения\n"+
                                                    "Git создает новый коммит слияния(merge commit)\n"+
                                                    "В истории появляется развилка(ветвление и соединение)\n"+
                                                    "Конфликты слияния. Если в main и feature затрагивают одни и те же строки \n"+
                                                    "Git останавливает процесс и сообщает от конфликте\n"+
                                                    "Нужно в ручную исправить конфликт,затем завершить слияние\n"+
                                                    "git add .\n"+
                                                    "git merge --continue\n"+
                                                    "Флаги:"+
                                                    "--no --ff всегда создает коммит сляиния\n"+
                                                    "--squash - объединяет все изменения в один коммит сливаемой ветки\n"+
                                                    "--abort - отменяет слияние при конфликтах\n"),

                ("43.Что такое fast-forward merge?","Это тип слияния в Git, при котором история веток остается линейной, не создает новый коммит слияния\n+" +
                                                    "Он возможен, если целевая ветка не получила новых изменений с момента создания сливаемой ветки\n"+
                                                    "а просто перемещает указатель текущей ветки вперед до конца целевой\n"
                                                    ),

                ("44.Как отменить конфликтное слияние?","Если конфликты не разрешены git merge --abort\n"+
                                                        "Кофликты разрешены, но нет коммита  git reset --hard HEAD\n"+
                                                        "Merge уже закомичен git reset --hard HEAD~1(локально)\n"+
                                                                             "git revert -m 1 <commit> если был отправлен\n"),

                ("45.Как увидеть коммиты, которые будут вливаться?","git log имя1 имя2\n"+
                                                                    "git log --online --graph --all графический просмотр\n"),

                ("46.Что делает git merge --no-ff","выполняет слияние веток в Git всегда создавая новый коммит\n"+
                                                    "даже если можно сделать fast-forward\n"),

                ("47.Как связать локальный проект с GitHub?","git init\n"+
                                                              "git add .\n"+
                                                              "git commmit -m\"сообщение\"\n"+
                                                              "git remote add origin ссылка\n"+
                                                              "git push -u origin main\n"),

                ("48.Как отправить первую версию на GitHub?", "git init\n"+
                                                              "git add .\n"+
                                                              "git commmit -m\"сообщение\"\n"+
                                                              "git remote add origin ссылка\n"+
                                                              "git push -u origin main\n"),

                ("49.Как переименовать удалённый репозиторий?","В репозитории GitHub Settings - Repository name - Rename\n"+
                                                               "Обновление локального git remote set-url origin новая ссылка\n"),

                ("50.Как проверить адрес удалённого репозитория?","git remote get-url origin\n"),

                ("51.Как удалить привязку к удалённому?","git remote remove origin \n"+
                                                         "git remote rm origin старая версия\n"+
                                                         "git remote -v проверка"),

                ("52.Какие типы объектов есть в Git?","Есть 4 основных типа обьектов в Git\n"+
                                                      "которые хранят историю и структуру репозитория\n"+
                                                      "Они лежат в папке .git/objects и имеют хеш индекаторы SHA-1\n"+
                                                      "Blob Binary Large Object:\n"+
                                                      "В нем содержимое файлов в сжатом ввиде\n"+
                                                      "Tree (Дерево):\n"+
                                                      "Структуру каталогов (аналогично папкам в файловой системе)\n"+
                                                      "Ссылки на blobs(файлы) и другие trees(подкаталоги)\n"+
                                                      "Метаданные: имена файлов, права доступа\n"+
                                                      "Commit(Коммит)\n"+
                                                      "Ссылку на tree (состояние файлов на момент коммита)\n"+
                                                      "Ссылки на родительские коммиты. Коммитов может быть один или два(при слияние)\n"+
                                                      "А также автора, дату и сообщение\n"+
                                                      "Tag(Аннотированный тег):\n"+
                                                      "Ссылку на коммит(обычно версию)\n"+
                                                      "Имя тега, автора, дату, описание\n"),

                ("53.Где они физически хранятся объекты Git?","Все объекты хранятся в .git/objects\n"+
                                                  "git cat-file -t sha или tag показать тип объекта\n"+
                                                  "git cat-file -p показать тип объекта\n"),

                ("54.Что такое Blob?","Binary Large Object. Один из четырех основных типов объектов в Git\n"+
                                       "которое хранит содержимое файла\n"+
                                       "Создается командой git add\n"+
                                       "Вычисляется SHA1 и сохраняет сжатые данные\n"),

                ("55.Что такое Tree?","Это объект Git которое описывает структуру каталогов и файлов\n"+
                                       "Он связывает blob объекты и другие tree объекты \n"+
                                       "в единую файловую систему\n"),

                ("56.Что такое Commit-объект?","Это объект Git, который фиксирует состояние репозитория\n"+
                                               "в определенный момент времени. Он хранит:" +
                                               "Снимок файловой структуры(через tree объекты)\n"+
                                               "Метаданные: автора, дату, сообщение и ссылку на родительские коммиты\n"),

                ("57.Что делает команда git init folder-name, если папка уже существует?","Если папка пустая:\n"+
                                                                                          "Создает новый git репозиторий в указанной папке\n" +
                                                                                           "Git создаст скрытую подпапку .git\n"+
                                                                                           "и инициализирует в ней репозиторий\n"+
                                                                                           "Иначе выдаст ошибку\n"),

                ("58.В чём принципиальная разница между git init и git clone?","init создает новый репозиторий с нуля\n"+
                                                                               "clone копирует существующий репозиторий(локальный или удаленный)\n"),

                ("59.Можно ли использовать git init внутри уже инициализированного репозитория?","Git проигнорирует команду git init и выдаст предупреждение\n"),

                ("60.Что хранится в папке .git после git init?"," два основных файла:\n"+
                                                                "HEAD указывает на текущую ветку\n"+
                                                                "config локальные настройки репозитория\n"+
                                                                "Служебные папки:\n"+
                                                                "hooks скрипты для автоматизации\n"+
                                                                "info файл для игнорирования файлов\n"+
                                                                "objects хранилище объектов Git\n"+
                                                                "refs ссылки на ветки и теги\n"),

                ("61.Как проверить, инициализирован ли каталог как Git-репозиторий?","проверить есть ли папка .git\n"+
                                                                                     "git status\n"+
                                                                                     "git branch\n"+
                                                                                     "git remote -t\n"),

                ("62.Что произойдёт, если выполнить git clone <https://url.git> . в уже инициализированной папке?","Выдаст ошибку\n"),

                ("63.Как клонировать репозиторий без загрузки содержимого (bare)?","git clone --bare url\n"),

                ("64.Что означает FolderName в команде git clone url FolderName?","Создаст папку и клонирует туда репозиторий\n"+
                                                                                  "Если папка есть то выдаст ошибку\n"),

                ("65.Как клонировать только определённую ветку?","git clone --branch dev --single-branch Url - клонирование одной ветки\n"+
                                                                 "git fetch origin other-branch - добавление ветки позже\n"),

                ("66.Что делает параметр --depth при клонировании? ","Позволяет клонировать репозиторий без полной истории\n"+
                                                                     "загружая только последние N коммитов указанной ветки\n"+
                                                                     "Это называется поверхностным клонированием(shallow clone)\n"),

                ("67.Чем отличается git diff от git diff --staged?","git diff сравнивает рабочую директорию и индекс(Staging Area)\n"+
                                                                    "git diff --stage сравнивает индекс и последний коммит\n"+
                                                                    "git diff HEAD рабочую директорию vs последний коммит\n"),

                ("68.Что покажет git diff master...feature?","Сравнивает изменения,внесенные в ветку feature\n"+
                                                             "Относительно точки расхождения с веткой master\n"+
                                                             "git diff origin/master...origin/feature\n удаленной ветки\n"),

                ("69.Что произойдёт, если файл изменён, но не проиндексирован? Где он появится в git status?","файл будет строке modified\n"),

                ("70.Что делает флаг --name-only у git diff?","Упрощает вывод, показывая только имена изменных файлов, без деталей самых изменений\n"+
                                                               ""),

                ("71.Почему git diff игнорирует неотслеживаемые файлы?","Потому что до добавления Git не знает про них\n"+
                                                                        "--no--index для принудительного сравнения\n"),

                ("72.Что делает git add -p и зачем это нужно?","запускает интерактивный режим добавления изменений в индекс\n"+
                                                               "Она позволяет выборочно добавлять части файлов(отдельные части, а не весь файл целиком\n"+
                                                               "y - yes добавить в текущий кусок в staging\n"+
                                                               "n - no пропустить кусок\n"+
                                                               "s - split разделить на более мелкие части\n"+
                                                               "e  - edit в ручную отредактировать кусок перед добавлением\n"+
                                                               "q - quit выйти из режима\n"+
                                                               "? - справка по всем опциями\n"),

                ("73.Чем отличается git add -i от git add -p?","git add -i работает с целыми файлами\n"+
                                                               "Имеет текстовое меню с опциями\n"+
                                                               "update - добавить файлы в staging\n"+
                                                               "revert - убрать файлы из staging\n"+
                                                               "add untracked - добавить неотслеживаемые файлы\n"+
                                                               "patch перейти в режим git add -p для выбранного файла\n"),

                ("74.Что произойдёт, если после git add . изменить файл?","Будет две версии файла одна в staging area,\n"+
                                                                           "другая в рабочей директории\n"),

                ("75.Как удалить файл из индекса, но оставить его в рабочей директории?","git rm --cached\n"+
                                                                                           ""),

                ("76.Можно ли добавить в индекс только часть изменений одного файла?","git add -p\n"+
                                                                                      "git add -e ручное редактирование патчей\n"+
                                                                                      "git add -i добавление отдельных строк\n"),

                ("77.Что удаляет git reset --hard?","Отменить все изменения до последнего коммита\n"+
                                                    "git reset hard <хеш коммита> отменить все изменения до коммита\n"+
                                                    ""),

                ("78.Как отменить только последние изменения, оставив индекс нетронутым?","git restore имя\n"+
                                                                                          "git restore .\n"+
                                                                                          "git checkout --\n"),

                ("79.Зачем нужен git clean -df и что он удаляет?","Он удаляет untracked файлы\n"+
                                                                   "d - флаг для удаления директорий\n"+
                                                                   "f - флаг опасных операций\n"+
                                                                   "x - флаг удаления из списка gitignore\n"),

                ("80.Что будет, если сделать git reset без аргументов?","покажет список флагов для git reset\n"),

                ("81. Чем reset --hard отличается от revert","revert создает коммит отменяющий изменения\n"+
                                                             "сохраняет историю коммитов, добавляя новый\n"),

                ("82.Что делает команда git commit -a -m \"msg\" и чем она отличается от git commit -m \"msg\"?",""+
                                                          "-a позволяет добавить изменения в файлах без git add .\n"),

                ("83.Можно ли закоммитить новые файлы с помощью git commit -a","новые файлы обязательно нужно добавлять в индекс\n"),

                ("84.Как отменить последний коммит, не удаляя изменения в рабочей директории?","git reset --soft HEAD~1\n"+
                                                                                               "git reset --mixed HEAD~1\n"+
                                                                                               "git revert HEAD\n"),

                ("85.В чем разница между git reset --soft, --mixed и --hard","--soft Перемещает указатель, не трогает изменения\n"+
                                                                             "--mixed Перемещает указатель, изменения становятся unstaged\n"+
                                                                             "--hard Перемещает указатель, сбрасывает изменения\n "),

                ("86.Что делает команда git commit --amend?","позволяет изменить коммит без создания нового\n"+
                                                             "-m изменить сообщение\n"+
                                                             "Git не удаляет старый коммит,а создает новый\n"+
                                                             "старый коммит становится недостижимым\n"),

                ("87.Что делает git revert HEAD --no-edit?","Выполняет отмену последнего коммита,\n"+
                                                            "создавая новый коммит с обратными изменениями\n"+
                                                            "при этом автоматически используя стандартное сообщение коммита\n"+
                                                            "без открытия редактора коммита\n"),

                ("88.В каких случаях git revert безопаснее, чем git reset?","когда коммит отправлен на удаленный репозиторий\n"+
                                                                            "нужно сохранить историю изменений\n"+
                                                                            "когда работают в одной ветке больше одного разработчика\n"+
                                                                            "reset может удалить измения другого разработчика\n"+
                                                                            "когда нужно отменить конкретный коммит, \n"+
                                                                            "reset удалит всё до указанного коммита\n"+
                                                                            "когда нужно уменьшить количество конфликтов\n"),

                ("89.Что произойдёт после выполнения git reset --hard @~2","полный сброс состояния репозитория до 2 коммита\n"),

                ("90.Что делает git reset --keep @~ и когда он полезен?","безопасная альтернатива git reset --hard\n"+
                                                                         "Перемещает указатель HEAD на предыдущий коммит\n"+
                                                                         "Сохраняет незакомиченные изменения в рабочей директории,\n "+
                                                                         "если не конфликтуют с целевым коммитом\n"+
                                                                         "сбрасывает индекс\n"),

                ("91.Какой командой можно безопасно заменить последний коммит новым, не создавая отдельного коммита отката?",""+
                                                                 "сделать изменения и выполнить команду git commit --amend\n"+
                                                                 "если только нужно изменить сообщение то git commit --amend -m\n"+
                                                                 "изменить автора git commit --amend --reset-author\n"+
                                                                 "если изменений много то git reset --soft HEAD^ + новый коммит\n"),

                ("92.Что делает git checkout b9533bb?","Переключение рабочей директории на состояние коммита с указанным хешом\n"),

                ("93.Как вернуться обратно в ветку main после переключения на старый коммит?","git checkout имя ветки\n"+
                                                                   "git switch main\n"+
                                                                   ""),

                ("94.Чем опасен detached HEAD и как его \"обезвредить\"?","Новые коммиты висят в воздухе\n"+
                                                                          "Они не принадлежат ни одной ветке и могут быть потеряны\n"+
                                                                          "если не создать новую ветку\n"+
                                                                          "Git не предупредит об удалении\n"+
                                                                          "Чтоб обезвредить detached HEAD\n"+
                                                                          "вернуться в ветку\n"+
                                                                          "Если есть изменения, но не закомичены, то сохранить изменения в новой ветке\n"+
                                                                          "Если закомичены то сделать новую ветку, а потом merge\n"+
                                                                          "Если изменения не нужны просто выйти\n"+
                                                                          "коммиты можно найти только через git reflog\n"+
                                                                          "найти хеш коммита git reflog\n" +
                                                                          "создать ветку от коммита git branch saved-commits хеш\n"),

                ("95.Как создать новую ветку, начиная с произвольного коммита?","git branch имя хеш\n"+
                                                                                "git checkout -b имя хеш\n"),

                ("96.Что произойдёт после git checkout master?","Git переключится на ветку master\n"+
                                                                "и рабочая директория обновится до последнего сотояния коммита этой ветки\n"+
                                                                "Если в текущей ветки были незакомиченные изменения,\n"+
                                                                "Git попытается сохранить изменения или выдаст предупреждения\n"+
                                                                "Указатель HEAD переместится на ветку master\n"),

                ("97.Что делает git checkout 5589877 index.html?","Выполняет восстановление кокретного файла из указанного коммита\n"+
                                                                  "в рабочую директорию и индекс\n"+
                                                                  "альтернативный вариант:\n"+
                                                                  "git restore --source хеш --worktree имя файла\n"),

                ("98. Можно ли отменить это восстановление?(git checkout sha1 имя файла)","Если еще не закомичены:\n"+
                                                             "вернуть файл к последней закомиченной версии\n"+
                                                             "git checkout HEAD --имя файла\n"+
                                                             "git restore имя файла\n"+
                                                             "отменить все изменения,если они не были добавлены в staging\n"+
                                                             "git checkout --имя файла\n"+
                                                             "Если уже закомитили восстановленый файл:\n"+
                                                             "Создать новый коммит, отменяющий изменения\n"+
                                                             "git revert HEAD\n"+
                                                             "Откатить последний коммит(если он не был отправлен в удаленный коммит)\n"+
                                                             "git reset --soft HEAD~1 отмена коммита, но сохранение изменений в stage\n"+
                                                             "git reset HEAD имя файла убирает файл из stage\n"+
                                                             "git checkout --имя файла\n"+
                                                             "или полный откат коммита git reset --hard HEAD~1\n"+
                                                             "Чтоб вернуть файл к состоянию до всех изменений(включая staged)\n"+
                                                             "git reset HEAD имя убирает из staged\n"+
                                                             "git checkout --имя  сбрасывает изменения в рабочей директории\n"+
                                                             ""),

                ("99.Как перенести изменения из одного коммита в другую ветку?","git cherry-pick если нужно перенести конкретный коммит\n"+
                                                                                "переключение на целевую ветку git checkout имя\n"+
                                                                                "git cherry-pick хеш коммита\n"+
                                                                                "git merge полное слияние\n"+
                                                                                "git rebase имя целевой ветки когда нужно перебросить коммиты одной ветки на другую\n"+
                                                                                "git checkout <коммит> -- <файлы> если нужны только некоторые файлы\n"+
                                                                                ""),

                ("100.Что произойдёт, если сделать git cherry-pick master~2..master?","Git перенесет два последних коммита из ветки мастер\n"+
                                                                                     "master~2 начало отсчета коммитов\n"+
                                                                                     ".. диапазон\n"+
                                                                                     "master окончание диапазона\n"+
                                                                                     "создаст новый коммит, а потом добавит два коммита в текущей ветке\n"),

                ("101.Что делать при конфликте во время cherry-pick?","При возникновении конфликта слияния Git останавливает операцию и требует ручного разрешения конфликта\n"+
                                                                      "В ручную разобрать в редакторе конфликт\n"+
                                                                      "git add .\n"+
                                                                      "git cherry-pick --continue\n"+
                                                                      "git cherry-pick --abort вернет состояние до выполнения команды\n"+
                                                                      "git cherry-pick --skip пропустить текущий конфликтный коммит\n"),


                ("102.Что произойдёт при выполнении команды git rm text.txt?","Полностью удалится файл из рабочей директории и индекса\n"+
                                                                              ""),

                ("103.В чем отличие git rm и git rm --cached","-- cached Файл будет удален только из индекса\n"),

                ("104.Что делает git rm -f и зачем нужен флаг -f","Принудительно удаляет файл из рабочей директории и индекса,\n"+"" +
                                                                  "игнорирует любые предуждения или конфликты\n"),

                ("105.Когда удобно использовать git rm --cached?","Полезна в ситуациях когда нужно перестать отслеживать изменения файлов\n"+
                                                                   "Добавление файлов в gitignore после того как его закомитили\n"+
                                                                   "Удаление случайно добавленных файлов\n"+
                                                                   "Прекращение отслеживания без удаления файла\n"),

                ("106.Что делает git rm ind*?","Удаляет файлы из рабочей директории и индекса, соответствующие шаблону\n"+
                                               "Работает только с отслеживаемыми файлами,иначе выдаст ошибку\n"+
                                               "для удаления файлов с незакомиченными изменениями нужен флаг -f\n"+
                                               "-r рекурсивное удаление в поддерикториях\n "),

                ("107.Что делает команда git branch -f master 5589877?","Принудительно перемещает ветку master на указанный коммит\n"+
                                                                        "Все коммиты после указанного теряют связь с веткой\n"),

                ("108.Как создать ветку new_branch на два коммита назад от master","git log master --oneline -3 поиск нужно коммита\n"+
                                                                                   "git branch имя ветки имя SHA1\n"+
                                                                                   "git branch имя master~2\n"+
                                                                                   "git checkout имя master~2\n"),

                ("109.Чем git checkout -b отличается от git checkout -B?","-b выдаст ошибку при перезаписи\n"+
                                                                          "-B перезапишем\n"),

                ("110.Что делает git branch -d hotfix?","Удаляет ветку при условии что она была слита в другую ветку\n"+
                                                        "иначе будет ошибка\n"+
                                                        "D удаление в любом случае\n"),

                ("111.Как посмотреть ветки, которые не были слиты в текущую?","Основной способ: git branch --no-merged\n"+
                                                                              "git branch --no-merged проверка конкретной\n"+
                                                                              "git branch -r --no-merge удаленные ветки\n"+
                                                                              "git branch merge просмотр слитых веток\n"+
                                                                              "git log --online --no-merge имя имя текущей\n"+
                                                                              "git log --graph --oneline --all графическое представление\n"),

                ("112.Что делает git stash?","Временно сохраняет незакомиченные изменения в рабочей директории\n"+
                                              "-a изменения в индексе\n"+
                                              "- include-untracked включая новые файлы\n"),

                ("113.Что произойдёт при git stash pop","Git возьмет самый свежий stash\n"+
                                                        "Применит изменения к рабочей директории и индексу\n"+
                                                        "Удаляет stach из списка\n"+
                                                        "При конфликте:\n"+
                                                        "Git останавливает операцию\n"+
                                                        "Stach не будет удален\n"+
                                                        "разрешить конфликт в ручную\n"+
                                                        "git add. \n"+
                                                        "git stach drop для удаления\n"+
                                                        "git stach apply не удаляет stach\n"),

                ("114.Можно ли сделать несколько stash-записей?","В Git можно делать несколько stach\n"+
                                                                 "они сохраняются ввиде стека\n"+
                                                                 ""),

                ("115.Что произойдёт, если после git stash создать новую ветку?","Stach останется доступным в новой ветке\n"+
                                                                              "Stach в Git привязан к репозиторию,а не конкретной ветке\n"+
                                                                              ""),

                ("116.Как посмотреть список всех stash-записей?","git stach list\n"),

                ("117.Как посмотреть URL удалённого репозитория?","git remote -v\n"+
                                                                  "git remote --verbose\n"+
                                                                  "конкретного git remote get-url origin\n"+
                                                                  "git remote просмотр всех\n"+
                                                                  "git remote show origin подробный просмотр\n"),

                ("118.Что делает git remote remove origin?","Удаляет связь вашего репозитория с удаленным\n"+
                                                            "git remote rm origin сокращеная\n"+
                                                            ""),

                 ("119.Что делает git push origin :old_branch_name new_branch_name?","Удаляет старую удаленную ветку\n"+
                                                                                     "Пушит локальную ветку на удаленный репозиторий\n"+
                                                                                     "Локальные ветки остаются, удаляется только удаленная\n"+
                                                                                     ""),

                 ("120.Как посмотреть удалённые ветки?","git branch -r\n"+
                                                        "git remote show origin подробный список\n"+
                                                        "git branch -a список локальных и удаленных\n"+
                                                        ""),

                 ("121. Что делает git remote show origin?","Выводит подробную информацию о подключенном удаленном репозитории\n"+
                                                            "URL\n"+
                                                            "отслеживаемые ветки\n"+
                                                            "настройки и статус синхронизации\n"),

                 ("122.Чем git rebase отличается от git merge?","git merge создает новый коммит слияния\n"+
                                                                "История остается нелинейной\n"+
                                                                "git rebase перемешает коммиты одной ветки поверх другой\n"+
                                                                "история остается линейной\n"+
                                                                "merge безопасен для командной работы\n"+
                                                                "Конфликты разрешаются один раз\n"+
                                                                "Для публичных веток\n"),

                 ("123.Почему использование git rebase может привести к конфликтам?","Переписывает историю, а не объединяет ее\n"+
                                                                                     "Применяет каждый коммит отдельно, увеличивая точки потенциальных конфликтов\n"+
                                                                                     "Требует больше ручной работы, но дает чистую историю\n"),

                 ("124. Как выполнить rebase ветки с основной веткой?","git rebase main\n"+
                                                                       ""),

                 ("125.Как отменить git rebase, если возникли проблемы с конфликтами?","git rebase --abort\n"),

                 ("126.Как продолжить git rebase после разрешения конфликтов?","git add .\n"+
                                                                                "git rebase --continue\n"),

                 ("127. Что делает команда git rebase --onto master feature","Выполняет сложную операцию перебазирования,\n" +
                                                                              "позволяет перенести часть коммитов из одной ветки в другую\n"+
                                                                              "минуя промежуточные изменения\n"),

                 ("128.Когда и почему полезно использовать git rebase --onto","Когда нужно перенести только часть коммитов\n"+
                                                                              "Когда нужно отрезать ненужные коммиты из истории\n"+
                                                                              "Когда нужно перебазировать несколько веток\n"+
                                                                              "Когда нужно исправить ошибку в базой ветке\n"+
                                                                              "Когда нужно разделить историю\n"),

                 ("129. Как использовать git reflog, чтобы найти коммит, на который можно откатить ветку после неудачного rebase?",""+
                                                                              "git reflog хронологический список всех действий,\n"+
                                                                              "включая переключение веток, коммиты и rebase\n"+
                                                                              "поиск стабильного коммита\n"+
                                                                              "git reset --hard HEAD@{2} или хеш\n"+
                                                                              "или создать ветку git branch HEAD@{2}"),

                 ("130.Как вернуться к коммиту до выполнения git rebase","\"git reset --hard HEAD@{2} или хеш\\n\"+\r\n " +
                                                                              "\"или создать ветку git branch HEAD@{2}"),


                 ("131.Что делает команда SELECT * FROM table_name?","Выбирает все столбцы из таблицы\n"+
                                                                      "* это wildcard(символ подстановки)\n"+
                                                                      "используют обычно для тестирования\n"+
                                                                      "в продакшен использует конкретные столбцы"),

                 ("132.Чем отличается SELECT DISTINCT от обычного SELECT?"," Distinct возвращает только уникальные значения"),

                 ("133.Можно ли в SELECT запросе использовать несколько таблиц? Как это сделать?","Можно после FROM через запятую,\n"+
                                                                                     "а можно осмысленно через JOIN"),

                 ("134.Что делает оператор INNER JOIN?","INNER JOIN(внутреннее соединение) - это оператор, который объединяет строки\n"+
                                                         "из двух таблиц только тогда, когда выполняется условие связи\n"+
                                                         "Если совпадений нет, то такие строки не попадают в результат\n"+
                                                         "можно написатьь кратко JOIN\n"),

                 ("135.Чем отличается LEFT JOIN от RIGHT JOIN?","Оба оператора объединения, но работают в разных направлениях\n"+
                                                                "LEFT JOIN все строки из левой таблицы + совпадения из правой,\n " +
                                                                "если нет совпадения в правой части будет NULL\n"+
                                                                "RIGHT JOIN все строки из правой таблицы + совпадения из левой,\n"+
                                                                "если нет совпадения то в левой части NULL\n"),

                 ("136.Можно ли объединить более двух таблиц? Приведите пример.","Таблицы можно объединить последовательными JOIN\n"+
                                                                   "SELECT users.name,\n"+
                                                                    "products.name,\n"+
                                                                    "orders.quantity\n"+
                                                                    "orders.order_date\n"+
                                                                   "FROM users\n"+
                                                                   "INNER JOIN orders ON users.id=orders.id\n"+
                                                                   "INNER JOIN products ON orders.product_id=products.id\n"),

                 ("137.Что делает GROUP BY в SQL?","Это оператор, который группирует строки по указанным столбцам\n"+
                                                   "и позволяет применять к ним агрегатные функции(COUNT,SUM,AVG,MAX,MIN)\n"+
                                                   "Все неагрегированные поля в SELECT должны быть в GROUP BY\n"),

                 ("138.Как использовать COUNT с GROUP BY в SQL","Функция COUNT совместно с GROUP BY позволяет подсчитывать количестов\n"+
                                                                "строк в каждой группе. Это полезно для анализа данных,например:\n"+
                                                                "Сколько заказов у клиента?\n"+
                                                                "Сколько товаров в каждой категории?\n"+
                                                                "Сколько сотрудников в каждом отделе?\n"),

                 ("139.Что возвращает функция AVG() и как она используется?","Это агрегатная функция,которая вычисляет среднее арифмитическое по числовым столбцам\n"+
                                                                             "Если применяется с GROUP BY вычисляет среднее по группам\n"+
                                                                             "Практическое применение:\n"+
                                                                             "Расчет средней зарплаты по отделам\n"+
                                                                             "Анализ среднего времени доставки\n"),

                 ("140.Что такое подзапрос и когда его следует использовать?","Подзапрос(subquery) - это SQL-запрос, вложенный внутрь друго запроса\n"+
                                                                              "(SELECT,FROM, WHERE, HAVING, INSERT, UPDATE, DELETE)\n"+
                                                                              "Подзапросы полезны:\n"+
                                                                              "Фильтровать данные на основе другого запроса(WHERE, HAVING)\n"+
                                                                              "Создавать временные таблицы для основного запроса(FROM)\n"+
                                                                              "Заменить JOIN в сложных сценариях\n"+
                                                                              "Обновлять или удалять данные на основе условий\n"+
                                                                              "Типы подзапросов:\n"+
                                                                              "1. по месту использования:\n"+
                                                                              "  В WHERE, HAVING возвращает одно значение или список\n"+
                                                                              "  В FROM возвращает таблицу\n"+
                                                                              "  В SELECT возвращает одно значение для каждой строки\n"+
                                                                              "2. По количеству возвращаемых значений:\n"+
                                                                              "  Скалярный(1 столбец, 1 строка) используется с =,<,>\n"+
                                                                              "  Список значений(1 столбец, много строк) используется IN,ANY,ALL\n"+
                                                                              "  Табличный(много строк и столбцов) используется в FROM\n"+
                                                                              "Плюсы:\n"+
                                                                              "   Упрощает сложные запросы разбивая их на части\n"+
                                                                              "   Позволяют избежать многоступенчатых JOIN\n"+
                                                                              "   Читаемы для многоэтапной логики\n"+
                                                                              "Минусы:\n"+
                                                                              "   Могут быть медленнее JOIN(если СУБД не оптимизирует их)\n"+
                                                                              "   Вложенные подзапросы снижают читаемость\n"),

                 ("141. Вопрос: Чем отличается подзапрос в SELECT от подзапроса в WHERE?","Подзапрос в SELECT используется, когда нужно добавить вычисляемое поле к результату запроса\n"+
                                                                                          "Подзапрос WHERE ипользуется для фильтрации строк основоного запроса\n"+
                                                                                          ""),

                 ("142.Что делает функция CONCAT() в SQL?","Это строковая функция которая склеивает две и более строк\n"+
                                                           "|| для Postgres\n"),

                 ("143.Как используется функция NOW() в SQL?","Возвращает текущую дату и время\n"),

                 ("144.Как извлечь только год из даты с использованием функции SQL?","SELECT EXTRACT(YEAR FROM дата_столбец) AS год FROM\n"+
                                                                                     "SELECT DATE_PART('year',дата_столбец) AS год FROM\n"),

                 ("145. Что такое домены в SQL? Пример","Домены в SQL объединяет тип данных и ограничения в одно\n"+
                                                   "CREATE DOMAIN название AS text constraint format CHECK(\n"+
                                                   "VALUE~ '^d{5}$' OR VALUE ~'^d{5}-'d{4}$'"),

                 ("146.COLLATE Что это? стандартный пример","Определяет правила сортировки и сравнения\n"+
                                                            "en_US.UTF-8\n"),

                 ("147.Пример создания сортировки","Создание регистронезависимой сортировки\n"+
                                                   "CREATE COLLATION en_us_ci(\n"+
                                                   "provider = icu,\n"+
                                                    "locale = 'en-US-u-ks-level1'\n"+
                                                    "deterministic = false\n"),
                 ("148.Что сделает команда SELECT md5('hello world)?","Создаст хеш код. Небозапасен\n"+
                                                                       "Лучше использовать sha256 для безопасности\n"+
                                                                       "или uuid для экономии места\n"),

                 ("149. Тип данных для хранения файлов в PostgreSQL?","bytea"),

                 ("150. Тип uuid. Что это такое?","Универсальный уникальный идентификатор. Занимает 16 байт.\n"+
                                                  "Отображается как строка и может быть приведен к строке\n"+
                                                  "но как строка занимает больше места\n"),

                 ("151. Команда для вызова рандомного uuuid","SELECT get_random_uuid()"),

                 ("152. Сколько версий uuid существует? В какой версии есть время создания","Версий 8. В 7 есть временнная ментка. По ней можно сортировать"),

                 ("153. Что такое BOOLEAN? Какие состояния бывают?","Это логический тип данных размером 1 байт,который хранит истину,ложь или неизвестность\n"),

                 ("154. Какие варианты написания значений в BOOLEAN?","TRUE FALSE\n"+
                                                                       "'true' 'false'\n"+
                                                                       "'t' 'f'\n"+
                                                                       "'1' '0'\n"+
                                                                       "'on' 'off'\n"+
                                                                       "'yes' 'no'\n"+
                                                                       "NULL"),

                 ("155. Как создать перечисление ENUM и добавить новый тип","CREATE TYPE название AS ENUM ('first','second','third')\n"+
                                                                            "ALTER TYPE название ADD VALUE 'four'"),


                 ("156. Особенности сортировки ENUM","Сортировка происходит по порядку добавления В ENUM\n"+
                                                     "С помощью команды ALTER TYPE название ADD VALUE 'first' before 'zero'\n"+
                                                     "'after' для добавления после\n"),

                 ("157. Что за формат timestamp? Его особенности?","Это временная ветка. Бывает с указанием часового пояса и без\n"+
                                                                   "timestamp without time zone\n"+
                                                                   "timestamp with time zone\n"+
                                                                   "timestamptz с часовым поясом\n"+
                                                                   "timestamptz(0-6) точность в милисекундах, 6 по умолчанию\n"+
                                                                   "SELECT NOW()::timestamp получение текущего времени\n"),

                 ("158. Форматы дата и время?","ISO 8601 2024-01-31 15:30:08.234\n"+
                                               "может быть Т между датой и время\n"+
                                               "z в конце это гринвич\n"+
                                               "-06:00 указание часового пояса\n"),

                 ("159. Посмотреть и настроить формат даты","show DateStyle стандарт ISO,DMY\n"+
                                                            "установка своего DateStyle:\n"+
                                                            "set DateStyle= 'ISO, MDY'"),

                 ("160. Работа с часовым поясом. Как посмотреть и установииь часовой пояс","show time zone проверить часовой пояс\n"+
                                                  "set time zone 'America/Chicago'\n"+
                                                  "ALTER database название SET time zone 'UTC' время базы данных\n"+
                                                  "show config_file редактирование файла настройки\n"+
                                                  "время::timestampz at time zone 'CDT' установка времени по названию пояса\n"+
                                                  "at time zone '-06:00'  установка через разницу. Делает перевод в обратную сторону\n"+
                                                  "at time zone interval '-06:00' корректное смещение\n"),

                 ("161.Посмотреть все часовый пояса","SELECT * FROM pg_timezone_names"),

                 ("162. Формат даты и времени отдельно","DATE без часового пояса\n"+
                                                        "TIME with time zone\n"+
                                                        "TIME without time zone\n" +
                                                        "CURRENTDATE текущая дата\n"+
                                                        "LOCALTIME текущее время без указания времени\n"),

                 ("163. Что такое INTERVAL интервалы? Как создать интервал?","Интервал это тип данных, представляющий отрезок в шкале типа этих данных. Удобно использовать например при бронировании\n"+
                                                       "SELECT '' ::interval создание интервала\n"+
                                                       "show intervalstyle стиль отображения интервала\n"+
                                                       "SET intervalstyle = установка стиля отображения интервала\n"),

                 ("164. Как посмотреть добавленные данные после INSERT INTO VALUES?","VALUES() RETURNING *"),


                 ("165. Как создать идентификатор?","SERIAL PRIMARY KEY\n"+
                                                    "BIGSERIAL PRIMARY KEY\n"+
                                                    "BIGINT GENERATED ALWAYS AS IDENTITY PRIMARY KEY"),

                 ("166. Как создать последовательность?","CREATE SEQUENCE название\n " +
                                                         "AS BIGINT\n"+
                                                         "INCREMENT 1 шаг\n"+
                                                         "START 1\n"+
                                                         "MINVALUE 1\n"+
                                                         "CACHE сколько кешировать прежде чем начнет запршивать новые\n"),

                 ("167. Функции для SEQUENCE","SELECT nextval('название') возвращает следующее значение и увеливает последовательность\n"+
                                              "SELECT setval('название',2) устанавливает текущее значение последовательности\n"+
                                              "SELECT currval('название') возвращает последнее значение в этой последовательности в текущей сессии\n"+
                                              "SELECT lastval() возвращает последнее значение любой последовательности текущий сессии "),

                 ("168. Какие бывают INTEGER","smallint - int2\n"+
                                              "integer int4\n"+
                                              "bigint int8\n"),

                 ("169. Тип данных NUMERIC","Тип данных для хранения чисел с произвольной точностью\n"+
                                            "Идеальный выбор для вычислений с высокой точностью\n"),

                 ("170. Дробные числа SQL","Дробные числа быстрые, но с ограниченной точностью\n"+
                                            "real 4 байт\n"+
                                            "double precision 8 байт\n"+
                                            "float(1-52)"),

                 ("171. Тип данных деньги","MONEY имеет точность два знака до запятой\n"+
                                           "имеет префикс ввиде валюты\n"+
                                           "просмотр префикса show lc_monetary \n"+
                                           "установка префикса SET lc_monetary = 'en_US.UTF-8'\n"+
                                           "MONEY не рекомендуется использовать. Возможны проблемы с точностью и конвертацией\n"+
                                           "Лучше использовать целые числа умноженные на 100\n"+
                                           "или NUMERIC\n"),

                 ("172. Что такое NaN","NaN это не число. Может быть у numeric и чисел с плавающей точкой\n"),

                 ("173. Что такое infinity","Это бесконечность может быть у numeric ,без ограничений и чисел с плавающей точкой\n"+
                                            "может быть отрицательной\n"),

                 ("174. Как можно преобразовать типы в Postgres","команда CAST(значение AS тип) или значение :: тип"),

                 ("175. Команда для определения типа Postgres","pg_typeof()"),

                 ("176. Команда для определения размера типа Postgres","pg_column_size()"),

                 ("177. Три символьных типа","char(размер) не гарантирует размер, просто выравнивает длину до нужного размера\n"+
                                             "character varying это varchar для postgres\n"+
                                             "text строка"),

                 ("178. Какие способы ограничений есть? Как сделать чтоб было название проверки","CHECK(название столбца >0) для целых чисел \n" +
                                                                                                 "CHECK(LENGTH(название столбца)>5) для строк\n" +
                                                                                                 "если ограничение записать через запятую то работает на уровне таблицы\n"+
                                                                                                 "CONSTRAINT название CHECK "),

                 ("179. Как создать автоматический идентификатор Postgres","id BIGINT GENERATED ALWAYS AS IDENTYTI PRIMARY KEY\n"+
                                                                           ""),

                 ("180. Как добавить принудительно значение идентификатора","INSERT INTO название таблицы (id) OVERRIDING SYSTEM VALUE values(значение id)\n"),

                 ("181. Как узнать номер последовательности для столбца","SELECT pg_get_serial_sequence('название таблицы','название столбца')\n"+
                                                                         "SELECT setval('название последовательности',(SELECT MAX(id) FROM 'название таблицы')"),

                 ("182. Какие типы данных есть для хранения строк IP адресов? " +
                 "Какие преимущества их использования?",                    "INET разные варианты ip адресов\n"+
                                                                            "CIDR хранит ip4 и ip6 вместе с маской\n"+
                                                                            "macaddr6 macaddr8 MAC адрес\n"+
                                                                            "Использование этих типов данных экономит место\n"+
                                                                            "а также имеет специальные функции для работы с ними\n"),

                 ("183. Какие типы данных для хранения json в Postgres\n"+
                 "Какие отличия",                                        "json имеет меньше размер,есть только защита от невадилидных данных\n"+
                                                                         "jsonb имеет больше размер, но скорость обработки выше потому,\n"+
                                                                         "что хранит в себе биты, а не текст\n"+
                                                                         "включает только последние значения по ключу, сортирует по ключу, удаляет лишние пробелы\n"),

                 ("184. Представление значения json в строку","::json->string строка в кавычках\n"+
                                                               "::json->>string строка без кавычек\n"),

                 ("185. Как указать тип данных массив в Postgres","ARRAY или []"),

                 ("186. Как можно добавить значения в массив Postgres","INSERT INTO название таблицы(int_array, text_array, bool_array)\n" +
                                                                       "VALUES \n"+
                                                                       "(\n"+
                                                                       "ARRAY [1, 2, 3, 4],\n"+
                                                                       "ARRAY ['marigold','daisy','poppy','sunflower'],\n"+
                                                                       "ARRAY [true, false, true, false]\n"+
                                                                       ")\n"+
                                                                       "Второй вариант:\n"+
                                                                       "VALUES '{1,2,3}'\n"+
                                                                       "Вариант для вложенного массива:\n"+
                                                                       "'{{},{},{}}'"),

                 ("187. Извлечение элементов из массива Postgres","SELECT text_array[1] FROM название таблицы\n"+
                                                                  "Индексация начинается с 1\n"+
                                                                  "Можно использовать срезы text_array[1:3] выдаст с 1 по 3 элементы\n"+
                                                                  "text_array[:3] все элементы по 3\n"+
                                                                  "text_array[3:] все элементы с 3\n"),

                 ("188.Как найти массив SQL в котором, есть искомый элемент","SELECT text_array FROM table\n"+
                                                                             "WHERE text_array @> ARRAY['значение']\n"),

                 ("189. Как получить набор результатов из массива SQL","SELECT unnest(text_array)\n"+
                                                                       "Сделает выборку,где каждое значение массива будет строкой\n"),

                 ("190. Создание временной таблицы с помощью массива SQL","WITH flowers AS {\n"+
                                                                "SELECT id, unnest(text_array) AS flower\n"+
                                                                "FROM array_example}\n"+
                                                                "Это код создает временную таблицу с id и каждом цветком из таблицы\n"),

                 ("191. Как сделать сгенерированный столбец Postgres","CREATE TABLE people(\n"+
                                                                      "heigth_cm numeric\n"+
                                                                      "heugth_in numeric GENERATED ALWAYS AS (height/2.54) STORED)\n"+
                                                                      "можно вставить функцию после AS\n"+
                                                                      "Ограничения:\n"+
                                                                      "Должны быть стабильные данные,\n"+
                                                                      "нельзя генерировать столбец от генерированого\n"),

                 ("192. Типы данных для полнотекстового поиска","to_tsvector('строка') перевод в тип tsvector это отсортированный список различных лексим\n"+
                                                                "to_tsquery('слово') перевод в тип tsquery. Через оператор @@ можно проверить есть ли в tsvector tsquery\n"+
                                                                 "SELECT ts_vector('язык','строка') создание tsvector с указанием языка\n"),

                 ("193.Создание генерируемого столбца tsvector","название столбца TSVECTOR generated always AS(to_tsvector('english', content)) stored"),

                 ("194. Чтот такое битовые строки. Как их записывать?", "bit(3) точный размер\n"+
                                                                        "bit varying(32) размер до 32 включительно\n"+
                                                                        "B'0001'\n"+
                                                                        "'0001'::BIT(4)\n"+
                                                                        "Можно использовать как список true false\n"),

                 ("195. Что такое диапазон. типы диапазона. Правило ограничений","Это специальный тип данных, который позволяет хранить и эффективно\n"+
                                                                                 "рабоать с диапазоном значений\n"+
                                                                                 "'[1,5]'::int4range это диапазон [1,6) --1,2,3,4,5\n"+
                                                                                 "'[1,5]'::numrange это диапазон [1,5]  --1,1.1,5.9 \n"+
                                                                                  "numrange(1,5) -- [1,5)  --1,4.9\n"+
                                                                                  "int4range(1,5) --[1,5) --1,2,3,4\n"+
                                                                                  "numrange(1,5,'[])' --[1,5] --1,5.9\n"+
                                                                                  "int4range(1,5,'(]) --(1,5] --2,3,4,5\n"+
                                                                                 "[] - края диапазона включены\n"+
                                                                                 "() - края диапазона невключены\n"+
                                                                                 "empty пустой диапазон включает все\n"+
                                                                                 "(,) полностью закрытый диапазон. Не включает ничего \n"),

                 ("196. Функции диапазона","WHERE столбец целых чисел @>5 диапазон целых чисел, который включает 5\n"+
                                           "WHERE столбец целых чисел && '[10,20)' есть ли пересечение между интервалами [1,11] включается\n"+
                                           "перемножение интервалов int4range(10,20)*int4range(15,25) -- [15,20)"),

                 ("197. Что такое мультидиапазон?","'{[3,7),[8,9)}'::int4multirange --3-6,8"),

                 ("198. Как создать составной тип Postgres","CREATE TYPE address AS(\n"+
                                                            "number text,\n"+
                                                            "street text);\n"+
                                                            "Нет возможности ввести ограничения на типы полей\n"),

                 ("199. Как заполнить составной тип","SELECT ROW ('1','street')::address Можно без ROW\n"+
                                                      ""),

                 ("200. Как получить отдельное поле составного типа","SELECT (название столбца).название поля"),

                 ("201. Какие ограничения в первичного ключа по умолчанию","NOT NULL UNIQUE"),

                 ("202. Может быть уникальное значение быть NULL","NULL всегда будет уникальным,\n"+
                                                                  "если не указать not distinct\n"),

                 ("203. Как создать внешний ключ","Первый вариант:\n"+
                                                   "название столбца тип данных(такой же тип данных как у столбца, на который ссылается)\n"+
                                                  "REFERENCES название таблицы название столбца, на который сслылается\n"+
                                                  "Второй вариант на уровне таблицы:\n"+
                                                  "FOREIGN KEY (название столбца) REFERENCES название таблицы(название столбца) на который ссылается\n"),

                 ("204. Удаление строк в родительской таблице в Postgres","1.ON DELETE RESTRICT по умолчанию вызовет ошибку\n"+
                                                                          "2.ON DELETE CASCADE удаление и в родительской и дочерней таблицы\n"+
                                                                          "3.ON DELETE SET NULL при удаление родительской строки во внешнем ключе ставится NULL\n"+
                                                                          "4.ON DELETE SET DEFAULT во внешнем ключе устанавливается значения по умолчанию. DEFAULT 0 REFERENCES при создании\n"+
                                                                          ""),

                 ("205. Что такое индексы в Postgres","Это отдельная структура данных,которые ускоряют поиск и извлечение данных из таблиц,\n"+
                                                      "но замедляют операции вставки и удаления\n"+
                                                      "содержит в себе копию части данных из таблицы\n"+
                                                      "содержит ссылки на таблицы и полную строку\n"),

                 ("206. Что такое ctid в Postgres","Скрытая системная таблица,показывающая где хранится строка\n"),

                 ("207. Типы индексов в Postgres"," 1. B-tree Бинарное дерево. Стандартный тип индекса. Для большинства операций >,=,BETWEEN,ORDER BY\n"+
                                                    "CREATE INDEX index_name ON table_name(column_name)\n"+
                                                    "2.HASH подходит только для = Быстрее бинаронго дерева\n"+
                                                    "CREATE INDEX index_name On table_name USING HASH (column_name)\n"+
                                                    "3.GIN GENERALIZED INVERTED INDEX для составных значений массивов,полнотекстовый поиск, JSON\n"+
                                                    "CREATE INDEX index_name ON table_name USING GIN(column_name)\n"+
                                                    "4.GiST GENERALIZED SEARCH TREE для полнотестового поиска\n"+
                                                    "CREATE INDEX ind_name ON table_name USING GiST(column_name)\n"+
                                                    "5.SP-GiST Space-Partitioned GiST для неоднородных данных\n"+
                                                    "CREATE INDEX ind_name ON table_name USING SP-GiST(column_name)\n"+
                                                    "6. BRIN Block Range Index для очень болиших таблиц с коррелированными данными\n"+
                                                    "CREATE INDEX idn_name ON table_name USING BRIN(column_name)\n"),

                 ("208.Какой тип для первичного ключа лучше использовать?","Лучше всего использовать большие целые числа\n"+
                                                                            "Если нужно улучшить безопасность первичного ключа\n"+
                                                                            "Есть два решения дополнительная таблица с ключами или UUID\n"+
                                                                           "При использовании UUID нужно учитывать что их бывает 6 видов и 2 похожих типа\n"+
                                                                           "Стандартный UUID это случайный UUID. Случайная вставка потребует перестроения дерева. Поэотму лучше использовать UUID 7 версии.\n"+
                                                                           "У него в начале идет дата и по ней можно сортировать и располагать строки по дате создания\n"+
                                                                           "Еще UUID имеет преимущество, если например пользователь получает ID раньше подключение к базе данных\n"+
                                                                           "UUID можно сразу присвоить ID\n"),

                 ("209.Какие столбцы желательно использовать под индекс.\n"+
                 "При какой ситуации поиск происходит по таблице, а не по индексу ","Нужно выбирать более уникальные столбцы\n"+
                                                                                    "Если выборка более половины таблицы,\n"+
                                                                                    "то вероятно поиск будет по таблице, а не индексу\n"),

                 ("210.Как создать составной индекс","CREATE INDEX multi ON users USING BTREE(first_name,last_name,birthday)\n"),

                 ("211.Как правильно создавать и использовать составной индекс","Нужно использовать правило слева направо\n"+
                                                                            "Перечесление столбцов в индексе должно соответствовать таблице\n"+
                                                                            "При поиске нужно задавать самый левый столбец, иначе будет поиск по таблице\n"+
                                                                            "При пропуске столбца вовремя поиск добавляет все строки из предущего\n"),

                 ("212. Покрывающие индексы. Для чего они?","Покрывающие индексы включает в себя столбец(ы),который был указан при создании\n"+
                                                            "Нужна, если часто происходит выдача результата, поиск,сортировка или группировка по только указанному столбцу\n"+
                                                            "Это позволяет получать результат не обращаясь к таблице\n"+
                                                            "Если нужно просто добавить в индекс без влияния на результат сортировки использовть USING(столбец)"),

                 ("213.Частичные индексы. Как записываются и как работают","Позволяют создать индекс для части таблицы,\n"+
                                                                           "Включая ограничения для части таблицы\n"+
                                                                           "CREATE INDEX email ON user(email) WHERE is_pro = true\n"+
                                                                           "Чтоб при выдачи результата использовался индекс, вместо таблицы\n"+
                                                                           "Нужно в SELECT продублировать WHERE из индекса\n"),

                 ("214. Есть ли разница в сортировки индекса ASC и DESC?, Особенность сортировки составного индекса","Индекс одинаково сортирует по возрастанию и по убыванию\n"+
                                                                          "Если индекс составной и столбцы нужно сортировать в разном направлении\n"+
                                                                          "то при создании индекса нужно указать сортировку в разном направлении\n"+
                                                                          "и не важном в каком потому,что индекс сортирует одинаково\n"),


                 ("215.NULL самый большой элемент? Как сделать чтоб  сортировалось иначе\n","NULL самый большой элемент, ORDER BY название столбца(ASC DESC) nulls (first или last)\n"),

                 ("216. Как создать индекс что при сортировке по возрастанию NULL был первым\n","CREATE INDEX название ON название таблицы(столбец ASC NULLS FIRST)"),

                 ("217. Как создать индекс на основе функции и как с ним работать?","CREATE INDEX название ON название таблицы((split(email,'@',2)))\n"+
                                                                                    "Чтоб индекс сработал нужно WHERE split(email,'@',2) = 'beer.com'"),

                 ("218. Как создать hash индекс. Для чего он полезен?","Работает быстрее,чем BTREE. Занимает меньше места\n"+
                                                                       "Можно использовать только для строгого равенства\n"+
                                                                       "CREATE INDEX email_hash ON users USING HASH(email)\n"+
                                                                       "до версии Postgres 10 были опасны\n"),

                 ("219. Рекомендация для названия индекса","таблица_столбец_idx"),

                 ("220.Что такое план объяснения? Как его создать?","QUERY PLAN это древовидная структура,состоящая из узлов\n"+
                                                                     "нужен для анализа запроса\n"+
                                                                     "EXPLAIN перед SELECT\n"+
                                                                     "можно EXPLAIN(format json) для подробного и машиночитаемого результата\n"+
                                                                     "читать план нужно снизу вверх\n"),

                 ("221. Типы сканирования","1.Последовательное сканирование таблицы\n"+
                                           "Seq Scan прочтение всей таблицы в физическом порядке\n"+
                                           "2.Сканирование по побитовой карте\n"+
                                           "Bitmap Index Scan сканирование битовой кучи. Физический просмотр таблицы по карте созданной по указателям\n"+
                                           "3.Сканирование по индексу\n"+
                                           "Index Scan сканирование по индексу с обращением к куче\n"+
                                           "Index Only Scan сканирование по покрывающему  индексу без обращения к куче\n"),

                 ("222. QUERY PLAN какие показатели есть","cost некоторая единица стомости(чтение последовательной, случайной) Postgres\n"+
                                                          "rows сколько строк передается\n"+
                                                          "width размер строк\n"),

                 ("223. Аналитика запроса. Основные показатели и моменты","explain (analyze) select это запрос будет выполнен\n"+
                                                                        "Основные показатели:\n"+
                                                                        "Время подготовки и выполнения\n"+
                                                                        "loops количество циклов\n"+
                                                                        "(analyze,cost off) отключить показатель cost\n"),

                 ("224. Как можно указать столбы с одинаковым названиями при Join","ON USING(user_id)"),

                 ("225. Full JOIN","Все совпадения плюс NULL левой и правой таблицы\n"),

                 ("226. Как всю включить после объединения таблиц","ON true"),

                 ("227. INNER JOIN LATERAL","Это специальный тип соединения, который позволяет подзапросу\n"+
                                            "или функции, следующий за ключевым словом LATERAL,\n"+
                                            "ссылаться на столбцы из таблицы указанных ранее\n"),

                 ("228. Выравнивание строк через ROW пример","SELECT * FROM ROWS FROM(\n"+
                                                             "generate_series(1,10), -- это функции генерации от 1 до 10\n"+
                                                             "generate_series(101,110)  -- это функции генерации от 101 до 110)\n"+
                                                             "AS t(lower,upper)\n"+
                                                             "Будет создано два столбца по 10 строк\n"+
                                                             "если один столбец будет иметь больше строк\n"+
                                                             "то в другой будет NULL\n"),

                 ("229. Функция,которая ставит значение по умолчанию, если значение NULL","coalesce(столбец, значение по умолчанию)\n"),

                 ("230. Объединение Postgres","UNION объединяет два и более запросов, удаляя дубликаты\n"+
                                              "UNION ALL объединяет запросы без удаления\n"+
                                              "Количество строк в запросах должно быть одинаковое"),

                 ("231.Пересечение Postgres","INTERSECT возвращает только те строки, которые есть в результатах обоих запросов\n"),

                 ("232.Разность Postgres","EXCEPT возврашает только строки из первого запроса, которых нет во втором\n"),

                 ("233. Получение строк из массива","SELECT unnest(ARRAY[1,2,3,4,5]) AS tag_name"),

                 ("234.Получение строк из массива с порядковым id","SELECT ordinality, element FROM\n"+
                                                                   "unnest(ARRAY['first','second','third]) WITH ORDINALITY AS t(element, ordinality)\n"),

                 ("235.Преобразование массивов JSON в таблицу","SELECT * FROM json_to_recorderset('[\n"+
                                                               "{id}:1, name:ALICE, email: alice@example.com]')\n"+
                                                               "AS x(id INT, name TEXT, email TEXT)\n"+
                                                               "Чтоб сделать тоже самое с JSONB нужно:\n"+
                                                               "jsonb_to_recorderset и ]'::JSONB\n"),

                 ("236.Получение строк из строки через регулярное выражение\n","SELECT regexp_matches('строка','\\m\\w{4}\\M'','g') AS match"),

                 ("237. Разделить строку на один столбец","SELECT string_to_table('apple,banana,cherry',',') AS fruit\n"),

                 ("238.Как можно ускорить связь между таблицами","Создать индекс для внешнего ключа\n"),

                 ("239.Необчные агрегатные функции","ANY_VALUE(столбец) любое значение\n"+
                                                    "ARRAY_AGG(столбец) агрегирование массива\n"+
                                                    "JSON_AGG(столбец)\\JSONB_AGG агрегирование JSON\n"+
                                                    "BOOL_AND(столбец) покажет true где все столбцы совпадают\n"+
                                                    "BOOL_OR где есть хоть одно совпадение\n"+
                                                    "COUNT(*) FILTER(WHERE) фильтр\n"+
                                                    "STRING_AGG(строковый столбец,'разделитель') объединение столбцов через разделитель в один столбец\n"+
                                                    "" +
                                                    ")"),

                 ("240. Сеты  в GROPUP BY","SELECT emploee_id, region, sum(amount) FROM sales\n"+
                                                 "GROUP BY grouping sets((employee_id),(region))\n"+
                                                 "() вывод общей пустой групировки\n"+
                                                 "вывод разных группировок"),


                ("241 Сварачивание в GROUP BY","rollup(region, employee_id) выведет:\n"+
                                               "region + employee_id\n"+
                                               "region + NULL\n"+
                                               "NULL\n"),

                ("242. Куб в GROUP BY","CUBE(employee_id, region) Все возможные варианты группировки\n"),

                ("243. Оконная функция"," Функция, которая работает с выделенным набором строк(окном, партицией)\n"+
                                        "и выполняет вычисление для этого набора строк в отдельном столбце\n"),

                ("244.Партиции","(окна из набора строк).Это набор строк, указанный для оконной функции по одному из столбцов\n"+
                                "или группе столбцов таблицы. Партиции для каждой оконной функции в запросе могут быть разделены по различным колонкам таблицы"),

                ("245. CTE? ","Это временные наборы результатов, которые существуют только во время выполнения запроса\n"+
                                            "Они позволяют создавать именованные подзапросы,\n"+
                                            "которые можно многократно использовать в основном запросе\n"+
                                            "WITH имя_cte AS(\n"+
                                            "SELECT)\n"+
                                            "SELECT * FROM имя_cte"),

                ("246. Обобщенное табличное выражение CTE для чего полезны","1. Улучшают читаемость сложных запросов\n"+
                                             "2. Позволяют избежать дублирования кода\n"+
                                             "3. Поддерживают рекурсию для работы с иерархическими данными\n"+
                                             "4. Могут материализоваться для оптимизации производительности\n"),

                ("247. Материализация CTE","Postgres сам выбирает материализовать или нет. Обычно при маленьком количестве вызовов не матеарилизует\n" +
                                           "WITH cte_name AS not matearilized\n"+
                                           "AS matearilized\n"),

                ("248. Рекурсивный CTE. Пример","WITH RECURSIVE имя AS\n"+
                                                "можно перечислить столбцы после AS(id,name)\n"+
                                                "WITH recursive numbers AS(\n"+
                                                "SELECT 1 AS n\n"+
                                                "UNION ALL\n"+
                                                "SELECT n+1 FROM numbers WHERE n < 10)\n"+
                                                "SELECT * FROM numbres\n"),

                ("249. CTE рекурсия. Пример с фибоначи\n","WITH RESURSIVE numbres(id, a, b) AS (\n"+
                                                          "SELECT 1, 0, 1\n"+
                                                          "UNION ALL\n"+
                                                          "SELECT id + 1, b, a + b FROM numbres WHERE id < 20)\n"+
                                                          "SELECT id, a FROM numbres\n"),

                ("250. CTE рекурсияю Иерархия пример","WITH RECURSIVE all_categories AS(\n"+
                                                      "SELECT id, name, name AS path\n"+
                                                      "FROM categories WHERE parent_id IS NULL\n"+
                                                      "UNION ALL\n"+
                                                      "SELECT categories.id, categories.name, CONCAT(path, '-->', categories.name)\n"+
                                                      "FROM all_categories\n"+
                                                      "INNER JOIN categories ON all_categories.id=categories.parent_id)\n"+
                                                      "SELECT* FROM all_categories\n"),

                ("251. Способ сравнения с NULL","SELECT 1 IS DICTINCT FROM NULL\n"+
                                                " IS NULL"),

                ("252. Функция возвращает NULL, если выражение TRUE","NULLIF(1,1),если неравны возрваащется первое значение\n"),

                ("253. Сравнение строк ROW","SELECT (1,2,3) = (1,2,3) - TRUE\n"+
                                            "SELECT (1,2,3) = (1,2,4) - FALSE\n"+
                                            "SELECT (1,2,3) = (1,NULL,3) - NULL\n" +
                                            "SELECT (1,2,3) = (1,NULL,4) - FALSE\n"),

                ("254. Представление VIEW синтаксис","CREATE VIEW имя AS();"),

                ("255. Отличие VIEW от WITH","VIEW сохраняется в базе, WITH временное(на время запроса)\n"+
                                             "VIEW может кешироваться, WITH вычисляется каждый раз\n"+
                                             "VIEW не поддерживает рекурсию\n"+
                                             "VIEW для многократного использования в разных запросах, WITH только в текущем запросе\n"),

                ("256. Как сделать Upsert при вставке","INSERT INTO kv (key,value) values ('cache:foo', 123)\n"+
                                                       "on conflict (key) do nothing - ничего не делай\n"+
                                                       "on conflict (key) do update set value='there was conflict' - вставка с заменой\n"+
                                                       "on conflict(key) do update set value=excluded.value - вставка с заменой на value\n"+
                                                       "set value = kv.value - вставка с заменой\n"+
                                                       "where как допусловие, при несоответствии не выполняется обновление\n"+
                                                       "returning позволяет отобразить вставку\n"),

                ("257. Операторы по поиску соответствия в тексте","LIKE\n"+
                                                                  "ILIKE без учета регистра\n"),

                ("258. Полнотекстовый поиск пример","SELECT title FROM movies\n"+
                                                    "WHERE to_tsvector(title) @@ to_tsquery('star & wars')\n"+
                                                    "& и то и другое\n"+
                                                    "| одно из двух\n"+
                                                    "<-> после первого идет сразу второе\n"+
                                                    "'star <-> (wars | trek)'\n"+
                                                    "<1> через сколько слов должно быть следующее слово\n"+
                                                    "'star & trek & !generation исключение слова\n"),

                ("259. Функция ранжирование полнотекстового поиска. Пример","ts_rank(to_tsvector(title), to_tsquery('star & (wars | trek)')) AS rank\n"+
                                                                            "FROM movies\n"+
                                                                            "WHERE to_tsvector(title) @@ to_tsquery('star & (wars | trek)')\n"+
                                                                            "ORDER BY rank DESC\n"+
                                                                            ""),
                ("260. Векторы полнотестового поиска","to_tsquery() стандартное\n"+
                                                      "phraseto_tsquery('star wars') - 'star'<->'war'\n"+
                                                      "plainto_tsquery('star wars') - 'star' & 'war\n"+
                                                      "websearch_to_tsquery() допускает двойные кавычки, не выдает ошибку\n"),
                ("261. Языковая допопция to_tsvector()","to_tsvector('simple',title) - простой поиск. Включает предлоги и артикулы\n"+
                                                         "to_tsvector('english', title) - желательно указывать язык\n"+
                                                         "setweight(to_tsvector(title),'A') установка приоритета при ранжировании, при совпадении\n"),

                ("262. Как сделать чтоб полнотекстовый поиск реагировал на точность совпадения","ts_rank(to_tsvector(title), to_tsquery('flight'),1)\n"+
                                                                                                "+(case when genre like %action% then 0.1 else 0)\n"+
                                                                                                "добавление к рейтингу\n"),
                ("263. Оптимизация полнотестового поиска. Пример","ALTER TABLE movies ADD COLUMN search_vectors tsvector generated always AS(\n"+
                                                                  "setweight(to_tsvector('english', coalesce(title, '')), 'B')\n+" +
                                                                  "|| ''\n"+
                                                                  "|| to_tsvector('english', coalesce(plot, '')))stored\n"+
                                                                  "Создали генерируемый столбец\n"+
                                                                  "SELECT * FROM movies\n"+
                                                                  "WHERE search_vectors @@ websearch_to_tsquery('\"stars wars\"')\n"+
                                                                  "ORDER BY\n"+
                                                                  "ts_rank(search_vectors, websearch_to_tsquery('\"stars wars\"')) desc\n"+
                                                                  "Вызваем запрос\n"+
                                                                  "CREATE index idx_movies_search_gin on movies using gin(search_vectors)\n"+
                                                                  "Создание индекса\n"),

                ("264. Поиск полнотекстовый с выделением","ts_headline('english', title, websearch_to_tsquery('\"stars wars\"'),\n" +
                                                          "'StarSel=<mark>,StopSel=</mark>'"),

                ("265. Функции для валидации и определения JSON","json_typeof(value) IS NOT NULL\n"+
                                                                 ""+
                                                                  "val IS JSON\n"+
                                                                 "IS JSON scalar - скалярное ли\n"+
                                                                 "IS JSON array - массив ли\n"+
                                                                 "IS JSON object - объект\n"+
                                                                 "IS JSON object with unicue keys - объект с уникальными ключами\n"),

                ("266. Функции для создания JSON","json_build_object - создание объекта JSON\n"+
                                                  "json_build_array - создание массива JSON\n"+
                                                  "to_json('aaron'::text) возврат текста в типе JSON\n"+
                                                  "Создание строки JSON из запроса\n"+
                                                  "SELECT row_to_json(u) AS users_json FROM\n"+
                                                  "(SELECT * FROM users WHERE email= ' ') u\n"+
                                                  "json_agg(row_to_json(u)) - массив JSON строк\n"+
                                                  "Создать массив объектов JSON\n"+
                                                  "json_agg(\n"+
                                                  "json_build_object(\n"+
                                                  "'id', id,\n"+
                                                  "'email', email))\n"),

                ("267. Получение значений из JSON","::JSON) -> ключ - возвращает в формате JSON\n"+
                                                   "->> ключ - возвращает в формате текст\n"+
                                                   "-> ключ -> ключ - возвращает вложенный JSON\n"+
                                                   "-> ключ ->1 - возвращает элемент массива,число может быть отрицательным, считает с конца\n"+
                                                   "#>{customer,name} продвижение как по стрелкам.Формат json\n"+
                                                   "#>> формат текст\n"+
                                                   "если не найдет ничего вернет NULL\n"),

                ("268. Получение значений из JSONB","SELECT jsonb_path_query('JSON с массивом', '$.items[0].product' - возвращает элемент в формате JSON\n"+
                                                    "'$.status') #>> '{}'  без кавычек\n"+
                                                    ""),
                ("269.",""),

                ("270. Сравнение JSONB","SELECT '{\"a\":1, \"b\":2}'::jsonb @> '{\"a\":1}'::jsonb  - TRUE\n"+
                                       "SELECT '{\"a\":1, \"b\":2}'::jsonb <@ '{\"a\":1}'::jsonb - FALSE\n"+
                                       "'[apple, banana, cherry]'::jsonb @> '[apple,cherry]::jsob - TRUE\n'"+
                                       "::jsonb @> '{customer: {name: Alice}}' - сравнение вложенного JSONB\n"+
                                       "WHERE details @> '{status:shipped}' фильтр в запросе\n"+
                                       "WHERE details ->> status = shipped фильтр в запросе\n"),

                ("271. Проверка ключей JSONB","::jsonb ? 'status' - есть ли ключ status\n"+
                                              "SELECT '[apple, banana]' ? 'asdf' содержит ли элемент\n"+
                                              "::jsonb ?| array['status','created_at'] содержит ли какой нибудь ключ из массива\n"+
                                              "&| все совпадения\n"+
                                              ""),

                ("272. Преобразование JSONB в таблицу","SELECT * FROM jsonb_each('{\"a\":1}') - выведет два столбца ключ и значение\n"+
                                                       "jsonb_each_text() - выведет таблицу, где ключ и значение будет в текстовом формате\n"+
                                                       "lateral jsonb_each_text(столбец из таблицы с JSONB) - выведет дополнительные столбцы Key и Value\n"+
                                                       "SELECT * FROM jsonb_to_recordset('[{\"a\":1,\"b\":\"foo\"}]') AS t(a int, b text) создаст столбцы с названиями a и b, и значениями 1 и foo\n"+
                                                       "SELECT * FROM jsonb_to_recordset(jsonb_build_array('{\"theme\":\"light\"}'::jsonb)) AS t(theme text) преобразование сначала в массив а потом столбец\n"+
                                                       ""),
                ("273. Update JSON","Update config - обновить таблицу\n"+
                                    "set\n " +
                                    "settings = jsonb_set(settings,'{theme}', json_scalar('syntwave')::jsonb)\n"+
                                    "в столбце settings по ключу theme обновит значение на syntwave\n"+
                                    "set settings = settings - 'theme' удаление ключа theme\n"+
                                    "set details =json_set(details, ключ, значение) установка вложенного значения по ключу\n"+
                                    "set details = jsonb_set(details, '{items,0,price}',to_json(899)::jsonb\n установка в ключе items,в 0 значении-массиве,по ключу price значения 899\n" +
                                    "set details = jsonb_insert(details, '{items,0}','{\"price\": 199, \"product\":\"HeadP\"}'::jsonb, true)\n"+
                                    "добавление в массив если true, обновление если fasle\n"),


                ("274. Добавление индекса JSON","Первый вариант:\n"+
                                           "CREATE INDEX orders_json_email_idx ON orders_json(\n"+
                                           "((details -> 'customer' ->> 'email')::text));\n"+
                                           "Запустить поиск по индексу" +
                                           "WHERE details->'customer'->>'email'::text = '.com'\n"+
                                           "Второй вараинт:\n"+
                                           "column email text GENERATED ALWAYS AS(details->'customer'->>'email'::text) STORED\n"+
                                           "создание обычного индекса по email\n"),

                ("275.Индекс GIN для JSON","CREATE INDEX название ON таблица USING GIN(столбец) подходит для @>,?,?|\n"+
                                       "USING GIN(столбец json_path) - оператор по умолчанию\n"+
                                       "USING GIN(столбец json_path_ops) - подходит только @>\n"+
                                       ""),

                ("276.Создать расширение для vector","CREATE EXTENSION IF NOT EXISTS vector\n"+
                                                     ""),

                ("277. Пример с vector расширением","CREATE TABLE products_v(\n"+
                                                    "id BIGINT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,\n"+
                                                    "name TEXT,\n"+
                                                    "embedding VECTOR(4));\n"+
                                                    "INSERT INTO products_v(name, embedding) VALUES\n"+
                                                    "('Product A', '[1,2,3,4]')\n"+
                                                    "('Product B', '[10,11,12,13]')\n"+
                                                    "SELECT *, embedding <->[1,2,3,4] вычисляет расстояние в эвклидовой геометрии\n"+
                                                    "Результат цифры. Чем больше соответствия тем меньше\n"+
                                                    "ORDER BY embedding <->[1,2,3,4]"+
                                                    "<=> cosine для нормализованных\n"+
                                                    "<+> L1\n"+
                                                    "<#> Inner Product\n"),

                ("278.Создание векторных индексов","CREATE INDEX имя ON table using ivfflat(embedding vector_cosine_ops) with (lists=10)\n"+
                                                   "vector_ip_ops - указание оператора\n"+
                                                   "USING hnsw - более точен, но требует больше ресурсов\n"),

                ("279. Нормалализация базы данных","Это процесс организации данных в базе для мимнимизации избыточности и зависимостей\n"+
                                                   "Она помогает избежать аномалий при вставке, обновлений, удалений\n"+
                                                   "и упрощает схему базы данных\n"),

                ("280. Обратная нормализация базы данных","Обратная нормализация - это баланс между идеальной нормализацией и реальной потребностью\n"+
                                                          "производительностью и удобством работы с данными\n"),

                ("281. Кеширование таблицы TRUNCATE","Создание таблицы для кеширования\n"+
                                                     "Периодическое обновление кеша\n"+
                                                     "TRUNCATE TABLE name\n"+
                                                     "INSERT INTO name(column1, column2)\n"+
                                                     "SELECT FROM WHERE\n"+
                                                     "Полезен для сложных запросов, где актуальность данных не так важна\n"),

                ("282. Триггеры","Специальные хранимые процедуры, которые автоматически выполняются\n"+
                                 "при наступлении определенных событий\n"+
                                 "CREATE TRIGGER trigger_name\n"+
                                 "{BEFORE | AFTER | INSTEAD OF} момент срабатывания до, после или вместо\n "+
                                 "{INSERT | UPDATE | DELETE} привязка к событиям\n"+
                                 "FOR EACH{ROW, STATEMENT} {выполняются для строки, для всего оператора}\n"+
                                 "EXECUTE FUNCTION nameFunction\n"+
                                 "Включение и отключение триггера {ENABLE, DISABLE}\n"+
                                 "DROP TRIGGER name - удаление триггера\n"),

                ("283. Основные подходы для денормализации","1. Добавление вычисляемых столбцов\n"+
                                                            "2. Дублирование данных из связанных таблиц\n"+
                                                            "3. Объединение таблиц\n "+
                                                            "4. Создание агрегированных таблиц\n"+
                                                            "5. Иерархические структуры в одном столбце техника\\телефоны\\модель\n"+
                                                            "6. Использование JSON/JSONB для сложных структур\n"+
                                                            "7. Создание копий таблиц для разных целей\n"),

                ("284. Виды планов выполения запросов","EXPLAIN показывает статистику, без выполнения\n"+
                                                  "EXPLAIN ANALYZE показывает статистику с выполнением\n"+
                                                  "EXPALAIN (VEBROSE TRUE) дополнительная информация Output столбцов(FALSE по умолчанию)\n"+
                                                  "EXPLAIN (COSTS FALSE) оценивает ожидаемую нагрузку на каждом шагу. по умолчанию TRUE\n "+
                                                  "EXPLAIN (ANALYZE BUFFERS) используется только с ANALYZE\n"+
                                                  "   состоит из 2 основных частей:\n"+
                                                  "   shared read разделяемых чтений - чтение с диска\n"+
                                                  "   shared hit разделяемых обращений - чтение с кэша\n"+
                                                  "EXPLAIN (ANALYZE TIMING) время на каждом узле. По умолчанию TRUE\n"+
                                                  "EXPLAIN (ANALYZE SUMMARY) включает итоговую информацию\n"+
                                                  "   может работать и с ANALYZE по умолчанию TRUE\n"+
                                                  "EXPLAIN (FORMAT JSON) возвращает в разных форматах(XML,JSON,YAML)\n"+
                                                  "   TEXT по умолчанию\n"),

                ("285. Шаги SQL при выполнении","1.Компиляция и преобразование оператора SQL в выражение,\n"+
                                           "состоящие из высокоуровневых логических операций, логический план\n"+
                                           "2.Оптимизирует логический план и преобразует его в план выполнения\n"+
                                           "3.Выполняет(интерпретирует) план и возвращает результаты\n"),

                ("286.Секционированная таблица", "Основные типы секционирования:\n"+
                                                 "1. RANGE по диапазону FOR VALUES FROM\n" +
                                                 "2.LIST по списку значений FOR VALUES IN\n   "+
                                                 "3. HASH по хеш функции \n"+
                                                 "Создаем основную (родительскую) таблицу\n "+
                                                 " CREATE TABLE sales(\n"+
                                                 " id\n"+
                                                 "sale_date DATE\n"+
                                                 ") PARTITION BY RANGE(sale_date)\n"+
                                                 "Создаем секции (партиции)\n"+
                                                 "CREATE TABLE sales_q1 PARTITION OF sales\n"+
                                                 "FOR VALUES FROM ('2023-01-01) TO ('2023-04-01')\n"),

                ("287.Временные таблицы","CREATE TEMP TABLE\n"),

                ("288. Что такое транзакция?","Это последовательность операций с базой данных,\n"+
                                              "которая рассматривается как единое целое\n"+
                                              "BEGIN TRANSACTION или START TRANSACTION\n"+
                                              "Действия\n"+
                                              "COMMIT сохранение, если все успешно\n"+
                                              "ROLLBACK отмена всех изменений в транзакции\n"+
                                              "для промежуточного сохранения можно использовать SAVEPOINT\n"+
                                              "для отката к точке сохранения ROLLBACK TO SAVEPOINT"),


                ("289.Характеристики транзакций ACID","1. Атомарность(Atomacity) - транзакция выполняется полностью или не выполняется вообще\n"+
                                                      "2. Согласованность(Consistency) - транзакции переводит БД из одного согласованного состояния в другое\n"+
                                                      "3. Изолированность(Isolation) - параллельные транзакции не влияют друг на друга\n"+
                                                      "4. Долговечность(Durability) -результаты завершенной транзакции сохраняются даже после сбоев\n"),

                ("290.Уровни изоляции транзакций","1. READ UNCOMMITED можно читать незафиксированные изменения других транзакций\n"+
                                                  "2. READ COMMITED читаются только зафиксированные данные\n"+
                                                  "3. REPEATABLE READ  гарантирует, что повторные чтения в одной транзакции дадут одинаковый результат\n"+
                                                  "4. SERIALIZABLE самый строгий уровень, выполняются так, если бы они шли последовательно\n"),

                ("291. ВИДЫ Аномалии SQL","1. Потерянное обновление(lost update)\n"+
                                          "   Возникает когда две транзакции делают обновления\n"+
                                          "   Обновления первой транзакции перетираются обновлениями второй транзакцией\n"+
                                          "2.Грязное чтение(Dirty Read)\n"+
                                          "    чтение одной транзакции, незафисированных значений другой транзакции\n"+
                                          "    Postgres не поддерживает Read Uncommitted\n"+
                                          "3.Неповторяющиеся чтение(Nonrepeatetable Read)\n"+
                                          "   Когда одна транзакция читает одну и ту строку дважды,\n"+
                                          "   а другая транзакция поменяла строку. В итоге в первой транзакции два разных результата\n"+
                                          "4.Фантомное чтение. (Phantom Read)\n"+
                                          "   Когда одна транзакция выбирает строки по условию дважды,а другая в промежутке добавляет новую строку по условию\n"+
                                          "   В итоге в у первой транзакции разные результаты\n"+
                                          ""),

                ("292. Что такое MongoDb","Это документоориентированная база данных с необходимыми вам маштабируемостью\n+" +
                                          "и гибкостью, запросами и индексированием\n"),

                ("293. Какие преимущества PostgreSQL по сравнению с MySQL и SQLite?","1. Сложные данные Полезовательские типы\n"+
                                                                                     "2. Высокие требования к надежности ASID гарантии\n"+
                                                                                     "3. Аналитика и оконные функции лучше оптимизированы\n"+
                                                                                     "4. Расширенная возможность с функциями и операторами\n"),

                ("294.Чем отличается клиент psql от GUI-инструментов?","psql - консольный клиент\n"+
                                                                        "GUI графический инструмент\n "),

                ("295.Как подключиться к БД через psql и посмотреть список таблиц?","psql -U имя пользователя -d имя базы_данных -h хост -p порт\n"+
                                                                                    "-h и -p необязательно\n"+
                                                                                    "\\dt - список таблиц\n"+
                                                                                    "\\dt+ - с дополнительной информацией\n"+
                                                                                    "\\dn просмотр схем"),

                ("296.Что такое схема в контексте PostgreSQL?","schema - это именованный контейнер для объектов базы данных(таблиц, представлений)\n"+
                                                               "которая позволяет:\n"+
                                                               "1. Логически группировать связанные объекты\n"+
                                                               "2. Разделять права доступа на уровне схемы\n"+
                                                               "3. Избегать конфликты имен могут существовать одинкавые имена таблиц в одной БД\n"+
                                                               "SELECT schema_name FROM - просмотр схем\n"+
                                                               "CREATE SCHEMA имя -схема отдела кадров\n "+
                                                               "ALTER TABLE table_name SET SCHEMA - перемещение таблицы в схему\n"+
                                                               "DROP SCHEMA schema_name CASCADE\n"),

                ("297.Как получить справку по командам в psql?","\\? все доступные команды\n"+
                                                                "\\h список всех доступных SQL команд\n"+
                                                                ""),

                ("298.Чем numeric отличается от float и в каких случаях использовать каждый?","numeric(decimal) это число с плавающей точкой и заданной точностью. Медленный\n"+
                                                                                              "float это число с плавающей точкой и приближенной точностью. Быстрые\n"),

                ("299.В чем разница между char, varchar и text?","char(n) фиксированная длина,недостающую длину заполняет пробелами\n"+
                                                                 "varchar(n) длина до n\n"+
                                                                 "text для большого текста\n"),

                ("300.Как работают check constraint и domain type?","CHECK проверяемое значение для столбца или таблицы\n"+
                                                                    "CONSTRAIN название CHECK для отображения\n"+
                                                                    "DOMAIN это пользовательский тип данных на основе существующего,\n"+
                                                                    "но с дополнительными проверками для многоразового использования\n"+
                                                                    "CREATE DOMAIN имя AS TEXT\n"+
                                                                    "CHECK (VALUE )\n"+
                                                                    ""),

                ("301.Как хранятся UUID и зачем он нужен?","это 128 битный индефикатор, который гарантирует уникальность без подключения БД\n"),

                ("302.Какие типы лучше использовать для хранения даты и времени?","DATE дата без точностей\n"+
                                                                                  "TIME только время\n"+
                                                                                  "TIMESTAMP для точности\n"+
                                                                                  "INTERVAL для промежутков\n"),

                ("303.В чем разница между json и jsonb?","json - текст, как есть\n"+
                                                         "jsonb - бинарный\n"),

                ("304.Как задать массив строк в таблице и получить второй элемент?","names TEXT[]\n"+
                                                                                    "names[2]\n"),

                ("305.Зачем нужны generated columns?","Это столбцы, значения которые автоматически вычисляются на основе других столбцов таблицы\n"+
                                                      "1.Автоматическое поддержание целосности данных\n"+
                                                      "2. Упрощение запросов\n"+
                                                      "3. Оптимизация производительности\n"+
                                                      "4. Сокращение кода приложения\n"),

                ("306.Что такое composite types и где их использовать?","Это пользовательские типы данных, которые объединяют несколько полей\n"+
                                                                        "разных типов в одну структуру\n"+
                                                                        "1. Структуированность данные логически связаны\n"+
                                                                        "2. Повторное использование в других таблицах\n"+
                                                                        "3. Удобство запросов доступ к полям через точечную нотацию\n"+
                                                                        "4. можно интегрировать в json и обратно\n"),

                ("307. Как работает exclusion constraint и чем он отличается от unique?","UNIQUE это проверка на уникальность с помощью =\n"+
                                                                                         "EXCLUSE это сложная проверка на уникальность\n"+
                                                                                         "требует специальных операторов и методов\n"+
                                                                                         "чаще всего индексов GiST и SP-GiST"),

                ("308.Как работает B-Tree индекс?","сбалансированное дерево\n "+
                                                   "Это структура данных, которую СУБД используют для эффективного поиска, вставки и удаления.\n"+
                                                   ""),

                ("309. В чем отличие между primary key и secondary index?","Primary key всегда уникален, не может быть NULL, один на таблицу\n"),

                ("310.Что такое index selectivity?"," Селективность индекса - это метрика, которая показывает\n"+
                                                    "насколько уникальны значения в столбце\n"+
                                                    "Высокая селективность - много уникальных значений\n"+
                                                    "Чем выше селективность тем вероятнее работу по индексу\n"),

                ("311.Как работают partial indexes?","Индекс создается только для строк соответсвующих условию WHERE\n"+
                                                     "Условие должно быть детерменированным\n"),

                ("312.Зачем использовать covering index?","Это индекс, который содержит в себе нужные столбцы из таблицы\n"+
                                                          "Что позволяет выдавать результат без обращения к таблице\n"+
                                                          "подходит для часто запращиваемых данных\n"),

                ("313.Что такое функциональный индекс?","Это индекс, который создается на функцию, содержащие столбцы таблицы\n"),

                ("314.Когда использовать hash index?","Это тип индекса которые используют хеш функцию для быстрого доступа\n"+
                                                      "только для = IN\n"),

                ("315.Почему дублирующие индексы — это плохо?","1.Нагрузка на запись INSERT\n"+
                                                               "2. Бесполезное расходование дискового пространства\n"+
                                                               "3. Перегрузка оптимизатора запросов\n"+
                                                               "4. Путаница при сопровождении\n"),

                ("316.Как назвать индекс, чтобы сразу было понятно его назначение?","idx_таблица_столбец_какой индекс\n"),

                ("317.Как PostgreSQL выбирает индекс при наличии нескольких?","1. Генерация планов выполнения\n"+
                                                                              "2. Оценка стоимости\n"+
                                                                              "3. Выбор оптимального плана\n"),

                ("318.Что показывает EXPLAIN?","Это команда, которая показывает план выполнения запроса,\n"+
                                               "но не выполняет сам запрос\n"),

                ("319.Чем отличается EXPLAIN от EXPLAIN ANALYZE?","1. Фактически выполняет запрос и показывает реальные запросы\n"+
                                                                  "2. Дает реальную статистику.фактическое время выполнения каждой операции,количество отработанных строк,затраты ресурсов\n"+
                                                                  "3. Показывает расхождения между реальным и ожидаемым результатам\n"),

                ("320.Что такое cost в EXPLAIN и как его читать?","Это параметр, представляющий собой оценочную стоимость\n"+
                                                                  "выполнения операции в условных единицах\n"+
                                                                  "cost x..y\n"+
                                                                  "x - стоимость первой строке\n"+
                                                                  "y - стоимость выдачи всех строк\n"),

                ("321. Что такое sequential scan и когда он возникает?","Операция полного чтения таблицы\n"+
                                                                        "Выполняется когда:\n"+
                                                                        "1. Отсутсвует индекс или он неэффективен\n"+
                                                                        "2. Запрос выполняет все или почти все записи\n"+
                                                                        "3. Маленькая таблица\n"+
                                                                        "4. Статистика устарела\n"),

                ("322. Как узнать, какой индекс используется в запросе?","использовать explain(можно вызвать нужный индекс принудительно)\n"+
                                                                         "SELECT * FROM pg_indexes\n"),

                ("323.Какие компоненты обязательны для базового SELECT-запроса?","SELECT 1;\n"+
                                                                                 "SELECT * FROM table\n"),

                ("324.Что делает оператор WHERE?","Фильтрация данных и сокращение обработки\n"),

                ("325.Что такое агрегатные функции и какие они бывают?","Выполняют вычисления над набором значений и выдают единственный результат\n"+
                                                                        "Часто используются с GROUP BY\n"+
                                                                        ""),
                ("326.Как использовать оператор GROUP BY в запросах?","Это оператор группировки данных,\n"+
                                                                      "который объединяет  строки с одинаковыми значениями в указанных столбцах\n "+
                                                                      "и позволяет использовать агрегатные функции\n"),

                ("327.Чем отличается оператор HAVING от WHERE?","WHERE используется до группировки\n"+
                                                                "HAVING фильтрует после группировки, может использовать агрегированные функции\n"+
                                                                ""),

                ("328.Что такое CROSS JOIN?","Этот операция соединения таблиц, которая возвращает декартово произведение\n"+
                                             "строк из обеих таблиц. Каждая строка первой таблицы соединяется с каждой строкой второй таблицы\n"),

                ("329.Когда может быть полезен CROSS JOIN?","1. Генерация всех возможных вариантов\n"+
                                                             "2. Создание таблицы умножения\n"),

                ("330.Чем отличается CROSS JOIN от других типов соединений?","Не требует условий соединения и редко используется\n"),

                ("331.Что происходит, если одна из таблиц в CROSS JOIN пуста?","Вернет 0 строк\n"),

                ("332.Как избежать использования CROSS JOIN, если нужно соединить таблицы по определенному условию?","использовать явные JOIN\n"),

                ("333.Что делает INNER JOIN?","Это оператор соединения таблиц, который возвращает только те строки,\n"+
                                              "где есть совпадения в обеих таблицах по указанному условию\n"),

                ("334.Как избежать дублирования строк при использовании INNER JOIN?","1. Точно указывать желаемые столбцы\n"+
                                                                                     "2.Использовать DISTINCT\n"+
                                                                                     "3. Использовать GROUP BY\n"+
                                                                                     "4. Использовать корректные условия соединения\n"),

                ("335.Когда лучше использовать INNER JOIN?","1. Связывание таблиц по ключу\n"+
                                                            "2. Фильтрация данных через соединение\n"+
                                                            "3. Агрегация связанных данных\n"+
                                                            "4. Многотабличные запросы с четкими связами\n"+
                                                            "5. Оптимизация производительности\n"),

                ("336.Что произойдет, если в одной из таблиц нет совпадений для строки из другой таблицы?","Не будет в выдаче результата\n" +
                ""),

                ("337.Как объединить несколько таблиц с помощью INNER JOIN","Последовательно составить соединения таблиц по условию"),

                ("338.Чем отличается LEFT OUTER JOIN от RIGHT OUTER JOIN?","Это два типа внешних соединений, которые отличаются направлением\n"+
                                                                           "сохранения данных при отсутствии совпадений\n"),

                ("339.Когда стоит использовать OUTER JOIN вместо INNER JOIN?","1. Когда нужно отобразить все данные из главной таблицы\n"+
                                                                              "2. Поиска записей без взаимных соответствий в двух таблицах\n"+
                                                                              ""),
                ("340.Что происходит, если в OUTER JOIN нет совпадений?","строки без совпадений не отбрасываются, а \n"+
                                                                         "сохраняются в результате с NULL значениями "),

                ("341.Как объединить несколько таблиц с использованием LEFT OUTER JOIN?","Сохраняются все строки первой таблицы\n"+
                                                                                         "Если в левой части NULL то и в правой будет NULL\n"),

                ("342. Что такое FULL OUTER JOIN?","Это операция соединения, которая сохраняет все строки из обеих таблиц\n"+
                                                   "заполняя NULL - значениями отсутвующие соответствия\n"),

                ("343.Что такое подзапрос?","это SQL запрос вложенный внутрь другого запроса\n"+
                                            "Он позволяет выполнять сложные операции с данными,\n"+
                                            "используя результаты одного запроса в другом\n"),

                ("344.Как использовать подзапрос в операторе WHERE?","Фильтрация на основе подзапроса"),

                ("345. В чем разница между подзапросом в SELECT и подзапросом в FROM?"," в SELECT возвращается одно значение\n"+
                                                                                       "в каждой строке запроса\n"+
                                                                                       "FROM возвращает целую таблицу\n"+
                                                                                       "выполняется один раз\n"+
                                                                                       "требует аллиас\n"),
                ("346. Как оптимизировать использование подзапросов?","Менять IN на EXIST и наоборот. Сделать фильтрацию внутри подзапроса\n"+
                                                                      "Использовать JOIN, CTE, оконные функции"),

                ("347.Что происходит, если подзапрос возвращает несколько строк?","Нужно использовать IN, ALL, EXISTS или LIMIT 1\n"+
                                                                                  "Иначе будет ошибка\n"),

                ("348.В чем основное отличие LATERAL JOIN от обычного JOIN?","Подзапрос справа выполняется для каждой строки левой таблицы,\n"+
                                                                             "с возможностью доступа к ней"),

                ("349. Когда использование LATERAL JOIN может быть полезным?","1. Когда подзапросу нужны данные из текущей строки внешней таблицы.\n"+
                                                                              "2. Когда нужно получить ограниченное количество записей для каждой группы\n"+
                                                                              "3. Для генерации данных на основе значений строк\n"+
                                                                              "4. Когда нужно применять к каждому элементу массива\\JSON\n"),

                ("350.Приведите пример применения LATERAL JOIN в запросе.","SELECT d.department_name, e.employee_name, e.salary\n"+
                                                                           "FROM departments d\n"+
                                                                           "CROSS JOIN LATERAL(\n" +
                                                                           "SELECT employee_name, salary\n"+
                                                                           "FROM employees\n" +
                                                                           "WHERE department_id=d.department_id\n"+
                                                                           "ORDER BY salary DESC\n"+
                                                                           "LIMIT 3) e\n"),

                ("351. В чем отличие ROWS FROM от обычного подзапроса?","Объединяет результаты несколько функций в одну таблицу\n"+
                                                                        "SELECT * FROM ROWS FROM(функции) AS алиас\n"),

                ("352.Когда стоит использовать ROWS FROM?","1. Параллельная обработка связанных наборов данных\n"+
                                                           "2. Обработка JSON/массивов с сохранением структуры\n"+
                                                           "3. Генерация согласованных временных рядов\n"+
                                                           "4. Комбинирование данных разной длины\n"),

                ("353.Приведите пример использования ROWS FROM.","SELECT * FROM ROWS FROM(\n"+
                                                                 "unnest(ARRAY[1,2,3,4]),\n"+
                                                                 "unnest(ARRAY['a','b'])\n"+
                                                                 ") AS t(num,letter);\n"),

                ("354.Как можно заполнить пропуски в последовательности дат в PostgreSQL?","WITH date_range AS\n"+
                                                                                           "SELECT generate_series(\n"+
                                                                                           "'2023-01-01'::date,\n"+
                                                                                           "'2023-01-31'::date,\n"+
                                                                                           "'1 day'::interval\n"+
                                                                                           ")::date AS full_date)\n"+
                                                                                           "SELECT dr.full_date AS date,\n"+
                                                                                           "COALESCE(d.amount, 0) AS amount\n"+
                                                                                           "FROM date_range dr\n"+
                                                                                           "LEFT JOIN daily_date d ON dr.fuul_date = d.date\n"+
                                                                                           "ORDER BY dr.full_date\n"),

                ("355.Что такое рекурсивный CTE и как он помогает при заполнении пропусков?","это специальная конструкция SQL,\n"+
                                                                "которая позволяет обрабатывать иерархические или последовательные данные\n"+
                                                                "путем повторяющегося выполнения запроса до достижения заданного уровня\n"),

                ("356.Приведите пример запроса для заполнения пропусков в последовательности Рекурсия.","WITH RECURSIVE date_range AS(\n"+
                                                                                "SELECT \n"+
                                                                                "'2023-01-01'::DATE AS date,\n"+
                                                                                "'2023-01-31'::DATE AS end_date\n"+

                                                                                "UNION ALL\n"+
                                                                                "SELECT\n"+
                                                                                " date +1,\n "+
                                                                                "end_date\n"+
                                                                                "FROM date_range\n"+
                                                                                "WHERE date < end_date\n"+
                                                                                ")\n" +
                                                                                "SELECT d.date AS missing_date\n"+
                                                                                "FROM date_range AS  d\n"+
                                                                                "LEFT JOIN events e  ON d.date=e.event_date\n"+
                                                                                "WHERE e.event_date IS NULL\n"+
                                                                                "ORDER BY d.date\n"),

                ("357.Почему важно избегать подзапросов в SQL?","Коррелированные подзапросы выполняются для каждой строки внешнего запроса\n"+
                                                                "Множественные вложености увеличивают время выполнения экспонтециально\n"),

                ("358.Какой эффект дает удаление подзапросов в запросах?","Улучшение производительности\n"+
                                                                          "Снижение нагрузки на СУБД\n"+
                                                                          "Улучшение читаемости кода\n"),

                ("359.Приведите пример запроса до и после удаления подзапросов.","SELECT * FROM orders\n"+
                                                      "WHERE customer_id IN(SELECT id FROM customers WHERE premium = true)\n"+
                                                      "SELECT o.*\n"+
                                                      "FROM orders o\n"+
                                                      "JOIN customers c ON 0.customer_id = c.id AND c.premium = true;"),

                ("360.Чем отличается UNION от UNION ALL?","UNION удаляет дубликаты,работает медленнее потому что делает для этого сортировку\n"),

                ("361.Когда лучше использовать INTERSECT?","Когда нужно найти общие элементы в двух таблицах\n"),

                ("362. Приведите пример запроса с использованием UNION ALL.","SELECT id FROM A --(1,2,3)\n"+
                                                                              "UNION ALL\n"+
                                                                              "SELECT id FROM B --(3,4,5)\n"+
                                                                              "1,2,3,3,4,5\n"),

                ("363.Что такое generate\\_series в PostgreSQL?","это встроенная функция генерации полседовательных значений\n"+
                                                                 "Особенно полезна для создания временных рядов и числовых последовательностей\n"),

                ("364. Когда стоит использовать set generating functions?","1. Работа с массивами и JSON\n"+
                                                                           "2. Генерация тестовых данных\n"+
                                                                           "3. Анализ временных рядов\n"+
                                                                           "4. Обработка иерархических данных\n"+
                                                                           "5. Разбор строковых данных\n"+
                                                                           "6. Создание матриц и кросс-соединений\n"+
                                                                           ""),

                ("365.Приведите пример использования generate\\_series.","INSERT INTO users(id, name, registration_date)\n"+
                                                                         "SELECT id,'user' || id,\n"+
                                                                         "generate_series('2023-01-01'::date, '2023-12-31'::date, '1 day'::interval)::date\n"+
                                                                         "FROM generate_series(1,1000) AS id"),

                ("366. Как индексы влияют на производительность JOIN-запросов?","Ускорение поиска совпадений\n"),

                ("367.Какие типы индексов лучше всего подходят для улучшения производительности JOIN-запросов?","B-tree и hash\n"),

                ("368.Когда использование индексов на соединениях может привести к ухудшению производительности? ","При работе с маленькими таблицами\n"+
                                                                                                       "низкой селективности\n"+
                                                                                                      ""),

                ("369.В чём отличие ROLLUP от GROUPING SETS?","GROUP BY ROLLUP(a,b,c)\n"+
                                                              "GROUP BY GROUPING SETS((a,b,c),(a,b),(a),())\n"+
                                                              ""),
                ("370.Что вернёт GROUPING SETS ((a), (b), ())?","GROUP BY a,GROUP BY b, итого"),
                ("371. Как определить, была ли строка сгенерирована ROLLUP?","GROUPING(столбец) возвращает 0, если является\n"+
                                                                             "1 - если нет\n"),
                ("372.В чём отличие ROW_NUMBER() и RANK()?","ROW_NUMBER уникальный номер,сплошная нумерация\n"+
                                                            "RUNK одинаковый ранг для одинаковых значений"),

                ("373.Как работает LAG(column, 1)?","Это оконная функция, которая позволяет получить значение из предыдущей строки, 1 -смещение\n"),

                ("374. SUM(value) OVER (PARTITION BY user_id ORDER BY date)?","1. Создает отдельные группы для каждого пользователя\n"+
                                                                              "2. Нарастающий итог рассчитывается в рамках одной группы\n"+
                                                                              "3. При смене user_id сумма сбрасывается\n"+
                                                                              "ORDER BY date\n"+
                                                                              "Определяет порядок расчета нарастающего итога\n"+
                                                                              "Сумма считается от первой до текущей строки в группе\n"),

                ("375.Что такое CTE и зачем он нужен?","это временный результат запроса, который можно использовать в последующих SQL опреациях\n"+
                                                       "Это именованный подзапрос, определяемый с помощью конструкции WITH\n"+
                                                       "разбитие сложных запросов на логические блоки\n"+
                                                       "рекурсивные запросы\n"+
                                                       "несколько раз обратится к одному результату\n"+
                                                       "замена временных таблиц. Материализация запроса\n"),


                ("376.Можно ли использовать CTE внутри CTE?","Можно через запятую сделать цепочку\n"),

                ("377. Отличие CTE от подзапроса в FROM?","У CTE лучшая читаемость, множественное использование,возможно будет быстрее\n"),

                ("378.Какие 2 части есть у рекурсивного CTE?","Якорная часть -> UNION ALL ->Рекурсивная часть\n"),

                ("379.Как ограничить количество итераций в рекурсивном CTE?","Через WHERE"),

                ("380.Что произойдёт, если рекурсивный CTE не имеет выхода?","Завершится с ошибкой\n"),

                ("381.Что делает COALESCE(a, b, c)? ","возвращает первое не NULL"),

                ("382.Почему a = NULL не работает как ожидалось?","Нельзя сравнить неизвестное с NULL"),

                ("383.Чем отличается IS DISTINCT FROM от !=?","DISTINCT возврашает TRUE и FALSE\n"),

                ("384.В чём разница между обычным и материализованным view?","Обычное это виртуальная таблица, хранит в себе запрос\n"+
                                                                             "возвращает актуальные данные, но может быть медленнее\n"+
                                                                             "материализованное содержит в себе физическую копию\n"+
                                                                             "данные могут быть устаревшими, требуется обновление\n"+
                                                                             "быстрее так как читает предварительно вычисленные записи\n "),

                ("385.Как обновить материализованное представление?","REFRESH MATERIALIZED VIEW \n"),

                ("386.Можно ли использовать ORDER BY в обычном VIEW","Можно, но лучше делать при создании. Без этого нет гарантий\n"),

                ("387.Как удалить дубликаты, оставив только одну строку?","DISTINCT"),

                ("388.Почему DISTINCT не всегда помогает при удалении дублей из таблицы?","оставит только один NULL\n"+
                                                                                          "нужно четко задавать столбцы по уникальности\n"),

                ("389.Как быстро найти дубликаты по нескольким колонкам?","DISTINCT ON(столбцы...)"),

                ("390.Что делает ON CONFLICT (id) DO UPDATE?","Делает другую заданную операцию в случае возникновения конфликта\n"),

                ("391.Что делает RETURNING * в INSERT?","Возвращает все строки вставленной таблицы\n"),

                ("392.Можно ли использовать RETURNING с UPDATE?","Да будет получена строка с обновлениями\n"),

                ("393.Как работает WHERE (a, b) IN ((1, 2), (3, 4))?","Возвращает true при полном совпадении\n"),

                ("394.Какие ограничения есть у row value comparisons в Postgres?","Сравнение строк значений\n"+
                                                                                  "(a,b LIKE a,b) - не работает\n"+
                                                                                  "NULL работает иначе\n"+
                                                                                  "Ограничение по количеству элементов\n"+
                                                                                  "Ограничение по типу и работе с агрегатными фуцнкциями"),

                ("395.Чем отличается VALUES (1,2), (3,4) от обычного INSERT ... VALUES?","VALUES это самостоятельная констукция:\n"+
                                                                                         "В подзапросах\n"+
                                                                                         "в составе CTE\n"+
                                                                                         "в JOIN\n"+
                                                                                         "как источник данных в INSERT и SELECT\n"),

                ("396.Что такое generated column и как её создать?","Это столбец который вычисляется на основе других столбцов\n"+
                                                                    "бывают STORED и VIRTUAL\n"+
                                                                    "имя тип GENERATED ALWAYS AS(выражение) STORED"),

                ("397.Как связаны COALESCE и generated column при создании дефолтных значений?","Coalesce позволяет избежать NULL значений"),

                ("398.Можно ли использовать выражение с COALESCE внутри GENERATED ALWAYS AS?","Да"),

                ("399.Почему ILIKE '%word%' работает медленно на больших таблицах?","B-tree индекс не поддерживает % в начале\n"+
                                                                                     "Регистронезависимый поиск\n"+
                                                                                     ""),

                ("400. Чем SIMILAR TO отличается от LIKE?","SIMILAR TO использует простые регулярные выражения\n"),

                ("401.Как ускорить LIKE 'abc%'?","B-Tree индекс\n"+
                                                 "функциональный индекс для регистронезависмого поиска\n"+
                                                 "GIN индекс\n"+
                                                 "частичный индекс\n"),

                ("402.Что делает to_tsvector('english', text)?","Разбивает текст на лексемы, убирает предлоги и артикулы на основе языка"),

                ("403.Что делает оператор @@?","Выполняет проверку на соответствие между tsvector(индексированым текстом)\n"+
                                               "tsquery(поисковым запросом)\n"),

                ("404.Почему rank может быть полезен при полнотекстовом поиске?","Это функция ранжирует релеватность результата\n "),

                ("405.Чем websearch_to_tsquery отличается от plainto_tsquery?","planto_tsquery не поддерживает OR NOT и не сохраняет порядок слов\n"),

                ("406.Как обработается запрос \"deep learning\" -neural в websearch_to_tsquery?","Точное совпадение на фразу DEEP LEARING с исключением NEURAL"),

                ("407.В чём отличие ts_rank и ts_rank_cd?","ts_rank базовый алгоритм оценивает количество совпадений без близкости слов к друг другу\n"+
                                                           "ts_rank_cd с учетом взаимного расположения\n"),

                ("408.Как ts_rank определяет, какой результат релевантнее?","Частота терминов, вес полей, длина документа\n"),

                ("409. Как улучшить сортировку результатов по релевантности?","Настройка весов\n"+
                                                                               "Выбор функции ранжирования\n"+
                                                                               "Нормальзация по длине документа\n"),

                ("410.Какой индекс нужен для tsvector?","GIN можно с опцией и без нее\n"+
                                                        "GiST\n"+
                                                        ""),

                ("411.Почему tsvector стоит выделить в отдельную колонку?","Предварительное вычисление\n"+
                                                                           "Индексирование оптимальное\n"+
                                                                           "Избегает многократногшо парсинга текста"),

                ("412.Как создать индекс для виртуального tsvector-выражения?","CREATE INDEX idx ON table_name\n"+
                                                                               "USING gin(to_tsvector('english', text_column))"),

                ("413.Что делает ts_headline?","Это инструмент для выделения найденных теминов в тексте\n"),

                ("414.Какие параметры можно настроить в ts_headline?","StartSel, StopSel начало и конец слова\n"+
                                                                      "MaxFragments количество возвращаемых фрагментов\n"+
                                                                      "MaxWords,MinWords - количестов слов во фрагменте\n"+
                                                                      "FragmentDemiliter разделить между фрагментами\n"+
                                                                      "HighLigthAll если true это выделение слов"),

                ("415. В чем ключевое различие между JSON и JSONB?","JSON хранится как есть, быстрый\n"+
                                                                    "JSONB хранит в бинарном формате, удаляет лишние пробелы и оставляет только последнее значение по ключу\n"),
                ("416.Почему JSONB предпочтительнее при поиске по ключам и значению?","Преобразование в бинарное дерево\n"+
                                                                                      "поддержка специальных операторов @>\n"+
                                                                                      "возможность индексирования\n"+
                                                                                      "оптимизированные функции доступа jsonb_path_query\n"),

                ("417.Можно ли преобразовать JSON в JSONB и наоборот?","::jsonb::json\n"+
                                                                       "to_jsonb() to_json()\n"),

                ("418.Что произойдет при попытке вставить невалидный JSON в колонку типа JSON?","Выкинет ошибку с описанием\n"),

                ("419.Можно ли явно валидировать JSON-строку до вставки?","Через функцию или TryCAST "),

                ("420.Чем опасна вставка \"валидного, но неожиданного\" JSON?","Проблема безопасности\n"+
                                                                               "нарушение структуры данных\n"+
                                                                               "проблемы производительности\n"+
                                                                               "логические ошибки\n"),

                ("421.Какие функции используются для создания JSON-объектов и массивов?","jsonb_build_object()\n"+
                                                                                         "jsonb_object()\n"+
                                                                                         "jsonb_build_array()\n"+
                                                                                         "jsonb_object_agg()\n"),

                ("422.В чем разница между row_to_json и json_build_object?","Преобразование строки таблицы\n"+
                                                                            "Ключи это название столбцов, а значение строки\n"+
                                                                            "json_build_object ручное создание. Требует явного указания ключ:значения\n"),

                ("423.Как создать массив JSON объектов из результата запроса?","jsonb_agg(row_to_json(таблица))\n"+
                                                                                "array_to_json(array_agg(row_to_json(таблица)))"),

                ("424.Чем отличаются операторы ->, ->> и #>>?","-> вложенный json\n"+
                                                               "->> преобразование вложенного json в text\n"+
                                                               "#>> путь"),

                ("425.Как получить элемент массива по индексу?","[номер], array_element(столбец, номер)\n"+
                                                                "json_column->'array_key'->1"),

                ("426.Как извлечь вложенное значение по пути?","#>,#>>, jsonb_path_query(столбец,путь), json_extract_path(json,что извлечь)\n"),

                ("427.Что делает оператор @>?","Содержит ли первый документ часть второго\n"),

                ("428.Сработает ли @> с JSON?","Нет. Можно проверить через преобразоание "),

                ("429.Как проверить, есть ли ключ \"status\" в JSONB?","? - простое наличие ключа\n"+
                                                                       "jsonb_exists(jsonb,'status') возвращает true или false\n"+
                                                                       "#? для вложенных ключей\n"+
                                                                       "jsonb_exists_path(путь)"),

                ("430.Как проверить наличие хотя бы одного из ключей?","?| OR"),

                ("431.Какая функция превращает JSON в табличное представление?","jsonb_to_recordsetjson)"),

                ("432.Зачем нужен LATERAL при работе с json_to_recordset?","1. Позволяет обратится к предыдущей таблице\n"+
                                                                           "2. Позволяет обрабатывать данные последовательно,когда следующий шаг зависит от предыдущего\n"+
                                                                           "3. Фильтрация и комбинирование с другими функциями"),

                ("433.Как указать схему (тип) возвращаемых полей? ","Явное указание внутри запроса"),

                ("434.Как обновить значение по ключу в JSONB?","UPDATE table_name\n "+
                                                               "SET jsonb_column = jsonb_column || {'key':'new_value'}::jsonb\n"+
                                                               "json_set()\n"),
                ("435.Что делает jsonb_set без параметра create_missing?","Создает ключи только из json"),

                ("436.Как удалить ключ из JSONB?","UPDATE table_name\n"+
                                                  "SET jsonb_column = jsonb_column - 'key_to_remove'\n"+
                                                  "#- удаление по пути\n"+
                                                  "jsonb_set(установить null)\n"+
                                                  "jsonb_delete(column, 'key')"),

                ("437.Какой тип индекса использовать для поиска по ключам в JSONB?","GIN GiST"),

                ("438.Почему неэффективен BTree для JSONB?","Потому что требуется  четкий порядок сортировки"),

                ("439.Что делает jsonb_path_ops?","специальный оператор для GIN индексов, оптимизированный для работы с JSON"),

                ("440.Что означает “Seq Scan” в плане выполнения запроса?","Последовательное сканирование таблицы\n"),

                ("441.Как узнать, какой шаг в EXPLAIN ANALYZE занимает больше всего времени?","actual time или rows * loops"),

                ("442.Чем отличается EXPLAIN от EXPLAIN ANALYZE?","EXPLAIN показывает предполагаемый план выполнения,а\n "+
                                                                  "EXPLAIN ANALYZE фактически выполняет запрос\n"),

                ("443.Почему индекс может не использоваться, даже если он есть?","Неселективность запроса\n"+
                                                                                 "Несоответствие типа данных\n"+
                                                                                 "использование функции в условиях\n"+
                                                                                 "маленькая таблица\n"),

                ("444.Какие типы индексов есть в PostgreSQL?","B_tree\n"+
                                                              "HASH\n"+
                                                              "GIN\n"+
                                                              "GiST\n"+
                                                              "SP-GiST\n"+
                                                              "BRIN\n"+
                                                              "Bloom для большого количества =\n"),

                ("445.Что такое селективность и как она влияет на выбор плана?","Это статистическая характеристика, показывающая,\n"+
                                                                                "какая доля строк таблицы удовлетворяет условию запроса\n"+
                                                                                "0- условие не выбирает ни одной строки. Высокая селективность\n"+
                                                                                "1 - условие выбирает все строки\n"),

                ("446.Чем опасны CTE с точки зрения производительности?","Неудачное пстроение запроса\n"+
                                                                         "Постоянное переиспользование с вычислением\n"),

                ("447.Когда лучше использовать оконные функции, а не подзапросы?","Аналитические вычисления над группами строк\n"+
                                                                                  "Вычисления с доступом к соседним строкам\n"+
                                                                                  "Агрегация без сворачивания строк\n"+
                                                                                  "Накопительные итоги\n"+
                                                                                  "Разбиение на страницы\n"),

                ("448.Что делает ROW_NUMBER() OVER (PARTITION BY ...)?","Это оконная функция которая присваивает уникальный последовательный номер,\n"+
                                                                        "каждой строке в пределах группы\n"),

                ("449. Что такое атомарность транзакции?","Гарантия что транзакция либо выполняется полность или вообще не выполняется"),

                ("450.В чём отличие COMMIT и ROLLBACK?","Commit фиксация изменений\n"+
                                                        "ROLLBACK отмена всех изменений\n"),

                ("451. Как транзакции взаимодействуют с блокировками?","Блокировки обеспечивают изоляцию транзакций\n"+
                                                                       "согласованость данных\n"),

                ("452.Какие уровни изоляции поддерживает PostgreSQL?","Read Uncommitted, Read Committed, Repeatable Read, Serializable\n "),

                ("453.Что такое phantom read и при каком уровне оно возможно?","Одна транзакция видит новые строки после добавления другой транзакцией после начала первой\n"+
                                                                               "Read Committed\n"),

                ("454. В чём отличие Repeatable Read и Serializable?","Работают оба по снимку, но serializable прервет пересекающиеся транзакцию\n"),

                ("455. Какие типы блокировок есть в PostgreSQL?","Блокировки таблиц\n"+
                                                                 "Блокировки строк\n"+
                                                                 "Блокировка страниц(операции с индексами)\n"+
                                                                 "Транзакционные блокировки\n"+
                                                                 "Предикатные блокировки(блокируют условия)\n"+
                                                                 ""),

                ("456.Как посмотреть текущие блокировки в базе?","SELECT locktype, relation::regclass, mode, transactionid AS tid,\n"+
                                                                 "virtualtransaction AS vtid, pid, granted\n"+
                                                                 "FROm pg_locks"),

                ("457.Что делать, если транзакция повисла в состоянии блокировки?","Находим блокировку через большой код\n"+
                                                                                   "SELECT pg_terminate_backend(pid)\n"+
                                                                                   "FROM pg_stat_activity\n"+
                                                                                   "WHERE pid =[blocking_pid]"),

                ("458.Что такое 3-я нормальная форма (3NF)?","это этап нормализации реляционной базы данных, при котором таблица\n"+
                                                             "уже находится во второй нормальной форме(2NF), и в ней отсутствуют транзитивные зависимости\n"+
                                                             "между неключевыми атрибутами\n"),

                ("459.Зачем нужна нормализация?","это огранизация данных в базе для минимизации избыточности и аномалий\n"+
                                                 "Одинаковые данные хранятся в нескольких местах\n"+
                                                 "Избегать аномалий вставки и удаления\n"+
                                                 "Нормализация проще в обслуживании(изменения вносятся в одном месте, меньше риск неодназначных данных)\n"+
                                                 "повышение целосности за счет внешних ключей\n"+
                                                 ""),

                ("460.В чём минусы чрезмерной нормализации?","Чем больше таблиц тем болше JOIN\n"+
                                                             "данные которые должны быть вместе разделены\n"+
                                                             "падает скорость вставки\n"),

                ("461.Когда денормализация — это нормально?","Частые чтения и редкие обновления\n"+
                                                             "Критична производительность(OLTP,аналитика)\n"+
                                                             "Данные статичны(справочники, архивные записи)\n"+
                                                             "Система масштабируется горизонтально(NoSQL, кеши)\n"),

                ("462.Что можно использовать вместо денормализации? ","Материализированные представления\n"+
                                                                       "Индексирование и кеширование\n"),

                ("463.В чём риск денормализации? ","Риск нарушения целости данных\n"+
                                                   "Усложение обновлений\n"+
                                                   "Увеличение объема данных\n"+
                                                   "Изменение структуры данных становится труднее\n"),
                ("464.Чем MongoDB отличается от реляционных баз данных в плане структуры хранения данных?",""+
                                                   "1. Данные хранятся в документах(JSON-подобные BSON-структуры)\n"+
                                                   "2. Нет JOIN\n"+
                                                   "3. Схема не обязательна - разные документы в одной коллекции\n"+
                                                   "могут иметь разные поля\n"+
                                                   "4. Поддерживает массивы и вложенные объекты прямо в документе\n"+
                                                   "5. масштабирование(sharding) встроенно и работает из под коробки\n"),

                ("465. Что такое BSON, и чем он отличается от JSON?","это бинарный формат хранения данных,\n"+
                                                                     "используемый в MongoDB для эффективной работы с документами.\n"+
                                                                     "По сути, это улучшенная бинарная версия JSON с доплнительными возможностями\n"+
                                                                     "Поддержка специфических типов(ObjectId, ISODate, BinData)\n"+
                                                                     "Быстрый парсинг. не нужно преобразовать даты и числа в текст\n"),

                ("466.  Как документы могут быть организованы внутри коллекции в MongoDB?","1. Плоская структура(Flat Documents) минимальная вложенность\n"+
                                                                                           "2. Вложенные документы(Embedded Documents)\n "+
                                                                                           "      Документы содержат другие документы как значения полей\n"+
                                                                                           "      Естественно отражает отношения 'один-ко-многим' в пределах одного документа\n"+
                                                                                           "3. Ссылочная модель(Document References)\n"+
                                                                                           "      Документы ссылаются на другие документы через индефикаторы\n"+
                                                                                           "      Аналог отношений в реляционных базах\n"+
                                                                                           "4. Гибридный подход\n"+
                                                                                                  "Комбинация вложенных документов и ссылок\n"+
                                                                                                  "Часто используемые данные встраиваются, редко используемые - выносятся\n"+
                                                                                           "5. Денормализованные структуры\n"+
                                                                                               "Намеренное дублирование данных для ускорения запросов\n"+
                                                                                               "Часто используется в аналитических системах "),

                ("467.Как создать индекс на поле в MongoDB?","db.users.createIndex({username: 1})\n"+
                                                             "db.users.createIndex({username:1, age:-1})\n"+
                                                             "db.users.createIndex({username:1},{unique:true})\n"+
                                                             "db.users.createIndex({username: text})\n"+
                                                             "db.users.createIndex({username:1},{partialFilterExpression:{isActive:true}})\n"+
                                                             "db.users.createIndex({\"address.city\":1}) - на вложенное поле\n"+
                                                             "db.users.createIndex({tags:1})"),
                ("468.Как индексы могут улучшить производительность запросов?","Индексы в MongoDB работают аналогично оглавлению в книге\n"+
                                                                               "они позволяют быстро находить данные без полного сканирования всей коллекции\n"+
                                                                               "Замена COLLSCAN(полное сканирование) на IXSCAN(сканирование по индексу B-tree) "),

                ("469.Что такое агрегатные запросы в MongoDB?","Это аналог GROUP BY, JOIN и оконных функций, но с более гибким синтаксисом\n"+
                                                               "$match Фильтрация документов\n"+
                                                               "$group группировка\n"+
                                                               "$sort\n"+
                                                               "$project аналог SELECT\n"+
                                                               "$lookup аналог Left Join\n"+
                                                               "$unwind разворачивание массивов\n"+
                                                               "$count\n"+
                                                               "$limit"),

                ("470. Как можно выполнить группировку данных в MongoDB?","db.collection.aggregate([\n"+
                                                                          "{\n"+
                                                                          "$group: {\n"+
                                                                          "  _id: \"$группируемое_поле\", //Поле для группировки \n"+
                                                                          "  поле_результата: {$оператор: \"$поле\"} // вычисляемые значения\n "+
                                                                          "}\n"+
                                                                          "}\n"+
                                                                          "])\n"),
                ("471.Как работает оператора $match в агрегации? ","Оператор $match в агрегационных пайплайнах MongoDB выполняет фильтрацию документов\n"+
                                                                   "аналогично методу find(). Он отбирает только те документы,\n"+
                                                                   "которые соответсвуют заданным условиям, и передает их следующим стадиям пайплаина\n"+
                                                                   "db.collection.aggregate([\n"+
                                                                   "{\n"+
                                                                   "$match: {\n"+
                                                                   "поле: условие\n"+
                                                                   "}\n"+
                                                                   "}\n"+
                                                                   "])"),

                ("472.Что такое OLAP-куб?","Это многомерная структура данных, оптимизированная для быстрого анализа\n"+
                                           "больших объемов информации\n"),

                ("473.В чем отличие между OLAP и OLTP?","    OLAP это анализ больших исторических данных для\n"+
                                                        "Оптимизирован для быстрого чтения и анализа больших наборов данных\n"+
                                                        "Денормализованные схемы(звезда, снежинка) или многомерные кубы\n"+
                                                        "Анализирует большие исторические архивы\n"+
                                                        "ClickHouse,Amazon Redshift, snowflake\n"+
                                                        "Аналитики, руководители\n"+
                                                        "Данные загружаются периодически, изменяются редко\n"+
                                                        "   OLTP обработка операционных транзакций в реальном времени\n"+
                                                        "Короткие, простые (вставка,обновление, удаление)\n "+
                                                        "Высокая скорость записи и чтения отдельных записей\n"+
                                                        "Нормализованные таблицы(минимизация избыточности)\n"+
                                                        "Работает с текущими, часто изменяемыми данными\n"+
                                                        "PostgreSQL\n"+
                                                        "Данные постоянно обновляются"),
                ("474.Какой основной принцип отличается OLAP от OLTP в плане архитектуры?","Архитектура OLTP: \"Быстрые транзакции\""+
                                                                                           "1. Нормализованные таблицы(3NF и выше)\n"+
                                                                                           " Данные разбиты на множество связанных таблиц для минимизации дублирования\n"+
                                                                                           "2. ACID гарантии\n"+
                                                                                           "   Каждая транзакция должна быть атомарной и согласованной\n"+
                                                                                           "3. Высокая конкуренция за запись\n"+
                                                                                           "Архитектура OLAP: \"Анализ больших данных\""+
                                                                                           "1. Денормализованные схемы: Звезда и снежинка\n"+
                                                                                           "2. Колоночное хранение(вместо строчного)\n"+
                                                                                               "Данные хранятся по столбцам,что ускоряет агрегацию(SUM)\n"+
                                                                                           "3. OLAP кубы заранее вычисляют суммы\\средние для ускорения запросов\n"),

                ("475.Почему OLAP-системы часто требуют сложной инфраструктуры?","1.Обработка огромных данных\n"+
                                                                                 "2. Специфические модели хранения: колоночные базы данных, многомерные кубы, распределенные хранилища\n"+
                                                                                 "3. Высокие вычислительные затраты:сканирование миллионов строк,множественные GROUP BY. \n"+
                                                                                 "4. ETL - конвейры. Данные должны извлекаться из OLTP источников, очищаться и трансфармироваться, загружаться в оптимизированное хранилище\n"+
                                                                                 "5. Масштабируемость OLAP системы часто строятся на кластерах из сотен узлов, репликации данных между дата-центрами\n"+
                                                                                 "6. Оптимизации для аналитики. Предварительные агрегаты, индексы для ускорения запросов, кэширование результатов\n"),

                ("476.Формы нормализации","1NF\n"+
                                          "Каждый элемент в столбце имеет свой первичный ключ\n"+
                                          "2NF\n"+
                                          "Отсутствие частичных зависимостей от первичного ключа у каждой сущности свой первичный ключ. Деление на таблицы\n"+
                                          "3NF\n"+
                                          "неключивые атрибуты незвисят от других не ключевых атрибутов\n"+
                                          "BCNF\n"+
                                          "у каждой функциональной зависимости X->Y, X должен быть суперключом\n"+
                                          "4NF\n"+
                                          "нет нетравиальных многозначных зависимостей\n"+
                                          "5NF\n"+
                                          "нет нетравиальных зависимостей\n"),

                ("477. Стандартные опрерации PostgreSQL","Создание таблицы:\n"+
                                                         "CREATE TABLE [IF NOT EXISTS] table_name(\n"+
                                                         "column name\n"+
                                                         ")[WITH допы]\n"+"" +
                                                         "Изменение таблицы:\n"+
                                                         "ALTER TABLE table_name ADD COLUMN column_name data_type\n"+
                                                         "ALTER TABLE table_name DROP COLUMN [IF EXISTS] column_name [CASCADE]\n"+
                                                         "ALTER TABLE table_name RENAME COLUMN old_name TO new_name\n"+
                                                         "ALTER TABLE table_name ALTER COLUMN column_name TYPE new_data_type\n"+
                                                         "ALTER TABLE table_name ALTER COLUMN column_name SET DEFAULT value\n"+
                                                         "ALTER TABLE table_name ALTER COLUMN column_name DROP DEFAULT\n"+
                                                         "ALTER TABLE table_name ADD CONSTRAINT constraint_name constraint_definition\n"+
                                                         "ALTER TABLE table_name DROP CONSTRAINT [IF EXISTS] constraint_name [CASCADE]\n"+
                                                         "Удаление таблицы:\n"+
                                                         "DROP TABLE [IF EXISTS] table_name [CASCADE | RESTRICT]\n"+
                                                         "TRANCATE [TABLE] [ONLY] table_name [RESTART IDENTITY | CONTINUE IDENTITY] [CASCADE | RESTRICT]\n"),

                ("478.Операторы сравнения в MongoDB","1. $eq: = \n"+
                                                     "2. $ne: !=\n"+
                                                     "3. $gt: >\n"+
                                                     "4. $gte: >=\n"+
                                                     "5. $lt: <\n"+
                                                     "6. $lte: <=\n"+
                                                     "7. $in: равно любому из\n"+
                                                     "8. $nin: неравно любому значению\n"+
                                                     "9. $exists: true есть ли такое поле\n "+
                                                     "10. $type проверка типа данных"),

                ("479. Проекция C#","Позволяет преобразовать объект одного типа в объект другого типа\n"+
                                    "с помощью оператора Select\n"+
                                    "var names= from p in people select p.name\n"+
                                    "SELECT(Func<TSourse>,<TResult> selector)\n"+"" +
                                    "var personel = from p in people\n"+
                                    "select new\n "+
                                    "{\n"+
                                    "FirstName=p.Name\n"+
                                    "Year=DateTime.Now.Year - p.Age\n"+
                                    "}\n"),

                ("480.Переменные let","var personnel = from p in people\n"+
                                      "let name = $\"MR.{p.Name }\"\n"+
                                      "let year = DateTime.Now.Year - p.Age\n"+
                                      "select new\n"+
                                      "{\n"+
                                      "Name = name,\n"+
                                      "Year = year\n"+
                                      "};\n"),

                ("481. SelectMany","SelectMany(Func<TSource, IEnumerable<TResult>> selector)\n"+
                                   "SelectMany(Func<TSource, IEnumerable<TCollection>> collectionSelector, Func<TSource, TCollection,TResult>resultSelector)\n"+
                                   ""),
                ("482. Where","Where<TSourse>(Func<TSource,bool>predicate)\n"+
                              "var selectedPeople = from p in people\n"+
                              "where p.Age>25\n"+
                              "select p\n"+
                              ""),
                ("483.фильтрация по типу\n","var students=peiople.OfType<Student>()\n"),

                ("484. Методы агрегации","Aggregate((x,y)=>x+y сложит все значения\n"+
                                         "Count(), Sum(), Min(), Max(), Average()\n"),
                ("485. Функции генераторы","Enumerable.Range(), Enumerable.Repeat()\n"+
                                           "()=>T[]"),
                ("486. Статические функции","Возвращают либо число либо логическое значение\n"+
                                            "Any(), Count(), Single()\n"+
                                            "T[]=>число, T[]=>bool\n"),
                ("487.Функции проекторы","Принимают коллекцию T возвращают коллекцию U\n"+
                                         "Select(), SelectMany(), Cast<T>()\n"+
                                         "T[]=>U[]"),
                ("488. Функции фильтры","T[]=>T[]\n"+
                                        "T[]=>T\n"+
                                        "Where(), First(), Last()\n "),

                ("489. Советы по LINQ","1. Избегать проецирования ToList ToArray\n"+
                                       "2. Все возможные фильтры в одно Where\n"+
                                       "3. Использовать TrueOfAll() в IList<T> вместо All()\n"+
                                       "4. Использовать OrderBy() вместо Sort()\n+" +
                                       "5. Не использовать Contains как лямбду. Если необходимо то HashSet.Contains\n"+
                                       "6. Лучше Count>0 чем Any()\n"+
                                       "7. Нежелательно использовать ElementAt на индексируемые коллекции. Если нужно то можно преобразовать\n"+
                                       "8. Неиспользовать ElementAt на dictionary. При необходимости использовать List<KeyValuePair<T,U>>\n"+
                                       "9. Предпочитайте обработку исключений методам ElementAtOrDefault(), FirstOrDefault() или SingleOrDefault().\n"+
                                       "10. Не имеет смысла использовать First(), Last() вместо индекса 0 и Count-1\n"+
                                       "11. Использовать IEnumerable<T> как можно чаще\n"+
                                       "12. Sum и Average медленнее чем простой цикл\n"+
                                       "13. Создайте свой собственный ForEach(Action<T>), который может работать с экземпляром IEnumerable<T>\n"+
                                       "14. Лучше Select<T> вместо Cast<T>\n"+
                                       "15. Если поддерживается Count==0 вместо любого ()\n "+
                                       "16. Aggregate работает медленнее for\n"+
                                       "17. FirstOfDefault лучше не использовать в циклах. Решение это HashSet Dictionary\n"),

                ("490.Объект Lookup"," это последовательность групп, в которую можно получать доступ на прямую к ключу\n"+
                                      "это словарь последовательностей, котрый способен принимать множество элементов для одного ключа\n"),

                ("491. IEnumerable<T>","IEnumerable<T> содержит в себе GetEnumerator. Возвращает IEnumerator<T> \n"+
                                       "1. ленивая загрузка. Данные загружаются по мере необходимости\n"+
                                       "2. Работает в памяти(In-Memory). Все операции на стороне клиента\n "+
                                       "3. LINQ to object(запросы к коллекциям)\n"+
                                       "4. Не может напрямую транслироваться в SQL\n"),

                ("492.IQuerayble<T>","IQuerayble<T>\n"+
                                     "Содержит методы:\n"+
                                     "AsQueryably() преобразует IEnumerable в IQueryably\n"+
                                     "Provider дает доступ к провайдеру запросов\n"+
                                     "Expression возвращает дерево выражений запросов\n"+
                                    "1. Ленивая загрузка, Запрос строится, но выполняется только при перечеслении\n"+
                                    "2. Может транслироваться в SQL\n"+
                                    "3. LINQ to Entities, LINQ to SQL\n"+
                                    "4. Фильтрация, сортировка и другие операции выполняются на стороне сервера\n"),
                ("493.ICollection<T>","ICollection<T>\n"+
                                      "Базовый интерфейс для изменяемых коллекций\n"+
                                      "Поддерживает проверку, добавление, удаление элементов\n"+
                                      "List<T>, HashSet<T>, Queue<T>\n"),

                ("494. IList<T>","IList<T>\n"+
                                 "Добавляет индексированный доступ list[0]\n"+
                                 "Поддерживает вставку и удаление по индексу\n"+
                                 "List<T>, Array\n"),

                ("495. IReadOnlyCollection<T> IReadOnlyList<T> ","Представляют только доступ к чтению\n"+
                                                                 "Не поддерживает изменение коллекции\n "+
                                                                 "Полезны для безопасного возврата данных из метода\n"),

                ("496. Итератор","Итератор это объект позволяющий перемещаться по элементам коллекции\n"),

                ("497. GetEnumerator","Это метод, который возвращает итератор(объект, реализующий IEnumerator или IEnumerator<T> ),\n"+
                                      "позволяющий последовательно перебирать элементы коллекции\n"),
                ("498. Разница между операторами запроса и методами расширения","Запросы похожи на SQl запросы и более понятны для сложного синтаксиса\n"+
                                                                                "расширения имеют больше методов и можно комбинировть с обычным кодом\n"),

                ("499. Семейства запросов","1. Фильтрование Where(), OfType()\n"+
                                           "2. Проекция Select(), SelectMany()\n"+
                                           "3. Селекционирование Skip(),SkipWhile(), Take(), TakeWhile()\n "+
                                           "4. Соединение Join GroupJoin\n"+
                                           "5. Конкатенация Concat\n"+
                                           "6. Упорядочивание OrderBy(), Reverse()\n"+
                                           "7. Группировка GroupBy, ToLookUp()\n"+
                                           "8. Набор Disticnt, Intersect,Except\n"+
                                           "9. Преобразование AsEnumerable, AsQuerably,Cast, ToArray()\n"+
                                           "10. Равенство SequanceEqual\n"+
                                           "11. Элемент ElementAt, First, Last, FirstOfDefault()\n"+
                                           "12. Генерация DefaultIfEmpty, Empty, Range, Repeat\n"+
                                           "13. Квантификаторы все содержат\n"+
                                           "14. Aggragate, Average, Max, Min\n"),

                ("500. Выражение запросов LINQ","from [type] id in source\n"+
                                                "join [type] id in source on expr equals expr [into id]\n"+
                                                "from [type] id in source let id =expr |where condition\n" +
                                                "orderby ordering\n"+
                                                "select expr group expr by key\n" +
                                                "into id query\n"),
                ("501. Пространство имен","System.Linq\n"+
                                          "System.Linq.Expressions позволяет использовать деревья выражений\n"+
                                          "System.Data.Linq для баз\n"+
                                          ""),

                ("502. Сборщик мусора определение","Это процесс автоматического управлению памятью в куче,\n"+
                                                   "заключается в поиске неиспользуемых участков памяти\n"+
                                                   "которыt ранее использовались программой\n"),

                ("503. что такое Span<T>","Это структура, которая представляет собой типобезопасное и безопасное \n"+
                                          "с точки зрения памяти представление непрерывной области памяти,\n "+
                                          "независимо откуда эта память взята(управляемый массив, стэк или неуправляемая память)\n"+
                                          "нельзя хранить в куче\n"+
                                          "нельзя использовать в async методах так как ref struct\n"),

                ("504. что такое Memory<T>","Это структура C#, предстовляющие безопасное и гибкое хранение непрерывной области памяти\n"+
                                            "аналогично Span, но без ограничений ref struct\n"+
                                            "Это значит что Memory<T> можно использовать в асинхронных методах, хранить в куче\n"+
                                            "и передавать между методами\n"+
                                            "Управляемые массивы\n"+
                                            "Память выделенную с помощью MemoryPool<T>\n"+
                                            "неуправляемую память через Marshal или unsafe\n"),

                ("505.Запахи кода","Раздувание(Bloaters) - 5 запахов\n"+
                                   "Нарушители ООП(Object-Orientation-Abusers) - 4 типа \n"+
                                   "Припятствия для изменений(Change Preventers) - 3 типа\n"+
                                   "Диспенсеры(Dispensables) - 5 типов\n"+
                                   "Связаность(Couplers) - 5 типов\n"),

                ("506. Раздувание методов","Если метод становится большим и появляется необходимость комментировать нужно его разделить\n"+
                                   "1. Извлечение метода\n"+
                                   "2. Замена временной переменной вызова методом\n"+
                                   "3. Замена параметров объектом и передача всего объекта\n"+
                                   "4. Замена метода классом с  методами \n"+
                                   "5. Разбиение условного оператора на методы\n"),

                ("507. Раздувание класса","Если класс содержит множество полей, методов\n"+
                                          "Извлечение класса\n"+
                                          "Извлечение подкласса, если есть альтернативное использование класса\n"+
                                          "Извлечение интерфейса\n"),

                ("508. Одержимость элементарными типами","Использование констант и элементарных типов\n"+
                                                         "Замена простого поля объектом\n"+
                                                         "Замена массива объектом\n"),

                ("509. Длинный список параметров","Если параметров больше 3 -4\n"+
                                                  "Замена параметра вызовом метода\n"+
                                                  "Передача объекта целиком или частично\n"),

                ("510. Группы данных запах","Если одно значение удалить, а другие потеряют свой смысл, то группу нужно объединить\n"+
                                            "Извлечение класса\n"+
                                            "замена параметов объектом\n"+
                                            "передача всего объекта\n"),

                ("511. Нарушители объектно - ориентированного дизайна","1. Сложный switch или последовательность if\n"+
                                                                       "2. Временнные поля - это поля, которые нужны только при определенных обстоятельствах\n"+
                                                                       "     заполняются значениями только, когда нужны. остальное время пустые\n"+
                                                                       "3. Если подкласс использует лишь малую часть унаследованных методов и свойств суперкласса,\n"+
                                                                        "   это является признаком неправильной иерархии\n"+
                                                                        "    При этом ненужные методы могут просто не использоваться или быть переопределенными и выкидывать ошибку\n"+
                                                                        "4. Два класса выполняют одинаковые функции, но имеют разные названия методов\n"),

                ("512.Утяжелители изменений ","При внесений изменений в одну часть программы, приходится делать много изменений в другой\n"+
                                              "1. При внесении в класс приходится изменять большое число различных методов\n"+
                                                   "Извлечение класса, извлечение суперкласса, подкласса\n"+
                                               "2. При выполнений любых модификаций приходится вносить много мелких изменений в большое число классов\n"+
                                               "    Перемещение метода или поля в класс, где метод или поле используется чаще\n"+
                                               "    Встраивание класса, чтоб избавится от пустых классов\n"+
                                               "3. Параллельные иерархии наследования. При создании одного подкласса приходится создавать подкласс другого класса\n"+
                                               "    Перемещение методов и полей в класс, который использует их чаще\n"+
                                               ""),
                ("513. Замусориватели ","Что то бесполезное и лишнее\n"+
                                        "1. Метод содержит много комментариев\n"+
                                        "    Извлечение переменной, извлечение метода, переименнование метода, введение утверждения\n"+
                                        "2. Дублирование кода\n"+
                                         "    Извлечение метода с последующим подъемом полей\n"+
                                         "    Если общий конструктор то подъем конструктора\n"+
                                         "   Если участки кода похожи, но не совпадают полностью то создание шаблонного метода\n"+
                                         "   Если оба метода делают одно и тоже но с помощью разных алгоритмов, то нужна замена алгоритма\n"+
                                         "2.1 Дублирующийся код находится в двух разных классах\n"+
                                         "   Извлечение суперкласса, если не допустимо то извлечение класса\n"+
                                         "2.2 Присутствует череда условных операторов\n"+
                                         "    объединение условных операторов, а также применять извлечение метода, чтоб вынести это условие в отдельный метод\n"+
                                         "2.3 Один и тот же код выполняется во всех ветках условного оператора\n"+
                                         "    Вынести код за пределы условного оператора с помощью объединения дублирующихся фрагментов в условных операторах\n "+
                                         "3. Ленивый класс если класс делает не достаточно много, то он должен быть уничтожен\n"+
                                          "  бесполезные компонеты должны быть подвергнуты встраиванию класса\n"+
                                          " При наличии подклассов с недостаточными функциями свертывание иерахии\n"+
                                          "4. Классы данных это классы, которые содержат только поля и простейшие методы для доступа к ним геттеры и сеттеры\n"+
                                          "    Приминение инкапсуляции к полям, инкапсуляция для коллекции\n"+
                                          "    Создание функциональности с помощью перемещения метода и извлечение метода\n"+
                                           "После добавления методов возможно стоит удалить сеттер и сокрыть метод\n "+
                                           "5. Мертвый код. Встраивание класса, схлопавние иерархии, удаление параметров\n"+
                                           "6. Теоритическая общность. Код, который предполагалось использовать, но так и не был использован \n"+
                                           "сворачивание иерархии, встраивание класса, встраивание метода, удалению параметров\n "+
                                           ""),
                ("514.Опутыватели связи","1. Завистливые функции. Метод чаще обращается к данным чужого объекта чем своим\n"+
                                          "  Если метод нужно перенести в другой метод то использовать перемещение метода\n +" +
                                          "   Если только часть метода обращается к данным другого объекта, примените извлечение метода к этой части\n "+
                                          "   Если обращения в разные объекты то перемещение также в разные\n"+
                                          "2. Неуместная близость. Один класс использует служебные поля и методы другого класса\n "+
                                          "     Самый простой способ перемещение метода и поля, если оригинальный класс их не использует\n"+
                                          "     Извлечение зависимых частей в отдельный класс или сокрытие делегирования\n"+
                                          "     Замена двунаправленной связи однонаправленной\n"+
                                          "     Замена делегирования наследованием\n"+
                                          "3. Цепочка вызовов. Клиент запрашивает у одного объекта другой объект\n"+
                                          "      Для удаления цепочки используют сокрытие делегирования\n"+
                                          "        Возможно имеет смысл извлечь нужный метод и переместить в самое начало цепи\n"+
                                          "4. Посредник. Класс выполняет единственное действие это делегация другому классу\n"+
                                          "    Может быть результатом фанатичной борьбы с цепочкой вызовов\n"+
                                          "      Можно просто удалить класс посредник\n"),

                ("515. Неполнота библиотечного класса","Единственное решение изменение библиотеки\n"+
                                                       "Введение внешнего метода\n"+
                                                       "Введение локального расширения\n"),

                ("516. SOLID","S\n"+
                          "Принцип единственной ответственности(single resposability) - принцип ООП, обозначающий что каждый объект должен иметь одну ответственность\n"+
                          "и эта ответственность должна быть полностью инкапсулирована в класс.\n"+
                          "Все его поведение должно быть направлены исключительно на обеспечение этой ответственности\n\n"+
                          "O\n"+
                          "Принцип открытости-закрытости(open-closed principale) - принцип ООП, устанавливающий следующее положение:\n"+
                          "програмные сущности должны быть открыты для расширения, но закрыты для изменения\n\n"+
                          "L\n"+
                          "Принцип подстановки Лисков(Liskov substition principle) - в объекто-ориентируемом программировании является\n"+
                          "специфичным определением подтипа, предложенным Барбарой Лисков в 1987 году на конференции в основном докладе под\n"+
                          "названием Абстракция данных и иерархия. Роберт Мартин определил этот тип: \n"+
                          "Функция, которая использует базовый тип, должна иметь возможность использовать подтипы базового типа не зная об этом\n\n"+
                          "I\n"+
                          " Принцип разделенения интерфейса(interface segregation principle)\n "+
                          "Клиенты не должны зависеть от интерфейсов, которые они не используют"+
                          "D.\n"+" Принцип инверсии зависимостей(dependency inversion principle) \n"+
                          "- Модули высокого уровня не должны зависеть от модулей низкого уровня.\n"+
                          " Оба должны зависеть от абстракций.\n"+
                          "Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций."),


                ("517. Чтот такое SOLID","SOLID в программировании, это мнемонический акроним, введенный Майклом Фэзерсом\n"+
                                         "для первых пяти принципов, названных Робертом Мартином в 2000-х,\n"+
                                         "которые означали 5 основных принципов объекто ориентированного программирования и проектирования\n"),

                ("518. Для чего нужен SOLID","При создании программных систем использование принципов SOLID\n"+
                                             "способствует созданию такой системы, которую будет легко поддерживать\n"+
                                             "и расширять в течение долгого времени\n"),

                ("519. что такое  YANGI","YANGI это процесс и принцип проектирования ПО, при котором\n"+
                                         "в качестве основной цели или ценности декларируется отказ \n"+
                                         "от избыточной функциональности, - то есть отказ добавления функциональности\n"+
                                         "в которой нет непосредственной надобности\n"),

                ("520. Недостатки YANGI","1. Трататися время на добавление, тестирование и улучшение необходимой функциональности\n"+
                                          "2. Новые функции должны быть отлажены, задокументированы и сопровождаться\n"+
                                          "3. Новая функциональность ограничивает то, что может быть сделано в будущем,\n"+
                                          "- ненужные новые функции могут впоследствии помешать добавить новые нужные\n"+
                                          "4. Пока новые функции действительно не нужны, трудно полностью предугадать\n"+
                                          "что они должны делать и протестировать их. Если функции тщательно не протестированы\n"+
                                          "они могут неправильно работать, когда впоследствии понадобятся\n"+
                                          "Это приводит к тому, что программное обеспечение становится более сложным\n"+
                                          "5. Если функциональность не документирована, она может так и остаться неизвестной пользователю\n"+
                                          "что может создать различные риски для безопасности пользовательской системы\n"+
                                          "6. Добавление новой функциональности может привести к добавлению еще новой функциональности\n"+
                                          "и это создаст снежный ком\n"),

                ("521. Принцип KISS","Принцип KISS утверждает, что большинство систем работают лучшего всего\n"+
                                     "если они остаются простыми, а не усложняются\n"+
                                     "Практически все принципы проектирорвания направлены на достижения понятности кода\n"+
                                     "Нарушая какой либо принцип проектирования, вы уменьшаете понятность кода.\n"+
                                     "Непонятный код автоматически вызывает у человека ощущение того, что код сложный,\n"+
                                     "так как его сложно понимать и модифицировать. При нарушении любого из этих принципов\n"+
                                     "также и нарушается и принцип KISS. Поэтому можно считать что принцип KISS включает\n"+
                                     "почти все остальные принципы проектирования. Паттерны проектирования описывают\n"+
                                     "наиболее удачные, простые и понятные решения некоторых проблем.\n"+
                                     "если вы используете паттерн проектирования там, где нет проблемы\n"+
                                     "которую решает данный паттерн - то вы нарушаете KISS, внося ненужные усложнения в код\n"+
                                     "Если вы не используете паттерн проектирования там, где  есть проблема, соответствующая паттерну\n"+
                                     "- то вы опять нарушаете KISS делая код сложнее, чем он мог быть\n "),

                ("522. Принцип DRY","Don,t repeat yourself - это принцип разработки, нацеленный на снижение повторений информации\n"+
                                    "различного рода, особенно в системах со множеством слоев абстрагирования.\n"+
                                    "Принцип DRY формулируется как <<<Каждая  часть знаний должна иметь единственное, непротиворечивое и\n"+
                                    "авторитетное представление в рамках системы.>>> Когда принцип DRY применяется успешно\n"+
                                    "изменение единственного элеметна не требует внесения изменений в другие, логически не связанные\n"+
                                    "То есть элементы логически связанные, изменяются предсказуемо и единообразно\n"+
                                    "Дублирование кода - это пустая трата времени и ресурсов\n"+
                                    "Вам придется поддерживать одну и ту же логику и тестировать в двух местах сразу\n "+
                                    "при чем если вы измените код в одном месте, его будет нужно изменить в другом месте\n"+
                                    "В большинстве случаев дублирование кода происходит из - за не знания системы\n"+
                                    "Прежде чем писать код убедитесь что где реализована такая функция или бизнес логика\n"),

                ("523.Основные приницы ООП","1. Инкапсуляция\n"+
                                            "2. Наследование\n"+
                                            "3. Полиморфизм\n"),


                ("524. Инкапсуляция","Это принцип ООП,который заключается в:\n" +
                                      "объединении данных(полей) и методов (функций), работающих с этими данными\n"+
                                      "в единый компонент(класс) и ограничении прямого доступа к внутреннему состоянию объекта извне\n"+
                                      "Ключевые аспекты:\n"+
                                      "1. Сокрытие реализации\n"+
                                      "    Внутренние детали работы объекта скрыты от внешнего кода.\n"+
                                      "Пользователь класса взаимодействует с ним только через публичный интерфейс(методы и свойства),\n"+
                                      "не зная как устроена внутренняя логика\n"+
                                      "2. Использование контроля доступа(public, private)\n"+
                                      "3. Управление состоянием объекта\n"+
                                      "Инкапсуляция позволяет гарантировать, что состояние объекта всегда будет корректным,\n"+
                                      "благодаря проверкам в методах(сеттеры свойств)\n"),

                ("525. Наследование","Это механизм ООП, при котором один класс(производный или дочерний) может\n"+
                                     "наследовать поля, свойства и методы другого класса(базового, родительского)\n"+
                                     "Это позволяет повторно использовать код и создавать иерархии классов\n"+
                                     "Плюсы наследования: " +
                                     "1. Повторное использование кода\n"+
                                     "2. Упрощение архитектуры\n"+
                                     "3. Поддержка полиморфизма(переопределение методов через virtual, override)\n"+
                                     "Минусы:\n"+
                                     "1. Жесткая связь между классами(изменение базового класса влияет на наследников)\n"+
                                     "2. Невозможность множественного наследования\n"+
                                     "3. Риск создания сложных иерархий\n"),

                ("526. Полиморфизм","Это принцип ООП, который позволяет одному и тому же коду работать c разными типами данных,\n"+
                                    "обеспечивая гибкость и расширяемость программы\n"+
                                    "Полиморфизм реализуется через:\n"+
                                    "1. Переопределение методов(virtual и override)\n"+
                                    "2. Абстрактные методы и классы(abstract)\n"+
                                    "3. Интерфейсы\n"+
                                    "4. Перегрузку методов(method overloading)\n"),

                ("527. Модификаторы доступа C#",""+
                                                "1. private только внутри класса\n"+
                                                "2. private protected только наследники в текущей сборке\n"+
                                                "3. protected класс и наследники\n"+
                                                "4. internal в пределах сборки\n"+
                                                "5. protected internal Класс+наследники+сборка\n"+
                                                ""+
                                                "6. public - везде"),

                ("528. Record ","Они предназначены для упрощения работы с неизменяемыми данными и \n"+
                                 "и представляют удобные возможности для сравнения,копирования и работы с объектами\n"+
                                 "== в record сравнивает по значению\n"+
                                 "автоматические методы ToString(), Equals(), GetHashCode() на основе свойств\n"+
                                 "with для создания копии, но с изменениями\n"+
                                 "можно объявлять как классы с конструктором и деконстуктором\n"+
                                 ""),

                ("529. Sealed","запечатывает класс и от него нельзя наследоваться\n"),

                ("530. Методы object","1. Equals()\n"+
                                       "Возвращает true если объекты ссылаются на один и тот же объект в памяти\n"+
                                       "Чаще всего метод переопеределяется. Если Equals переопределен, то и GetHashCode должен быть переопределен\n"+
                                       "так как данные методы используются внутренними типами Hashtable для извлечения подъектов из контейнера\n "+
                                       "2. Finalize()\n"+
                                       "Вызывается когда переопределен для освобождения любых выделенных ресурсов перед уничтожением объекта\n"+
                                       "3. GetHashCode\n возвращает int который идентифицирует конкретный объект\n"+
                                       "4. ToString()\n"+
                                       "Этот метод возвращает строковое представление объекта в формате <пространство имен>.<имя типа>\n" +
                                       "Чаще всего переопределяется\n" +
                                       "5. GetType()\n"+
                                       "Этот метод возвращает объект Type, полностью описывающий объект,\n"+
                                       "на который в текущий момент производится ссылка\n"+
                                       "идентификатор типа объекта\n"+
                                       "6. MemberwiseClone\n"+
                                       "метод возвращает копию текущего объекта\n"+
                                       "7. статические члены ReferenceEquals и Equals\n"+
                                       "безопасно обрабатывают null при переопределенном методе Equals статический сравнивает ссылки\n"),

                ("531. Анти паттерны","1. Копи паста\n"+
                                       "2. Спаггети код\n"+
                                       "Это слабо структуированная и плохо спроектированная система,\n"+
                                       "запутанная и сложная для понимания\n"+
                                       "3. Золотой молоток\n"+
                                       "Уверенность в полной универсальности решения. Использование одного решения для всех задач возможных и не возможных задач\n "+
                                       "4. Магические числа\n"+
                                       "константа, использованная в коде для чего либо\n "+
                                       "5. Жесткое кодирование\n"+
                                       "Внедрение различных данных об окружении в реализацию\n"+
                                       "Различные пути к файлам, имена процессов, устройств\n"+
                                       "Главная опасность такой код непереносим\n "+
                                       "6. Мягкое кодирование\n"+
                                       "Параноидальная боязнь захаркодить. Это приводит к тому, что настравивается абсолютно все.\n"+
                                       "и это делает конфигурацию сложной и непрозрачной\n"+
                                       "7. Ненужная сложность\n"+
                                       "Заумность решения. Ненужная сложность может быть внесена в решение любой задачи\n"+
                                       "Это может быть ненужные проверки, части кода с мягким кодированием, отсутствии оптимизации\n"+
                                       "8. Лодочный якорь\n"+
                                       "Сохранение неиспользуемых частей системы, которые остались после рефакторинга или оптимизации\n"+
                                       "9.Изобретение велосипеда\n"+
                                       "программист разрабатывает собственное решение для задачи, у которой уже есть решение\n"+
                                       "10. Изобретение одноколесного велосипеда\n"+
                                       "Изобретение плохого велосипеда\n"+
                                       "11. Поток лавы\n"+
                                       "часть кода, которая давно не менялась и не понятно как она вообще работает\n"+
                                       "12. Программирование перебором\n"+
                                       "Подбор параметров в функции. +-1 и подобные штуки\n"+
                                       "13. Слепая вера\n"+
                                       "Недостаточная проверка корректности входных данных, исправления ошибки или результатов работы кода\n"+
                                       "14. Безумное комментрирование\n"+
                                       "Большое и не нужное количество лишних и бессмысленных комментариев\n"+
                                       "15. Божественный объект\n"+
                                       "Объект берет на себя много функций или хранит в себе много данных\n"),

                ("532. Виды паттернов","1. Порождающие это паттерны, которые абстрагируют процесс инстанцирования или\n "+
                                       "иными словами процесс пораждения классов и объектов\n"+
                                       "2. Структурные паттерны - группа паттернов рассматривает, как классы и объекты\n"+
                                       "образуют более крупные структуры. Более сложные по характеру классы и объекты\n"+
                                       "3. Поведенческие паттерны - определяют алгоритмы и взаимодействие между классами и объектами\n"+
                                       "то есть их поведение\n"),

                ("533.Хранитель(memento) или снимок. Паттерн","Поведенческий паттерн\n"+
                                            "Он позволяет определять, сохранять, а также востанавливать предыдущие состояния без нарушения инкапслуляции\n"
                                            ),

                ("534. Цепочка обязанностей.(chain of responsibility) Паттерн  ","Поведенческий шаблон проектирования, который позволяет избежать жесткой привязки отправителя запроса к получателю\n"+
                                                         "Каждый объект в этой цепочке при получении запроса выбирает\n"+
                                                         "либо закончить обработку запроса, либо передать запрос на обработку следующему по цепочке объекту\n"),

                ("535. Наблюдатель.(observer)(Издатель подписчик) Паттерн","Представляет поведенческий шаблон проектирования\n"+
                                             "который использует отношение один ко многим\n"+
                                             "В этом отношении есть один наблюдаемый объект и множество наблюдателей\n"+
                                             "И при изменение наблюдаемого объекта происходит оповещение всех наблюдателей\n"),

                ("536. Команда.(command) Паттерн","Позволяет инкапсулировать запрос на выполнение определенного действия в виде отдельного объекта\n"+
                                         "Этот объект запроса на действие и называется командой\n "+
                                         "При этом объекты, инициирующие запросы на выполнение действия,\n"+
                                         "отделяются от объектов, которые выполняют это действие\n"),

                ("537. Состояние(state) паттерн","шаблон проектировани, который позволяет объекту изменять свое поведение\n "+
                                          "в зависисмости от внутреннего состояния\n"),

                ("538. Интепретатор.(interpreter) Паттерн","определяет представление для данного языка и интепретатор предложений\n"+
                                              "этого языка. Как правило данный шаблон применяется для часто повторяющихся операций\n"+
                                              ""),

                ("539. Стратегия(strategy) Паттерн","представляет шаблон проектирования, который определяет набор алгоритмов,\n"+
                                          "инкапсулирует каждый из них и обеспечивает их взаимозаменяемость\n"+
                                          "В зависимости от ситуации один используемый алгоритм можем заменить другим\n"),

                ("540. Итератор.(iterator) Паттерн","представляет абстрактный интерфейс для последовательного доступа ко всем\n"+
                                          "элементам составного объекта без раскрытия его внутренней структуры\n"),

                ("541. Шаблонный метод.(template method) Паттерн","определяет общий алгоритм поведения подклассов,\n"+
                                                 "позволяя им переопределить отдельные шаги этого\n"+
                                                 "алгоритма без изменения его структуры\n"),

                ("542.Посредник(mediator) ","Представляет такой шаблон проектирования,\n"+
                                            "который обеспечивает взаимодействие множества объектов\n"+
                                            "без необходимости ссылаться друг на друга\n"+
                                            "Тем самым достигается слабосвязанность взаимодействующих объектов\n "),

                ("543.Посетитель(visitor)","позволяет опеределить операцию для объектов других классов\n"+
                                           "без изменения этих классов. При использовании паттерна определяются две иерархии классов:\n"+
                                           "одна для элементов, для которых надо определить новую операцию,и\n"+
                                           "вторая иерархия для посетителей, описывающих данную операцию\n"),

                ("544. Абстрактная фабрика(abstract factory)","предоставляет интерфейс для создания семейств взаимосвязанных объектов\n"+
                                                              "с определенными интерфейсами без указания конкретных типов данных объектов\n"),

                ("545. Строитель(builder) паттерн","шаблон проектирования, который инкапсулирует создание объекта и позволяет разделить его на различные этапы\n"+
                ""),

                ("546.Фабричный метод","это паттерн, который определяет интерфейс для создания объектов\n"+
                                       "некоторого класса, но непосредственное решение объект какого класса решается в подклассах\n"+
                                       "то есть паттерн предполагает что базовый класс делегирует создание объекта наследникам\n"),

                ("547. Прототип.(prototype) Паттерн","позволяет создавать объекты на основе уже раннее созданных объектов-прототипов\n"+
                                                     "по сути данный паттерн предлагает технику клонирования объектов\n"),

                ("548. Одиночка(singeton) ","порождающий паттерн, который гарантирует,что для определенного класса будет создан только один объект,\n "+
                                            "а также предоставит к этому объекту точку доступа\n"),

                ("549. Адаптер(adapter)","предназначен для преобразования интерфейса одного класса в интерфейс другого\n"+
                                         "Благодаря реализации данного паттерна мы можем использовать вместе все классы с несовместимыми интерфейсами\n"),

                ("550. Прокси(proxy) заместитель","предоставляет объект-заместитель,который управляет доступом к другому объекту\n"+
                                             "объект суррогат, который может выступать в роли другого объекта и замещать его\n"),

                ("551. Мост.(Bridge)","структурный шаблон проектирования, который позволяет отделить абстракцию от реализации таким образом,\n "+
                                      "чтобы и абстракцию, и реализацию можно было изменить независимо друг от друга\n"),

                ("552. Компоновщик(composite). Паттерн","объединяет группу объектов в древовидную структуру по принципу часть-целое\n"+
                                                        "и позволяет клиенту одинаково работать как с отдельными объектами, так и с группой объектов\n"+
                                                        "образно реализацию паттерна можно представить в виде меню, которое имеет различные пункты\n"),

                ("553. Декоратор(decorator) Паттерн","представляет структурный шаблон проектирования, который позволяет динамически подключать к объекту\n"+
                                                     "дополнительную функциональность.Для определения функциональности обычно используют наследование"),

                ("554. Фасад(facade)","представляет собой шаблон проектирования, который позволяет скрыть сложность системы\n"+
                                      "с помощью предоставления упрощенного интерфейса для взаимодействия с ним\n"),

                ("555. Приспособленец(flyweight)","структурный шаблон проектирования, который позволяет использовать разделяемые объекты\n"+
                                                  "сразу в нескольких контекстах. Данный паттерн используется преимущественно для оптимизации работы с памятью\n"),

                ("556. GRASP","это шаблоны, используемые в ООП проектировании для решения общих задач по назначению\n"+
                              "ответственостей классам и объектам\n"),

                ("557. виды GRASP","1. Информационный эксперт(information Expert)\n"+
                                    "Шаблон определяет базовый принцип ответственностей:\n"+
                                    "Ответсвенность должна быть назначена тому, кто владеет максимум необходимой информации для исполнения\n"+
                                    "информационному эксперту\n"+
                                    "2. Создатель(Creator)\n"+
                                    "Класс должен создавать экземпляры тех классов, которые может\n "+
                                    "3. Контроллер(Controller)\n"+
                                    "Отвечает за операции, запросы на которые приходят от пользователя\n"+
                                    "и может выполнять сценарии одного или нескольких вариантов использования\n"+
                                    "4. Слабое зацепление\n"+
                                    "степень зацепления - мера неотрывности от других элементов\n"+
                                    "слабое зацепление - распределение ответственностей и данных, обеспечивающие независимость классов\n"+
                                    "5. Высокая связаность(High Cohesion) \n"+
                                    "Высокая связаность класса - это оценочная модель, направленная на удержание объектов должным образом сфокусироваными\n"+
                                    "управляемыми и понятными. Высокая сзязаность обычно используется для низкого зацепления\n"+
                                    "разбиение программ на классы и подсистемы является примером деятельности, которая увеличивает связаность системы\n"+
                                    "6. Полиморфизм(Polymorphism) Устройство и поведение системы:\n"+
                                    "Определяется данными и задано полиморфными операциями её интерфейса\n"+
                                    "7. Чистое изготовление(Pure Fabrication) уменьшает зацепление, повышает связанность, упрощает повторное использование\n"+
                                    "8. Перенаправление(inderection)\n"+
                                    "Слабое зацепление между элементами системы( и возможность повторного использования) обеспечивается назначением \n"+
                                    "промежуточного объекта их посредником\n"+
                                    "9. Устойчивость к изменениям(Protected Variations)\n"+
                                    "Шаблон защищает элементы от изменения другими элементами(объектами или подсистемами ) с помощью вынесения\n"+
                                    "взаимодействия в фиксированный интерфейс, через который(и только через который) возможно взаимодействие между элементами\n"+
                                    "поведение может варьироваться лишь через создание другой реализации интерфейса\n"),

                ("558. Синхронная программная модель","это программная модель, когда потоку назначается одна задача\n"+
                                                      "и начинается выполнение. Когда завершено выполнение задачи тогда появляется возможность заняться другой задачей\n "),

                ("559. Однопоточность","если мы имеем несколько задач, которые надлежит выполнить, и текщая система предоставляет один поток\n "+
                                       "который может работать со всеми задачами, то он берет поочередно одну за другой\n"),
                ("560. Многопоточность","это способ выполнения нескольких потоков команд в рамках однопроцесса,\n"+
                                        "позволяющий эффективно использовать ресурсы процессора и выполнять задачи параллельно\n"),

                ("561. Асинхронная модель программирования","в отличии от синхронной програмнной модели\n"+
                                                            "здесь поток однажды начав выполнение задачи может приостановить выполнение, сохранив\n"+
                                                            "текущее состояние и между тем начать выполнение другой задачи\n"),
                ("562. Параллелизм","это свойство системы, при котором несколько вычислений выполняются одновременно в течение определенного периода времени\n"),

                ("563. SynchronizationContext","это абстракция, которая перенаправляет вызовы(обычно колбеки или продолжения)\n"+
                                               "в нужный контекст синхронизации(поток, очередь)\n"+
                                               "Переносит выполнение кода в правильный поток\n"),

                ("564. ConfigureAwait(false)","это оптимизация, которая говорит механизму продолжения задач\n"+
                                              "не возвращаться в исходный контекст синронизации\n"+
                                              "отменяет привязку продолжения к исходному потоку, позволяя продолжить\n"+
                                              "выполнение в любом доступном потоке из пула\n"+
                                              "улучшение производительности\n"+
                                              "предотвращение дедлоков\n"+
                                              "Оптимизация библиотечного кода\n"+
                                              "Использовать в библиотечном коде, где не важен контекст.\n"+
                                              "Не использовать в UI коде или где нужен исходный контекст\n"),
                ("565. async\\await","это паттерн для неблокирующего выполнения асинхронных операций\n"+
                                     "async помечает метод как асинхронный\n"+
                                     "await приостанавливает выполнение до завершение задачи, не блокируя поток\n"),

                ("566. Ошибки в асинхронном методе","если ошибка в состоянии Canceled то OperationCanceledExpeption\n"+
                                                    "если в Faulted вызывается конкретная ошибка\n"),

                ("567. CancellationTokenSource","Источник маркера отмены. Свойство источника Token\n"+
                                                "вызов метода Cancel"),

                ("568. методы Task","Task, Task<TResult>\n"+
                                    "await Task.Run(()=>{return x});\n"+
                                    "await Task.Run(async()=>\n"+
                                    "return Task.FromResult() возвращает уже выполненую задачу\n "+
                                    "Task.WhenAll для ожидания нескольких операций\n"+
                                    "Task.WhenAny для ожидания одной из нескольких операций\n"),
                ("569. для чего нужны TaskContinue.With","используется для создания продолжений(continuations) задач\n"+
                                                         "Это механизм, который позволяет выполнить код сразу после завершения\n"+
                                                         "предыдущей задачи.Независимо с ошибкой завершилось или нет\n"),

                ("570. что такое Task.Yield()","этот метод, который принудительно делает текущий метод асинхронным,\n+" +
                                               "заставляя его немедленно вернуть управление вызывающему коду, даже если он\n"+
                                               "выполниться синхронно\n"),

                ("571. что такое await Task.Run()","это операция, которая позволяет выполнить синронный код в фоновом потоке\n"+
                                                   "и ожидать его завершение асинхронно\n"),

                ("572. что такое Task.FromResult()","это метод, который создает уже завершенную задачу с указанным результатом\n"+
                                                    "Это полезно для симуляции асинхронных операций,которые на самом деле\n"+
                                                    "выполняются синхронно\n"),
                ("573. что такое Task.WhenAll()","это метод, который создает задачу, ожидающую завершения всех переданных задач.\n"+
                                                 "Это мощный инструмент для параллельного выполнения асинхронных операций\n "),

                ("574. что такое Task.WhenAny()","это метод, который создает задачу, ожидающую завершения любой из переданнных задач\n"+
                                                 "Он возвращается как только одна из задач завершается с ошибкой или без\n"),

                ("575.что такое Task.Delay()","это метод,который создает задачу, завершающиеся через определенный промежуток времени без блокировки потока\n"),

                ("576.что такое ThreadPool","это архитектурный паттерн программирования, представляющий собой коллекцию(пул)\n "+
                                            "заранее созданных и простаивающих потоков, готовых к выполнению задач\n"),

                ("577. виды потоков в ThreadPool","Рабочие потоки(worker threads) для вычислительных задач\n"+
                                                  "Потоки завершения ввода вывода(I/O completion threads) - обрабатывают завершение асинхронных операций ввода - вывода\n"),

                ("578.методы ThreadPool","1. QueueUserWorkItem самый простой способ поместить задачу в пул потоков\n"+
                                         "2. GetMaxThreads/SetMaxThreads получение/установка максимального количества потоков\n "+
                                         "3. GetMinThreads/SetMinThreads получение/установка минимального количества потоков\n"+
                                         "4. GetAvailableThreads определение числа свободных потоков\n"+
                                         "5. RegisterWaitForSingleObject регистрация объекта ожидания с заданным таймаутом\n"),

                ("579. инструменты синхронизации ThreadPool","1. Блокировки lock(object)\n"+
                                                             "2. Атомарные операции\n"+"" +
                                                             " ThreadPool.QueueUserWorkItem(_=>{\n"+
                                                             "Interlocked.Increment(ref _counter)\n"+
                                                             "})\n"+
                                                             "3. ReaderWriterLockSlim когда чтений больше,чем записей\n"),

                ("580. Паттерны для использования ThreadPool в микросервисах","Circuit Breaker(Предохранитель) для предотвращения каскадных отказов\n"+
                                                                              "BulkHead(Переборка) для изоляции ресурсов между подсистемами\n"),

                ("581. Альтернативы для управления потоками","1. Dataflow(TPL Dataflow) для обработки потока данных\n"+
                                                             "2. Channels для высокопроизводительных сценариев производитель- потребитель\n" +
                                                             "3. Reactive Extansions(Rx) для реактивных потоков данных и обработки событий"),

                ("582. что такое Parallel.Invoke()","это метод который позволяет запускать несколько операций параллельно\n"+
                                                    "и ожидать их завершения\n"),

                ("583. что такое TaskFactory.StartNew()","это фабричный метод, который создает и немедленно запускает объект Task\n"+
                                                         "для выполнения в фоновом потоке из пула потоков"),

                ("584. Task.AsyncState","это свойство которое позволяет сохранить объект состояние вместе с задачей\n"+
                                        "и затем получить его обратно\n"),

                ("585 что такое AggregateException","это специальный тип исключения в Net, который действует как контейнер\n"+
                                                    "для одного или нескольких исключений,\n"+
                                                    "произошедших в параллельных или асинхронных операциях\n"),

                ("586. что такое TaskFactory","это класс, представляет собой фабрику для создания и настройки задач\n"+
                                              "Он предоставляет методы для создания и запуска задач с различными параметрами и настройками\n"),

                ("587. что такое System.Threading.Channels.Channel<T>","это высокопроизводительный и безопасный для многопоточного использования\n"+
                                                                       "способ организации асинхронного обмена данными между\n"+
                                                                       "производителями(producers) и потребителями(consumers)\n"+
                                                                       "Channel<T> сам канал\n"+
                                                                       "ChannelWriter<T> для записи данных\n"+
                                                                       "ChannelReader<T> для чтения данных\n"),

                ("588.что такое Open.ChannelExtensions","это популярный open sourse пакет, который представляет \n +" +
                                                        "набор методов для работы с каналами. это как LINQ для object\n"+
                                                        "но для асинхронных потоков данных в каналах\n"),

                ("589. что такое WriteAsync","это метод отправки данных в канал\n"+
                                             "асихронный метод класса ChannelWriter<T>,\n"+
                                             "который добавляет элемент в канал\n"),

                ("590. что таое ReadAsync ","это асинхронный метод класса ChannelReader<T>, который читает один элемент из канала\n"),

                ("591. TryWrite","это синхронная альтернатива асинхронному WriteAsync для работы с каналами в C#\n "+
                                 "TryWrite это  метод класса ChannelWriter<T>, который пытается немеделенно записать элемент в \n"+
                                 "канал без блокировки. Не бросает исключения и возвращает bool"),

                ("592. TryRead","это синхронная альтернатива ReadAsync\n "+
                                "метод который пытается прочитать элемент из канала потока без блокировки\n"),

                ("593. что такое Completion","это свойстов которое возвращает Task\n"+
                                             "заверщаюйся когда канал больше недоступен для чтения и записи\n"+
                                             "Завершается успешно когда канал полностью отработан\n"+
                                             "Завершается с ошибкой если произошла ошибка\n"+
                                             "Не завершается никогда если канал еще активен"),

                ("594. емкость канала ","Channel.CreateBounded - ёмкость\n"+
                                        "Channel.CreateUnbounded - неограниченное количество читателей и писателей\n"),

                ("595. пайплаины обработки(Processing pipelines)","Эта последовательности операций, где выход одной операции становится входом для следующей\n"+
                                                                   "   Каналы позволяют организовать эффективный поток данных между этапами обработки\n"+
                                                                   "    Пример: конвейер обработки изображений, где одна операция выполняет масштабирование\n"+
                                                                   "     другая фильтрацию\n"),
                ("596.  Очереди задач(Task queues)",
                                                                   "   использование каналов для создания очереди задач,\n"+
                                                                   "   которые должны быть выполнены асинхронно\n"+
                                                                   "   один или несколько потоков могут добавлять задачи(производители)\n"+
                                                                   "   а другие потоки могут их выполнять(потребители)\n"+
                                                                   "   Пример: очередь запросов к внешнему API с ограничением частоты,\n"+
                                                                   "    где задачи добавляются по мере необходимости, а обрабатываются с контролируемой скоростью\n"
                                                                   ),

                ("597. реализация event loop","Организация цикла обработки событий,\n"+
                                              "где события помещаются в канал и последовательно обрабатываются\n"+
                                              "Позволяет создавать неблокирующие обработчики событий\n"+
                                              "Пример: приложение, которое получает события из разных источников\n"+
                                              "(UI,сеть,файловая система) и должна их обрабатывать в определенном порядке\n"+
                                              "в одном потоке\n"),

                ("598. Полезность каналов в сценариях ","1. Предоставляют встроенную синхронизацию между потоками\n"+
                                                        "2. Поддерживают асинхронные операции(async/await)\n"+
                                                        "3. Обеспечивает контроль потока данных(особенно в bounded каналах)\n"+
                                                        "4. Предлагают высокопроизводительную альтернативу традиционным коллекциям с блокировками\n "),

                ("599. Чем отличается Select от Where?","Select это преобразование (проекция). Он преобразует каждый элемент коллекции в новую форму\n "+
                                                         "Where это фильтрация. Оставляет только те элементы которые удовлетворяют условию\n"),

                ("600. Какие методы отвечают за агрегацию в LINQ?","Это семейство методов. Их цель вычислить одно результирующее значение\n"+
                                                                   "на основе всей коллекции(или ее части)\n"+
                                                                   "Aggregate 1+2+3+4+5\n"+
                                                                   "SUM(),Average() среднее, Min,Max,Count, LongCount, First/FirstOfDefault,\n"),

                ("601. Что произойдет, если к IEnumerable-запросу не применить методы вроде ToList()?","1. Отложенное выполнение\n"+
                                                                                                       "2. Повторное выполнение\n"+
                                                                                                       "3. Чуствительность к изменению данных\n"),

                ("602. В чем разница между IEnumerable и IQueryable?","IEnumerable работает с данными в памяти (клиентская сторона)\n"+
                                                                      "IQueryable работает с поставщиком запросов(серверная сторона)\n"),

                ("603.Как можно предотвратить повторное выполнение LINQ-запроса?","Использовать методы материализации\n"+
                                                                                  "в EF метод AsNoTracking\n"),

                ("604.Что такое deferred execution?","Запрос не выполняется немедленно в момент его определения,\n"+
                                                     "а лишь сохраняется как план выполнения\n"+
                                                     "фактическое выполнение откладывается до момента, когда реально нужны данные\n"),

                ("605.Как yield return реализует отложенное выполнение?"," Генерирует класс итератор компилятором\n"+
                                                                         "и машину состояния которая запоминает текущую позицию выполнения\n"),

                ("606. Как deferred execution помогает с производительностью?","1. Избегание ненужных вычислений\n"+
                                                                               "2. экономия памяти при генерации больших последовательностей\n"+
                                                                               "3. Оптимизация в запросах к базе данных\n"+
                                                                               "4. Ленивая загрузка больших файлов (построчное чтение файлов)\n"+
                                                                               "5. Цепочка отложенных операций\n"+
                                                                               "6. Динамическое построение запросов\n"+
                                                                               "7. Генерация по требованию\n"),

                ("607. Что может пойти не так при использовании deferred execution?","1. Неожиданные многократные использования\n"+
                                                                                     "2. Доступ к disposed объектам\n"+
                                                                                     "3. Изменения данных во время выполнения\n"+
                                                                                     "4. Побочные эффекты\n"+
                                                                                     "5. Производительность при многократном использовании\n"+
                                                                                     "6. Позднее обнаружение ошибок\n"+
                                                                                     "7. Разное выполнение методов с анонимными типами при схожей логике\n"+
                                                                                     "8. Пробелемы с параллельным выполнением\n"+
                                                                                     "9. Случайное создание бесконечного цикла\n"+
                                                                                     "10. Сложность отладки ленивых вычислений\n"),

                ("608. Как можно заставить deferred-запрос выполниться немедленно?","1. Методы материализации\n"+
                                                                                    "ToList(), ToArray(), ToDictionary(), ToLookUp(),ToHashSet()\n"+
                                                                                    "2. Методы агрегации\n"+
                                                                                    "Count(), Sum(), Min()\n"+
                                                                                    "3. Методы получения элементов\n"+
                                                                                    "First(), FirstOrDefault(), Single(), SingleOrDefault(), Last()\n"+
                                                                                    "4. Методы проверки\n"+
                                                                                    "Any(), All(), Contains(),\n"+
                                                                                    "Явное пречисление\n"),

                ("609.Когда рефакторинг в LINQ может ухудшить читаемость кода? ","1. Чрезмерные цепочки\n"+
                                                                                 "2. Много логики в Select\n"+
                                                                                 "3. Сложные анонимные типы\n"+
                                                                                 "4. Использование LINQ где простой цикл более читаем\n"+
                                                                                 "5. Смещение бизнес логики с Linq\n"+
                                                                                 "6. Использование динамических типов\n"+
                                                                                 "7. Сложная группировка\n"),

                ("610.Какой LINQ-метод эквивалентен вложенному foreach?","SelectMany "),

                ("611. Как заменить проверку всех элементов на условие?","All() все элементы удовлетворяют условию\n"+
                                                                         "Any() хотя бы один удовлетворяет условию\n"),

                ("612. Почему важно избегать побочных эффектов в LINQ-выражениях?","нарушение принципов функционального программирования\n"+
                                                                                   "неопределенное поведение при отложенном выполнении\n"+
                                                                                   "Многократное выполнение побочных эффектов\n"+
                                                                                   "Сложность тестирования и отладки\n"+
                                                                                   "Проблемы с параллельным вычислениями\n"),

                ("613. Что делает yield return в C#?","это ключевые слова для создания итераторов и ленивого вычисления\n"+
                                                      "они позволяют генерировать последовательности элементов по одному,\n"+
                                                      "по мере необходимости\n"),

                ("614. Чем yield return отличается от обычного return?","1.return возвращает готовую коллекцию yield return возвращает по одному\n"+
                                                                        "2. retrun жадное выполнение Выделяется вся память, yield память только для текущего элемента\n"+
                                                                        "3. один return один возврат, yield много возвратов\n"+
                                                                        "4. return состояние между вызовами сбрасывается yield сохраняется\n"+
                                                                        "5. return не имеет ограничений на контекст, yield нельзя в catch блоке, анонимных методах\n"+
                                                                        "6. ошибка return сразу yield по достижению итерации"),

                ("615. В каких случаях имеет смысл использовать yield return?","1. Работа с большими данными\n"+
                                                                               "2. Генерация бесконечных последовательностей\n"+
                                                                               "3. Ленивая загрузка данных\n"+
                                                                               "4. Кастомные итераторы и фильтры\n"+
                                                                               "5. Для данных которые поступают медленно\n"+
                                                                               "6. для посторения цепочек обработки\n"+
                                                                               "7. Отладка и логирование процесса\n"+
                                                                               "8. Экономия памяти в Linq цепочках\n"+
                                                                               "9. Создание собственных Linq методов\n"+
                                                                               "10. обработка деревьев и иерархических стурктур\n"),

                ("616. Что возвращает метод с yield return?","возвращает не обычную коллекцию, а специальный итератор - объект,\n"+
                                                             "который реализует интерфейсы IEnumerable<T> или IEnumerator<T>\n"),


                ("617. Чем отличается стек от кучи по способу хранения данных?","1.Структура и организация"+
                                                                                "Стек (LIFO Last In First Out)\n"+
                                                                                "Куча произвольный доступ\n"+
                                                                                "2. скорость и производительность\n"+
                                                                                "Стек(быстро) и куча(медленно)\n"+
                                                                                "стек освобождение при выходе из метода\n"+
                                                                                "куча сборщик мусора\n"+
                                                                                "3. Размер и ограничения\n"+
                                                                                "Стек(ограниченный)\n"+
                                                                                "Куча(большой размер)\n"+
                                                                                "4. Время жизни переменных\n"+
                                                                                "Стек(автоматическое управление)\n"+
                                                                                "Куча(управление через GC)\n"+
                                                                                "5. Типы данных\n"+
                                                                                "Стек(значимые типы)\n"+
                                                                                "Куча(ссылочные типы)\n"),

                ("618.Что произойдёт при переполнении стека?","возникает исключение StackOverflowException,\n"+
                                                              "которое является критическим и обычно приводит к аварийному завершению программы\n"),

                ("619.Почему доступ к стеку быстрее, чем к куче?","структура LIFO и близкость располпожения данных, автоматическое управление компилятором\n "),

                ("620. Какие типы в C# по умолчанию размещаются в стеке, а какие — в куче?","В стеке по умолчанию размещаются экземпляры типы значений,\n"+
                                                                                            "обьявленные как локальные переменные или параметры методов\n"+
                                                                                            "В куче по умолчанию размещаются все экземпляры ссылочных типов,а\n"+
                                                                                            "также типы значений, которые являются полями внутри ссылочных типов или упакованы(boxing)\n"),

                ("621. Что такое boxing в C#?","Это процесс преобразования типа значения в ссылочный тип(object или интерфейс который реализует этот тип).\n"+
                                               "При упаковке значение копируется из стека в управляемую кучу,\n"+
                                               "и вокруг него создается обертка, которая позволяет обращаться к нему как обьекту\n"+
                                               "int number =42; object boxedNumber = number;"),

                ("622. Что такое unboxing?","это операция извлечения типа значения из объекта, в который он был ранее упакован\n"+
                                            "Это процесс преобразования ссылочного типа обратно в тип значения\n"+
                                            "при распаковке значение копируется из кучи обратно в стек\n"+
                                            "можно распоковывать только этот же тип или его nullable"),

                ("623. Почему частое использование boxing/unboxing нежелательно?","Частое использование boxing и unboxing это антипаттерн\n"+
                                                                                  "1. Значительные накладные расходы на производительность\n"+
                                                                                  "2. Повышенное давление на garbage collect\n"+
                                                                                  "3. Риск ошибок времени выполнения\n"+
                                                                                  "4. Потеря семантики типов значений\n"),

                ("624. Как избежать boxing при работе с коллекциями?","что бы избежать boxing нужно использовать обобщенные коллекции\n"+
                                                                      "и generic интерфейсы"),

                ("625.Как Equals ведёт себя при сравнении значимого типа и object?","1. object.Equals(object)Если один тип то сравнивается побитово\n"+
                                                                                    "если разный то false;если null то false\n"+
                                                                                    "2. ValueType.Equlas(object) если не соместимый тип то false\n"+
                                                                                    "если совместимый то провреяет все поля"),

                ("626. Что такое поколение в контексте GC?","идея поколения основана на двух эмперических наблюдениях,\n "+
                                                            "известных как гипотезы поколений:\n"+
                                                            "молодые объекты умирают быстро\n"+
                                                            "старые объекты ссылаются на молодые\n"),

                ("627.Когда запускается GC?","Не следует четкому набору правил и условий. Нет расписания\n"+
                                             "Триггеры для запуска:\n"+
                                             "1. Недостаточно памяти для выделения нового объекта(самая частая причина)\n"+
                                             "2. Прямой вызов GC.Collect()\n"+
                                             "3. Нехватка системной памяти\n"+
                                             "4. Вызов API, влияющего на память\n"+
                                             "5. Завершение работы приложения\n"),

                ("628.Почему вручную вызывать GC — плохая практика?","1. Нарушение самооптимизирующейся логики GC\n"+
                                                                     "2. Преждевременное движение объектов\n"+
                                                                     "3. Снижение производительности из  за очистки 2 поколения\n"+
                                                                     "4. Иллюзия решения проблем\n"),

                ("629. Как узнать, в каком поколении находится объект?","метод GC.GetGeneration(object obj)"),

                ("630.Какой метод можно использовать для освобождения неуправляемых ресурсов?","интерфейс IDisposable и шаблон Dispose\n"+
                                                                                               "использование using гарантирует вызов Dipose()\n"+
                                                                                               "Деструктор\n"),

                ("631.Что такое Span<T> и его главное преимущество?","Это стурктура, предоставляет безопасное и безкопируемое представление\n"+
                                                                     "непрерывной области памяти, независимо от того, откуда эта память взята\n"+
                                                                     "откуда может быть память:\n"+
                                                                     "1. Управляемые массивы\n"+
                                                                     "2. Стек(stackalloc)\n"+
                                                                     "3. Неуправляемая память unsafe\n"+
                                                                     "4. Строки(только для чтения, с помощью ReadOnlySpan<char>)"),

                ("632.Чем отличается Span<T> от Memory<T>?","Это родственные типы, решающие схожие задачи, но с важными различиями в семантике\n"+
                                                            "и применении. Понимание их отличий критически важно для правильно использования\n"+
                                                            "Span<T> для синхронного низкоуровнего кода,\n"+
                                                            "который работает только на стеке\n"+
                                                            "Memory<T> асинхронного и высокоуровневого кода, который может находится в куче\n"),

                ("633. Почему Span<T> не может быть полем класса?","Span<T> это ref struct. Может находится только в стеке\n"+
                                                                   "Предотвращение использования после освобождения\n"+
                                                                   "Не касается GC\n"+
                                                                   "Производительность\n"),

                ("634. Как Span<T> помогает избежать выделения памяти?","Span<T> не требует копирования, он просто является окном на эту память\n"+
                                                                        "создает кратковременный буфер в стеке с прямым доступом"),

                ("635.Где Span<T> особенно полезен?","1. Парсинг строк без выделения памяти\n"+
                                                     "2. Сетевое программирование и обработка пакетов\n"+
                                                     "3. Работа с файлами или потоком\n"+
                                                     "4. Криптография и математические выделения\n"+
                                                     "5. Высокопроизводительные API и библиотеки\n"+
                                                     "6. Микроконтроллеры и ресурсо-ограниченные среды\n"),

                ("636. Что означает принцип единственной ответственности (SRP)?","Один класс должен решать только одну задачу и \n"+
                                                                                 "и быть отвестенен только за одну часть функциональности\n"),

                ("637. Что нарушает принцип открытости/закрытости (OCP)?","1. явные проверки типа\n"+
                                                                          "2. проверка состояний\n"+
                                                                          "3. жесктие зависимости\n"),

                ("638.Как понять, что нарушен принцип подстановки Лисков (LSP)?","1. Код требует проверики на тип\n"+
                                                                                 "2. Подкласс усиливает предусловия\n"+
                                                                                 "3. Подкласс ослабляет постусловия\n"+
                                                                                 "4. Подкласс генерирует исключения\n"+
                                                                                 ""),

                ("639. В чём суть принципа разделения интерфейса (ISP)?","Лучше иметь много маленьких и точных интерфейсов,\n"+
                                                                         "чем один большой\n"+
                                                                         "интерфейсы должны реализовать только нужные классы\n"),

                ("640.Как реализовать инверсию зависимостей (DIP)?","1. Выделяем абстракции(интерфейсы)\n"+
                                                                    "2. Внедряем зависимость() передаем зависимость классу извне, а не создаем ее внутри\n"+"" +
                                                                    "внедрение через конструктор предпочтительнее\n"+
                                                                    "3. Компоновка приложения\n"+
                                                                    "Создаем конкретную модель и внедряем ее в сервис\n"),

                ("641.Что означает KISS?","Keep it simple stupid\n"+
                                          "1. Простые и понятные названия\n"+
                                          "2. Короткие методы и классы с одной ответственностью\n"+
                                          "3. Отказ от преждевременной реализации и золотых молотков\n"+
                                          "4. Использование простых алгоритмов\n"+
                                          "5. Читаемость важнее крутизны\n"+
                                          ""),

                ("642.В чем суть DRY?","Dont Repeat YourSelf не повторяйся\n"+
                                       "не копируй один и тот же код, а вынеси этот код в отдельное место и используй\n"+
                                       "1. Дублирование кода\n"+
                                       "2. Дублирование логики\n"+
                                       "3. Дублирование данных и конфигурации\n"),

                ("643.Почему принцип YAGNI может сэкономить ресурсы?","You Aint Gonna need It Вам это не понадобится\n "+
                                                                      "1. Экономия времени разработки\n"+
                                                                      "2. Экономия умственных ресурсов и концепции\n"+
                                                                      "3. Снижение технического долга и затрат на поддержку\n"+
                                                                      "4. Экономия ресурсов бизнеса\n"),

                ("644.Как понять, что код нарушает DRY?","1. Буквальное дублирование кода\n"+
                                                         "2. Дублирование логики\n"+
                                                         "3. Дублирование данных и констант\n"+
                                                         "4. Нарушение принципа единственной ответственности\n"+
                                                         "5. Почти одинаковый код\n"+
                                                         ""),

                ("645. Почему KISS и YAGNI конфликтуют с overengineering?","Они не конфликтуют они напрвлены на его предотвращение\n"),

                ("646. Чем отличается инкапсуляция от сокрытия реализации?","Инкапслуляция это упаковка в один ящик\n"+
                                                                            "Сокрытие реализации - это решение какие грани ящика сделать прозрачными, \n"+
                                                                            "а какие нет\n"),

                ("647. Как работает наследование в C#?","это механизм, позволяющий одному классу(наследнику), перенимать\n"+
                                                        "(наследовать) поля, свойства и методы другого класса\n"+
                                                        "При этом класс наследник может добавлять новую функциональность или изменять наследуемую\n"),

                ("648. Что такое полиморфизм?","Полиморфизм это способность объектов с одинаковой спецификацией\n"+
                                               "иметь различную реализацию и вести себя по-разному в ответ на один и тот же вызов метода\n"+
                                               "Полиморфизм вовремя выполнения. Наследование virtual и override методы\n"+
                                               "Полиморфизм во время компиляции. Достигается через перегрузку методов\n"),

                ("649. Что такое virtual, override и new?","virtual - это метод в базовом классе,который можно переопределить\n"+
                                                           "override - позволяет классу наследнику предоставить свою собственную реализацию\n"+
                                                           "new скрывает унаследованный метод. Это непереопределение а создание своего метода с таким же названием\n"),

                ("650. В чём разница между абстрактным классом и интерфейсом?","1. Абстрактный класс может содержать:\n"+
                                                                               "реализованные методы с телом\n"+
                                                                               "поля, констукторы\n"+
                                                                               "может наследоваться от абстрактного класса\n"+
                                                                               "2. Интерфейсы могут содержать методы с реализации по умолчанию в зависимости от версии\n"+
                                                                               "свойства, события с реализации или без в зависимости от версии\n"+
                                                                               "множественное наследование\n"+
                                                                               "статические поля в зависимости от версии\n"),

                ("651. В чем отличие паттернов \"Стратегия\" и \"Шаблонный метод\"?","Стратегия использует композицию и делегирование\n"+
                                                                                     "Он выносит изменяемое поведение в отдельную иерархию классов и позволяет менять его на лету\n"+
                                                                                     "Шаблонный метод использует наследование. Он фиксирует скелет алгоритма в базовом классе, позволяя подклассам переопеределять отдельные шаги\n"),

                ("652. Когда следует применять паттерн \"Фабричный метод\"?","1. Когда заранее неизвестны конкретные типы объектов\n"+
                                                                             "2. Когда вы хотите дать возможность подклассам определять какой объект создавать\n"+
                                                                             "3. Когда нужно отделить код создания от кода использования\n"+
                                                                             "4. Когда вы планируете расширяемую архитектуру\n"+
                                                                             "5. Когда объект требует сложной настройки которую не стоит дублировать\n"+
                                                                             ""),

                ("653. Как реализуется паттерн \"Одиночка\" в многопоточной среде?","Наивная реализация паттерна небезопасна в многопоточной среде\n"+
                                                                                     "1. использовать блокировку\n"+
                                                                                     "2. статический конструктор\n"+
                                                                                     "3. Lazy<T>\n"+
                                                                                     ""),

                ("654.Чем \"Декоратор\" отличается от \"Адаптера\"?","Адаптер меняет интерфейс объекта, чтобы он стал совместим с другим кодом\n" +
                                                                      "Он решает проблему несовместимости\n"+
                                                                      "Декаратор добавляет новое поведение объекту, не меняя его интерфейса.\n"+
                                                                      "Он решает проблему расширения функциональности\n"),

                ("655.Какие задачи решает паттерн \"Наблюдатель\"?","1. Создает отношение один ко многим\n"+"" +
                                                                    " где один объект(subject) уведомляет множество наблюдателей об изменениях своего состояния\n"+
                                                                    "2. Слабосвязанная архитектура\n"+
                                                                    "Позволяет объектам взаимодействовать без жестких зависимостей.\n"+
                                                                    "наблюдатели знают только об интерфейсе Subject, а Subject знаеи об интерфейсе Observer\n"+
                                                                    "3. автоматическое распространение изменений\n"+
                                                                    "При изменений состояния Subject автоматически уведомляет всех подписанных наблюдателей\n"+
                                                                    "4. Динамическое добавление удаление зависимостей\n"+
                                                                    "Наблюдаетели могут подписываться и отписываться во время выполнения программы"),

                ("656.Что такое \"Информационный эксперт\"?","Information expert\n"+
                                                              "Ответственность должна быть назначена тому классу,\n"+
                                                              "который обладает необходимой информацией для ее выполнения\n"),

                ("657.Как работает \"Создатель\"?","определяет какой класс должен отвечать за создание объектов другого класса\n"),

                ("658.В чем суть принципа \"Низкая связанность\"?","классы должны быть максимально независимы друг от друга и иметь минимальные возможности\n"),

                ("659.Чем полезна \"Высокая связность\"?","Класс с высокой связаностью содержит только те методы и данные, которые\n"+
                                                          "непосредственно относятся к его основной ответственности\n "+
                                                          "Все элементы класса работают вместе для выполнения одной четкой задачи\n"),

                ("660.Что делает \"Контроллер\" в GRASP?","Служить посредником между UI(пользовательским интерфейсом) и бизнес-логикой\n"+
                                                          "обрабатывая входящие запросы и делегируя их выполнение соответсвующим объектам доменной области\n"),

                ("661. Что такое \"Божественный объект\"?","это антипаттерн, при котором один класс или модуль\n"+
                                                           "берет на себя слишком много задач и становится сложным и монолитным\n"),

                ("662. Почему \"Дублирование кода\" считается запахом?","Потому что оно создает серьезные проблемы для поддержки\n"+
                                                                        "расширения и надежности\n"+
                                                                        ""),

                ("663.Как \"Примитивная одержимость\" влияет на качество кода?","это антипаттерн, когда разработки используют примитивные типы\n"+
                                                                                "вместо создания специализированных классов\n +" +
                                                                                "Потеря семантики и смысла. Сложность рефакторинга и изменений\n"),

                ("664.Чем опасен запах \"Флаги как параметры методов\"?","1. Нарушение принципа единственной ответственности\n"+
                                                                          "2. Нарушение принципа низкой связаности\n"+
                                                                          "3. Ухудшение читаемости\n"+
                                                                          "4. Сложность тестирования\n"),

                ("665.Что означает запах \"Формальные параметры не используются\"?","метод обьявлен с параметрами, которые неиспользуются в его реализации"),

                ("",""),


                ("667.Что делает ключевое слово await на уровне IL?","1. Создание класса стейт машины\n"+
                                                                     "класс реализует интерфейс IAsyncStateMachine\n"+
                                                                     "Хранит все состояние метода\n"+
                                                                     "2. Преобразование тела метода\n"+
                                                                     "Исходное тело вашего async-метода полностью переписывается в метод MoveNext\n"+
                                                                     "у сгенерированного класса стейт машины\n"+
                                                                     "3. Механизм продолжений который автоматически возобновляет выполнение метода после завершения awaited задачи\n"+
                                                                     "4. билдер который отвечает за создание и управление возвращаемой Task"),

                ("668. Может ли async метод возвращать void?","можно но есть ограничения:"+
                                                              "1. невозможность ожидания await\n"+
                                                              "2. ошибки в async void не могут быть пойманы вызывающим кодом\n"+
                                                              "3. Нарушение принципов композиции\n"+
                                                              "4. Сложность тестирования\n"),

                ("669.Что произойдет, если не использовать await внутри метода, помеченного как async?","если просто нет await выполнится метод синхронно,\n"+
                                                                                                        "если будут асинхронные операции без await то будет неопределенное поведение\n"),

                ("670.Чем отличается await SomeAsyncMethod() от return SomeAsyncMethod()?","await ожидает завершения задачи,возвращаемой SomeAsyncMethod()\n"+
                                                                                           "и только потом продолжает выполнение текущего метода\n"+
                                                                                           "return немедленно возвращает задачу, полученную от SomeAsyncMethod(),\n"+
                                                                                           "вызывающему коду.Текущий метод не ждет ее завершения\n"),

                ("671.Что вернёт метод с сигнатурой async Task<int>, если в нем произойдёт исключение?","статус Fauted и исключение"),


                ("672.В чем разница между Task.Run и Task.Factory.StartNew?","Task.Run это обертка над Task.Factory.StartNew\n"+
                                                                             "Task.Factory.StartNew это низкоуровневый метод с большим количеством параметров\n"+
                                                                             "для тонкой настройки. Его гибкость и является главной опасностью\n "+
                                                                             "лучше всего использовать Task.Run, Task.Factory.StartNew для специфических задач\n "),

                ("673. Нужно ли использовать Task.Run внутри ASP.NET контроллеров?","Нет это создает пул в пуле. Нужно использовать async"),

                ("674. В каком случае Task.Run может пригодиться в UI-приложении?","Основная задача оставлять интерфейс отзывчивым\n"+
                                                                                   "а логику отправялть в фон через Task.Run()\n"),

                ("675.Что произойдёт, если вызвать Task.Run внутри Task.Run?","Ничего не сломается.Код выполнится корректно\n"+
                                                                              "Скорее всего антипаттерн. В 95% случаев вложенный Task.Run внутри другого Task.Run\n"+
                                                                              "не нужен и только добавляет лишние накладные расходы на планирование задач без реальной выгоды\n"+
                                                                              "Есть редкие исключения, когда это может быть оправдано для изоляции особенно тяжелой и\n"+
                                                                              "блокирующей операции внутри уже фоновой задачи\n"),

                ("676. Как Task.Run использует ThreadPool?","Task.Run это диспетчер который дает работу ThreadPool\n"+
                                                            "1. Создается объект Task,Task<int>\n"+
                                                            "2. код делегата выполняется не сразу, а как освободится очередь пула потоков\n"+
                                                            "3. когда делегат завершает свою работу, поток освобождается и возвращается в пул\n"+
                                                            "Task переходит в состояние RanToCompletion или Faulted"),

                ("677. Что делает ConfigureAwait(false)?"," ConfigureAwait(false) сообщает механизму await что не обязательно\n"+
                                                          "возобновлять выполнение в исходном контексте синхронизации\n"+
                                                          "Это может предотвратить взаимоблокировки и немного улучшить производительность\n"+
                                                          "желательно использовать в библиотеках и неиспользовать в коде обнавляющего UI\n "),

                ("678. В каких проектах особенно важно использовать ConfigureAwait(false)?","1. В библиотечном коде (Library Code)\n"+
                                                                                             "2. Для микро-оптимизации в коде приложения\n"+
                                                                                             "3.Главная суперсила: Предотвращение взаимоблокировок (Deadlocks)\n"),

                ("679. Почему ConfigureAwait(false) может ускорить выполнение кода?","1. Устранение накладных расходов на переключение контекста\n"+
                                                                                      "2. Улучшение масштабируемости за счет избежания \"очередей к контексту\"\n"
                                                                                      +"3. Устранение лишних переходов между потоками"),

                //("670. Что произойдёт, если не использовать ConfigureAwait(false) в UI-приложении?","Все будет работать правильно\n"),

                //("671. Работает ли ConfigureAwait(false) в .NET 6+ внутри ASP.NET Core?","Больше не требуется так как в .NET 6+ по умолчанию оптимизирован контекст синхронизации\n"),

                //("672. Что делает cancellationToken.ThrowIfCancellationRequested()?","Это ключевой метод для корректной обработки отмены операции в Net\n"+
                //                                                                     "это метод проверяет был ли запрос на отмену операции для данного токена\n"+
                //                                                                     "Если запрос был, метод немедленно бросает исключение OperationCanceledException\n"+
                //                                                                     "Где то создается источник отмены CancellationTokenSourse\n"+
                //                                                                     "Токен отмены (CancellationToken) из этого источника передается в метод, который должен поддерживать отмену\n"+
                //                                                                     "Внутри долгой операции периодически вызывается cancellation.ThrowIfCancellationRequasted()\n"+
                //                                                                     "когда внешний код  вызывает Cancel() на источнике, все токены, выданные этим источником получают сигнал отмены\n"+
                //                                                                     "при следующим вызове ThrowIfCancellationRequasted() метод видит этот сигнал и бросает OperationCanceledException\n"+
                //                                                                     "Вместо ThrowIfCancellationRequested() можно использовать свойство IsCancellationRequested для более гибкого поведения\n"+
                //                                                                     "cancelationToken.IsCancellationRequested если true вызвать логику отмены вручную\n"),

                //("673. Как можно отменить Task.Delay?","1.Создаем источник токена var cts = new CancellationTokenSource()\n"+
                //                                        "2. Запускаем задержку с возможностью отмены Task delayTask = Task.Delay(TimeSpan.FromSeconds(10), cts.Token)\n"+
                //                                        "3.await Task.Delay(2000);cts.Cancel() отменяем и обрабатываем результат через try catch"),

                //("674. Что произойдёт, если CancellationToken отменится, но в методе его не проверяют?","Если сам метод не проверяется и методы,которые он вызывает не проверяются ничего не пройзойдет\n"+
                //                                                                                        "если в вызываемом метода будет проверка то будет выброшен OperationCanceledException\n"),

                //("675.Как отменить цепочку задач?","Создать один CancellationTokenSource() и передавать cancellationToken всем методам\n"),

                //("676. Можно ли повторно использовать CancellationTokenSource?","Нет после отмены нужно создавать новый\n"),

                //("677. Что произойдёт, если исключение выбрасывается после await внутри async Task метода?","1. Исключение захватывается механизмом async/await\n"+
                //                                                                                            "2. Задача завершается с состоянием Faulted(а не RanToCompletion)\n"+
                //                                                                                            "3. Исключение оборачивается в AggregateException внутри задачи\n"+
                //                                                                                            "4. Исключение пробрасывается при ожидании задачи(await) или обращении к .Result\n"),

                //("678. Как поймать исключение из async void метода?","никак. Можно только сделать try catch внутри метода и залогитровать\n"+
                //                                                     ""),

                //("679.Можно ли использовать try/catch вокруг await SomeAsyncMethod()?","да, можно и нужно\n"),

                ("680. Как работают исключения в цепочке .ContinueWith(...)?","нужно проверять каждый вызов через свойство IsFaulted\n"+
                                                                              "можно собрать все ошибки в continueWith, TaskContinuationOptions.OnlyOnFaulted в Exception.InnerException\n"),

                ("681. Почему async void считается антипаттерном?","1. Невозможность обработки исключений\n"+
                                                                   "2. Невозможность ожидания: на работает await,.Wait(), cancellationToken\n"+
                                                                   "3. проблемы с тестированием\n"+
                                                                   "4. Не возможно работать в цепочке\n"+
                                                                   "5. Сложность отладки\n"),

                ("682. Что такое TAP и какие ключевые преимущества он даёт по сравнению с APM/EAP?","TAP(Task-based Asynchronous Pattern) это современный асинхронный шаблон в Net\n"+
                                                                                                    "основанный на типах Task и Task<T>, примел на смену APM/EAP\n"+
                                                                                                    "TAP представляет асинхронную операцию одним методом,\n "+
                                                                                                    "который возвращает Task и Task<TResult> и обычно имеет суффикс async\n"+
                                                                                                    "1. Единая модель TAP подходит для решения APM и EAP\n"+
                                                                                                    "2. Просто использования и читаемость\n"+
                                                                                                    "3. TAP легко поддерживает отмену, APM/EAP отмена была сложной или невозможной\n"+
                                                                                                    "4. Естественная обработка исключений. TAP выбрасываются в точке await.\n"+
                                                                                                    "APM/EAP ошибки обрабатывались в колбеках или событиях часто теряя контекст\n"+
                                                                                                    "5. Композиции и цепочки вызовов\n"+
                                                                                                    "6. await вместо callback\n"+
                                                                                                    "7. TAP легче тестировать\n"+
                                                                                                    ""),

                ("683.Что вернёт метод, реализующий TAP, если его не дожидаться с await?","1. вернет объект Task, а не результат\n"),

                ("684. Обязательно ли использовать async и await, чтобы следовать TAP?","Нет может реализоваться без async/await"),

                ("685. В чём плюсы TAP по сравнению с Begin/End-методами?","1. Простота использования\n"+
                                                                           "2. Естественный поток выполнения. Последовательный код\n"+
                                                                           "3. Композиция задач. Позволяет легко комбинировать операции\n"+
                                                                           "4. единая точка обработки исключений\n"+
                                                                           "5. Отмена операций с CancellationToken\n"+
                                                                           "6. Производительностью TAP оптимизирован\n"+
                                                                           "7. TAP универсален\n"),

                ("686. Что происходит на уровне исполнения при вызове await?","1. Трансформация кода компилятором\n"+
                                                                              "2. создание State Machine\n"+

                                                                               " 3.Проверка завершенности await\n"+
                                                                               "4. сохранение контекста\n"+
                                                                               "5. возврат управления вызывающему коду\n"+
                                                                               "6. Синхронизация и обработка исключений\n"),

                ("687. Какой тип возвращает метод, в котором используется await?","Task<TResult>, Task, void"),

                ("688. Что произойдёт, если вызвать await на уже завершённой задаче?","это оптимизированный синхронный путь\n"+
                                                                                      "без накладных расходов асинхронности\n"+
                                                                                      "Компилятор эффективно обрабатывает этот случай"),

                ("689. Можно ли вызывать await вне метода с модификатором async?","Нет будет ошибка компиляции\n"),

                ("690.  Как использовать await в цикле?","можно написать await метод прям в условии\n"),

                ("691.Что такое SynchronizationContext?","это абстракция NET, которая представляет контекст синхронизации для \n"+
                                                         "выполнения кода в определенном потоке или контексте\n"+
                                                         "Это механизм, который управляет тем, в каком потоке продолжается выполнение после await\n"+
                                                         "Управляется через ConfigureAwait . Отсутствует в консольных приложениях и ASP.Net\n "),

                ("692.  Чем TaskScheduler отличается от SynchronizationContext?","Это два разных механизма планирования выполнения в net.\n"+
                                                                                 "SynchronizationContext привязка к потоку, а TaskScheduler управлениями задач\n"),

                ("693. Как влияет SynchronizationContext на await?","1. Определяет где код выполняется после await\n"+
                                                                    "2. Как происходит возврат в исходный текст\n"+
                                                                    "3. Производительность и потокобезопасность\n"),

                ("694.Как отключить возврат в SynchronizationContext?","использует метод ConfigureAwait(false)\n"),

                ("695.  Какой контекст используется в консольном приложении .NET?","В консольном приложении нет нет специального SynchronizationContext по умолчанию\n"+
                                                                                    "Это означает что продолжение после await выполняются в произвольном потоке\n"),

                ("696. Как обрабатываются исключения, если await отсутствует?","Исключение выбрасывается сразу при вызове,\n"+
                                                                                "отработает также как синхронный метод\n"+
                                                                                "вернет Faulted Task"),

                ("697. Что произойдёт, если async void метод выбросит исключение?","получится не контроллируемое исключение\n"+
                                                                              ""),

                ("698. Как проверить, завершилась ли Task с ошибкой?","1. свойство IsFaulted()\n"+
                                                                      "2. проверка свойства Status. Task.Status==TaskStatus.Faulted\n"+
                                                                      "3. использование свойства Exception task.Exception!=null\n"+
                                                                      ""),

                ("699. Как обработать исключения из нескольких задач, например через Task.WhenAll?","1. Базовый подход через try catch\n"+
                                                                                                    "2. получение из AggregateException. allTask.Exception.InnerException\n"+
                                                                                                    "3. обработка на успешные и неуспешные через Where и Isfaulted\n"),

                ("700. Какой тип исключения генерируется при отмене через CancellationToken?","OperationCancelledException(ручная проверка) или его наследник TaskCancelledException(при отмене асинхрооных операций)\n"),

                ("701.Что делает Task.Yield() в async методе?","Это специальный метод, который заставляет асинхронный метод\n "+
                                                               "немедленно вернуть управление вызывающему коду, даже если он мог\n"+
                                                               "бы продолжить синхронное выполнение\n"+
                                                               "Использовать для предотвращения блокировки, тестирования и многозадачности\n"),

                ("702.Task.CompletedTask","это статическое свойство которое возвращает уже завершенную успешную задачу\n "),

                ("703. В каких случаях Task.Yield() может быть полезен?","1. Предотвращение блокировки UI потоков\n"+
                                                                         "2. Многозадачность в циклах\n"+
                                                                         "3. Тестирование асинхронного поведения\n"),

                ("704. Что происходит, если использовать await Task.Yield() в начале метода?","Возврат управления вызываему коду\n"+
                                                                                              "создание асинхронной точки\n"+
                                                                                              ""),

                ("705. Можно ли использовать Task.Yield() в обычных не-UI приложениях?","можно\n"+
                                                                                         "1. Кооперативная многозадачность в циклах\n"+
                                                                                         "2. Предотвращение stack overflow в рекурсии\n"+
                                                                                         "3. Fair scheduling в высоконагруженных сервисах\n"+
                                                                                         "4. Тестирование асинхронного поведения.\n" +
                                                                                         "" +
                                                                                         " "),

                ("706. Что делает ConfigureAwait(false) на практике?","отключает захват и восстоновление контекста синхронизации\n"+
                                                                      "при продолжении выполнения после await\n"),

                ("707. Почему ConfigureAwait(false) важен в библиотечном коде?","1.Может быть получится deadlock\n"+
                                                                                "2. Независимость от констекста вызова\n"+
                                                                                "3. Улучшенная производительность\n"+
                                                                                "4. Предсказуемость поведения\n"),
                ("708. Где ConfigureAwait(false) может быть вреден?","1. UI элементы\n"+
                                                                     "2. устаревший ASP.Net HttPContext\n"+
                                                                     "3. код требующий определенного контекста\n"),

                ("709. Как ConfigureAwait(false) влияет на производительность?","существенно влияет, но неодназначно\n"+
                                                                                "1. Снижение нагрузки на контекст сихронизации\n"+
                                                                                "2. Избегание лишних переключений контекста\n"+
                                                                                "3. Уменьшение аллокаций памяти\n"+
                                                                                "снижение за счет проверок\n"),
                ("710. Что такое IProgress<T> и зачем он нужен?","Интерфейс для безопасной передачи прогресса и промежуточных результатов\n"+
                                                                 "из асинхронных операций в UI или другой контекст\n"+
                                                                 "интерфейс void Report(T value)\n"),

                ("711. Какой класс обычно реализует IProgress<T>?","Progress<T> стандартный класс, который реализующий IProgress<T>\n"+
                                                                   "Он представляет готовую реализацию для безопасной передачи прогресса\n"),

                ("712. Как IProgress<T> обеспечивает потокобезопасность?","обеспечивает потокобезопасность через автоматическую маршрутизацию вызовов  в правильный контекст\n"),

                ("713.  Можно ли использовать IProgress<T> в консольных приложениях?","Можно, но нет синхронизации и нет гарантии порядка вывода\n"),

                ("714. Почему нельзя использовать обычный Action<T> вместо IProgress<T>?","Action<T> потоконебезопасен и выполняется в том же потоке\n"+
                                                                                          ""),

                ("715. Что делает Task.Run?","это метод в NET, который ставит указанную работу в очередь на выполнение в пуле\n"+
                                             "потоков и возвращает задачу Task или Task<TResult>\n"+
                                             "основная его задача запустить выполнение кода в фоновом режиме,\n"+
                                             "что бы не блокировать поток\n"+
                                             "1. Принимает делегат или лямбду выражение или имя метода\n"+
                                             "2. Передает этот делегат в пул потоков Thread Pool\n"+
                                             "3. Немедленно возвращает объект Task, который является обещанием\n"+
                                             "предоставить результат или информацию о состоянии операции в будущем\n"+
                                             "4. Выполняется в потоке из пула. Пул потоков выбирает свободный поток и выполняет в нем переданный код\n"),

                ("716. Когда уместно использовать Task.Run в ASP.NET?","В ASP. NET не нужно использовать\n"+
                                                                       "сам запрос в контроллере занимает поток из пула,\n"+
                                                                       "а потом сам task.Run занимает поток из этого же пула\n"+
                                                                       "первый поток освобождается и ждет второго. В этом нет смылса\n"+
                                                                       "Единстевенный вариант использования это потоконебезопасная или сторонняя библиотека"),

                ("717. Когда оправдано использование Task.Run в UI-приложениях?","UI приложениях это необходимость чтоб не было блокировки\n"+
                                                                                 "Выполнение вычислительно сложных задач и или вынуждены использовать синхронный API для связи с файлом или базаой данных\n"),

                ("718.Как Task.Run влияет на масштабируемость серверного приложения?","Task.Run негативно влияет на масштабируемость,\n"+
                                                                                      "потому что потребляет дополнительные потоки из ограниченного пула потоков\n"+
                                                                                      "добавляя накладные расходы на переключение контекста\n"),

                ("719. Чем Task.Run отличается от Thread?","Task.Run и Thread это принципиально разные подходы к многопоточности\n"+
                                                           "Task.Run представляет собой более современную и высокоуровневую абстракцию\n"+
                                                           "Thread это низкоуровневый примитив. Работа напрямую с потоком операционной системы\n"+
                                                           "Вы сами управляете его жизненным циклом(запуск завершение) и все его деталями\n"+
                                                           "Task.Run это высокоуровневая абстракция над понятием работа и задача\n"+
                                                           "Вы не управляете потоком напрямую. Вы говорите выполни код, а среда выполнения сама решает в каком\n"+
                                                           ""),

                ("720.Что делает Task.FromResult?","Это простой метод, который создает уже завершенную успешную задачу Task c указанным результатом\n"+
                                                   "1. Реализация асинхронного интерфейса, когда операция синхронная\n"+
                                                   "2. Создание заглушек для unit тестов\n"+
                                                   "3. Возврат констант и простых значений из асинхронного метода\n"+
                                                   "4. Реализация ошибок или отмены с помощью Task.FromCanceled или Task.FromException\n"+
                                                   ""),

                ("721. Можно ли использовать await Task.FromResult(x)?","это бессмысленно создавать ожидание уже завершенной задачи\n"),

                ("722. Как Task.FromResult помогает при unit-тестировании?","это один из главных инструментов в unit тестировании асинхронного кода\n"+
                                                                            "1. Создание заглушки вместо работы с базой данных\n"+
                                                                            "2. Тестирование ошибок и крайних случаев\n"+
                                                                            "3. Упрошенный код\n"),

                ("723. Есть ли разница в производительности между Task.FromResult(x) и return x в async методе?","есть небольшая разница. Создается Task и небольшие накладные расходы\n"+
                                                                                                                 ""),

                ("724. Что делает Task.WhenAll?","это один из самых полезных инструментов для работы с асинхронным методом\n"+
                                                 "Его главная задача эффективно ждать завершения нескольких асинхронных операций задач\n"+
                                                 "1. Параллельное выполнение независимых операций\n"+
                                                 "2. обработка результатов(можно вернуть результы в виде массива\n)"+
                                                 "3. Ожидание выполнения группы операций\n"+
                                                 "4. Обработка ошибок, если одна операция завершилась с ошибкой, то и задача возвращенная Task.WhenAll() вернется с ошибкой\n"),

                ("725. Что произойдёт, если одна из задач завершится с исключением?","1. Исключение в одной задачи\n"+
                                                                                     "Task.WhenAll завершается в состояние Faulted\n"+
                                                                                     "будет выброшено первое исключение\n"+
                                                                                     "2. Исключения в нескольких задачах\n"+
                                                                                     " все ошибки будут в свойстве Exception\n"+
                                                                                     "3. выжившие результаты можно получить через TAsk.Result\n"+
                                                                                     "4. если результат должен быть массив, то вместо то него будет исключение\n"),

                ("726. Что вернёт Task.WhenAll<Task<T>>()?","1. Результатом будет массив\n"+
                                                            "2. Порядок будет гарантирован\n"+
                                                            "3. Если будет ошибка не будет массива\n"+
                                                            "4. Все задачи должны быть одного типа\n"),

                ("727.  Можно ли комбинировать WhenAll и await в цикле?","можно.\n"+
                                                                         "Запуск всех задач одновременно. Собрать через цикл и запустить\n"+
                                                                         "Пакетная обработка. Запуск задач через цикл, но с определенным количеством\n"+
                                                                         "через SemaphoreSlims делить параллелизм\n"),

                ("728. Когда WhenAll предпочтительнее await по очереди?","Когда результаты независимы друг от друга\n"+
                                                                         "Требуют длительнного ожидания\n"),

                ("729. Что делает Task.WhenAny?","Task.WhenAny() ожидает завершения любой одной задачи из представленного набора\n"+
                                                 "и возвращает эту завершенную задачу\n"+
                                                 "1. Вы передаете ему коллекцию задач Task[] или Task<T>[]\n"+
                                                 "2. Результатом будет первая завершившаяся задача из исходного набора\n"+
                                                 "3. когда делается await получаете саму завершенную задачу, а не результат\n"+
                                                 "4. чтоб получить результат нужно сделать await уже для завершенной задачи\n"+
                                                 "или использовать ее свойства Result, Status, Exception\n"),

                ("730.Что вернёт Task.WhenAny(...)?","Task<Task> или Task<Task<T>>\n"+
                                                     "Возвращаемая Task<Task> находится в состоянии RanToCompletion\n"+
                                                     "а ее свойство Result содержит ссылку на ту задачу которая завершилась раньше\n"+
                                                     "можно проверить через == какая задача выполнилась первой и быть готовым к обработке ошибок после второго await\n"),

                ("731. Что будет с остальными задачами после WhenAny?","Они будут выполняться\n"+
                                                                       "Можно дождаться выполнения всех задач, если нужно\n"+
                                                                       "или отменить через CancellationToken\n"+
                                                                       "можно просто проигнорировать\n"),

                ("732.Как реализовать таймаут с помощью WhenAny?","самый частый сценарий для использования Task.WhenAny()\n"+
                                                                  "две задачи одна с полезной, а другая с задержкой Task.Delay()\n"+
                                                                  "проверяем через == кто первее, если Delay то кидаем ошибку\n"),

                ("733.Как работает Task.Delay?","Часто используемый метод в асинхронном програмировании\n"+
                                                "создает задачу которая переходит в состояние RanToCompletion через указанный промежуток времени\n"+
                                                "Он не блокирует текущий поток\n"),

                ("734.Можно ли использовать Task.Delay в цикле? ","Можно. Это частое применение\n"+
                                                                   "1.Периодическое выполнение\n"+
                                                                   "2. Повторные попытки с задержкой\n"+
                                                                   "3. анимация или постепенное изменение\n"+
                                                                   "4. Ограничение частоты запросов\n"),

                ("735. Чем Task.Delay отличается от Thread.Sleep?","Task.Delay и Thread.Sleep решают похожие задачи\n"+
                                                                   "но кардинально разными способами\n"+
                                                                   "1. Thread.Sleep блокирует поток\n"+
                                                                   "2. Thread.Sleep только в синхронных методах\n"+
                                                                   "3. Thread.Sleep не поддерживает CancellationToken\n"),

                ("736. Что делает RetryOnFault?","это паттерн проектирования для реализации логики повторных попыток при сбоях\n"+
                                                 "основная автоматически повторить операцию если завершилась со сбоем\n"),

                ("737. Как реализовать WhenAllOrFirstException?","WhenAllOrFirstException либо задачи все завершены успешно либо когда одна задача завершилась с ошибкой \n"+
                                                                 "реализуется через цикл + WhenAny() + IsFaulted\n"),

                ("738. Зачем нужен NeedOnlyOne?","это паттерн, когда нужно выполнить несколько избыточных операций,но\n"+
                                                 "достаточно успешного результата любой одной из них\n"+
                                                 "реализация цикл-WhenAny()-IsFaulted\n"),

                ("739. Какие проблемы могут возникнуть при реализации Retry?","Некорректная обработка исключений. Если ошибки не исправиться повторным вызовом то нет смысла их повторно вызывать\n"+
                                                                              "Обязательно передавать cancellationToken\n"+
                                                                              "метод может выполниться несколько раз. Обрабатывать эту ситуацию\n"+
                                                                              "проверять правильность выделения памяти и логики при повторном вызове\n"+
                                                                              ""),

                ("740. что такое TaskCompletionSource","это механизм ручного управления жизненного цикла задачи Task\n"+
                                                       "он позволяет создавать задачи и независимо управлять их состоянием\n"+
                                                       "завершать успехом, ошибкой или отменой\n"+
                                                       "методы: \n"+
                                                       "SetResult завершает задачу успешно с результатом\n"+
                                                       "SetException завершает задачу с ошибкой\n"+
                                                       "SetCanceled отменяет задачу\n"+
                                                       "имеются безопасные методы Try которые возвращают bool\n"),

                ("741. Зачем кэшировать Task, а не результат?","Чтоб избежать гонки. Task проще сделать атомарным чем результат\n"+
                                                               "Если несколько потребителей на один и тот же результат\n"+
                                                               "Обработка ошибок\n"+
                                                               "можно привязать дополнительный токент отмены\n"),

                ("742. Как избежать гонки при кэшировании Task?","1. использовать Lazy<Task<T>>\n"+
                                                                 "2. ConcurrentDictionary с атомарными операциями\n"+
                                                                 "3. InterLocked.CompareExchange\n"),

                ("743. Какие подводные камни у Task-кэша?","1. Неконтролируемый рост памяти\n"+
                                                           "2. Кеширование Faulted\\Canceled задач\n"+
                                                           "3. Задачи могут захватывать внешние зависимости\n"+
                                                           "4. Проблемы с обновлениями\n"+
                                                           "5. Может закешироваться задача которая никогда не выполнится\n"),

                ("744. Чем отличается кэш на Task<T> от обычного словаря значений?","У обычного словаря:\n"+
                                                                                    "1. Значение должно быть вычислено до помещения в кеш\n"+
                                                                                    "2. Может быть несколько одновременных вычислений для одного ключа\r\n// Пока один поток вычисляет значение, другие блокируются или получают старое значение\n"+
                                                                                    "3. Поток блокируется на время вычислений\n"+
                                                                                    "4. Выкидывает исключения немеделенно\n"+
                                                                                    "5. нужно явное обновление\n"+
                                                                                    ""),

                ("745. Что делать, если кэшируемая задача падает?","1. Немедленная инвалидация кеша. Удаление задачи\n"+
                                                                   "2. автоматическая инвалидация через ContinueWith\n"+
                                                                   "3. кеширование с повторными попытками Retry\n"+
                                                                   "4. Разделение кеша для успешных и неуспешных\n"),

                ("746. В чём отличие BlockingCollection и BufferBlock<T>?","Это два принципиально разных подхода к реализации producer customer pattern\n"+
                                                                           "BlockingCollection синхронный, блокирующий\n"+
                                                                           "BufferBlock<T> асинхронный, неблокирующий\n"+
                                                                           ""),

                ("747. Как работает BufferBlock<T>?","представялет собой асинхронную очередь с возможностью ограничения размера\n"+
                                                     "Producers отправляют данные с помощью SendAsync()\n"+
                                                     "Consumers() получают данные с помощью ReceiveAsync()\n"+
                                                     "Автоматическая синхронизация между producers и consumers"),

                ("748. Как реализовать producer-consumer на Channel<T> или BufferBlock<T>?","это современные способы реализации producer-consumer pattern\n"+
                                                                                            "Channel<T> современная высокпроизводительная замена\n"),

                ("749. Как обработать отмену при чтении из BufferBlock<T>?","передать cancellationToken в методы ReceiveAsync и OutputAvailableAsync\n"+
                                                                            "создать BufferBlock с токеном отмены\n"+
                                                                            ""),

                ("750. Зачем использовать такие коллекции Channel<T>, BufferBlock<T> вместо обычной Queue<T>?","Channel<T>, BufferBlock<T> решают другие задачи, чем обычная Queue<T>\n"+
                                                                                    "1. Асинхронность\n"+
                                                                                    "2. Потокобезопасность\n"+
                                                                                    "3. Ограничение размера\n"+
                                                                                    "4. Множественные consumers и producers\n"+
                                                                                    "5. Простая отмена операций\n"+
                                                                                    "6. Интеграция c async/await\n"),

                ("751. В каких случаях в .NET-приложении стоит использовать потоки?","1. вычислительно сложные операции. Создать отдельный поток, чтоб он не блокировать главный поток\n"+
                                                                                     "2. работа с синхроными API\n"+
                                                                                     "3. создание выделенных долго живущих воркеров. Фоновый процесс,  который независим от действий пользователя\n"+
                                                                                     "4. для взаимодействия с компонентами которые требуют один поток\n "),

                ("752. Чем потоки лучше процессов?","Потоки(Threads)  и процессы(Processes) это разные уровни изоляции и разделения ресурсов\n"+
                                                    "Потоки не всегда лучше процессов, но они эффективнее для решения кокретного круга задач\n"+
                                                    "внутри одного приложения\n"+
                                                    "1. Создание процесса это очень тяжелая операция для ОС\n"+
                                                    "2. Процессы изолированы друг от друга. Память одного процесса по умолчанию недоступна другому\n"+
                                                    "3. каждый процесс имеет свое собственное виртуальное адресное пространство. Это приводит к большему общему потреблению памяти ОС\n"+
                                                    "4. Переключение между процессами медленнее, так как требует обновления кеша\n"+
                                                    ""),

                ("753. В каких сценариях многопоточность может навредить?","1.Слишком большое количество потоков. Постоянное переключение контекста вместо выполнение полезной работы\n"+
                                                                            "2. Состояние гонки. Несколько потоков изменяют одни и те же данные\n"+
                                                                            "3. Взаимные блокировки\n"+
                                                                            "4. Голодание потоков. Не удается получить доступ к потоками из зи занятости другимим\n"+
                                                                            "5. Сложность отладки и тестирования\n"+
                                                                            "6. Черезмерная синхронизация. Весь код в lock\n"),

                ("754. Как потоки помогают повысить масштабируемость?","Потоки это фундаметальный инструмент для повышения масштабируемости\n"+
                                                                       "1.Эффективное использование ресурсов многопроцессорных систем.одновременное выполнение нескольких потоков\n"+
                                                                       "2. обслуживание множества одновременных запросов.\n"+
                                                                       "3. параллелизм в операциях ввода вывода\n"),

                ("755. Когда использование async лучше, чем создание потока?","async вовремя ожидания отпускает поток\n"+
                                                                              "1. Операции Ввода Вывода\n"+
                                                                              "2. Веб сервисы и серверы(Asp.Net Core WCF)\n"+
                                                                              "3. Сохранение отзывчивости UI  без лишних потоков\n"+
                                                                              ""),

                ("756. Кто занимается планированием потоков в .NET?","Планированием потоков занимается планировщик ОС\n"+
                                                                     "1. Планировщик ОС\n"+
                                                                     "2. Пул потоков ThreadPool менеджер ресурсов\n"+
                                                                     "3. Планировщик задач TaskScheduler диспетчер абстракций. "),

                ("757. Какие значения приоритета есть у потока?","1. ThreadPriority.Lowest\n"+
                                                                 "2. ThreadPriority.BelowNormal\n"+
                                                                 "3. ThreadPriority.Normal\n"+
                                                                 "4. ThreadPriority.AboveNormal\n"+
                                                                 "5. ThreadPriority.Highest\n"),
                ("758. Что произойдёт, если задать потоку ThreadPriority.Highest?","поток станет первым в очередь, но имеет последствия.\n"+
                                                                                   "может вызвать голодание у других потоков и вызовется аварийное закрытие приложения\n"+
                                                                                   "зависание самой системы если поток уйдет в бесконечный цикл\n"+
                                                                                   "может вызывать deadlock из за невозможности освободить поток с более низким приоритетом\n"),

                ("759. Как влияет планирование на производительность при большом количестве потоков?","С ростом числа потоков накладные расходы начинают доминировать над полезной работой\n"),

                ("760. Нужно ли вручную менять приоритет потока в .NET-программе?","В большинстве случаев нет. Ручное изменение нужно крайне редко\n"+
                                                                                    "Изменение приоритета ломает тонкую настройку планировщика\n"),

                ("761. Что произойдёт с фоновыми потоками при завершении основного потока?","фоновые потоки будут автоматически завершены\n"+
                                                                                            "потоки переднего плана препятствуют завершению\n"),

                ("762. Как сделать поток фоновым?","Thread.IsBackground = true или Task.Run\n"),

                ("763. Когда стоит использовать фоновые потоки?","Фоновые потоки надо использовать тогда, когда вы хотите чтоб она была второстепенной\n"+
                                                                 "по отношению основному процессу и можно было прервать в любой момент безопасно прервать\n"+
                                                                 ""),

                ("764.Какие потоки являются foreground по умолчанию?","Task.Run и ThreadPool по умолчанию фоновые"),

                ("765. Можно ли сделать поток фоновым после запуска?","можно поменять свойство IsBackground на true\n"),

                ("766.Как CLR соотносится с потоками Windows?","1. CLR использует потоки Windows\n"+
                                                                "2. каждый поток CLR это поток windows\n"+
                                                                "CLR не заменяет потоки windows а предоставляет абстракцию над ними\n "+
                                                                "добавляя функциональность и управление \n"),

                ("767.Что такое \"managed thread\"?","это абстракция CLR над нативными потоками операционной системы, которая\n"+
                                                     "предоставляет дополнительные возможности и безопасность в managed среде\n"),

                ("768.  Сколько нативных потоков можно создать в .NET-приложении?","Точной цифры нет\n"+
                                                                                   "основные ограничители: операционная система и ограниченный ресурс"),

                ("769.Как CLR оптимизирует работу с потоками?","Есть множество оптимизаций для эффективной работы с потоками\n"+
                                                               "1. ThreadPool динамическое управление пулом, балансировка\n"+
                                                               "2. работа с контекстом и оптимизация\n"+
                                                               "3. координация GC и многопоточности\n"+
                                                               "4. Эффективные state machine\n"),

                ("770.Что такое \"thread affinity\"?","это механизм который связывает выполнение определенного кода или задачи с определленым потоком\n"+
                                                      ""),

                ("771. Что такое ThreadPool?","ThreadPool это механизм в Net для управления рабочими потоками и эффективного\n"+
                                              "выполнения множества коротких задач без создания новых потоков для каждой операции\n"+
                                              "ThreadPool.QueueUserWorkItem(Dowork,)"),

                ("772. Почему ThreadPool эффективнее, чем new Thread?","1. Создание отдельного потока дорого. ThreadPool позволяет переиспользовать потоки\n"+
                                                                       "2. оптимизирует количество потоков и адаптируется к нагрузкам"),

                ("773. Где используется ThreadPool по умолчанию?","1. Task Parallel Library\n"+
                                                                  "2. Async/await паттерн\n"+
                                                                  "3. Asp.Net Core\n"+
                                                                  "4. EF Core\n"),

                ("774. Можно ли настроить поведение ThreadPool?","1. можно установить количество min max потоков ThreadPool.SetMinThreads или получить количество GetMinThreads(out,out)\n"+
                                                                  "2. использование TaskScheduler для кастомного планировщика\n"+
                                                                  "3. Parallel.Options для Parallel.For/ForEach\n"+
                                                                  "4. SemarphoreSlims для контроля параллелизма\n"+
                                                                  "5. через конфигурацию ASP.Net CORE\n"),

                ("775. Когда не стоит использовать ThreadPool?","1. долго выполняющиеся задачи\n"+
                                                                "2. задачи с высоким приоритетом. В пуле все потоки приоритет normal\n"+
                                                                "3. задачи требующие точного контроля за потоком\n"+
                                                                "4. задачи с особой конфигурацией\n"+
                                                                "5. блокирующие задачи\n"+
                                                                "6. задачи требующие порядка выполнения\n"),

                ("776. Что делают методы SetMinThreads и SetMaxThreads?","устанавливает минимимум и максимум потоков в ThreadPool\n"
                        ),

                ("777. Почему нельзя бездумно увеличивать MaxThreads?","1. Потребление памяти\n"+
                                                                       "2. увеличивается количество переключений контекста\n"+
                                                                       "3. должно быть оптимально относительно ядра\n"+
                                                                       "4. есть ограничения операционной системой\n"+
                                                                       "5. большое количество потоков создаст замедление и это может вызвать создание еще потоков\n"+
                                                                       "6. "),
                ("778. Как проверить текущие лимиты пула потоков?","GetMinThreads()\n"+
                                                                   "GetMaxThreads()\n"+
                                                                   "GetAvailableThreads() доступные потоки прямо сейчас\n"),

                ("779. Какое поведение по умолчанию у пула потоков?","Environment.Count(количество процессорных ядер) это минимум потоков. максимум отверсии net"+
                ""),


                ("780. В каком случае имеет смысл изменить лимиты пула?","1.Внезапные всплески нагрузки\n"+
                                                                         "2. долгие синхронные операции\n"+
                                                                         "3. спецефические паттерны нагрузки\n"+
                                                                         "4. предотвращение deadlock в legacy коде\n"+
                                                                         "5. специфические требования\n"),

                ("781. Как задача попадает в пул?","1. ThreadPool.QueueUserWorkItem()\n"+
                                                   "2. через task.Run()\n"+
                                                   "создается объект Task и задача планируется на выполнение"),

                ("782. Что произойдёт, если задач больше, чем доступных потоков?","Это штатная ситуация. Задачи встают в очередь, если очередь постоянно занята то будут выделены еще потоки\n "),

                ("783.  Как избежать блокировок при избытке задач?","1. Использовать async/await\n"+
                                                                    "2. Явное увеличение потоков\n"+
                                                                    "3. использовать Task.WhenAll\n"+
                                                                    "4. избегать .Result .Wait()\n"),

                ("784. Как отследить загрузку пула?","использовать специальное  API(PrintThreadPoolStats) для получения текущей статистики потоков\n"+
                                                     "встроенные счетчики от microsoft\n"+
                                                     ""),

                ("785. Можно ли принудительно запустить поток в пуле?","нельзя"),

                ("786. Что делает Parallel.For?","это метод для параллельного выполнения циклов\n"+
                                                 "он автоматически распределяет итерации цикла по нескольким потокам используя пул потоков\n"+
                                                 ""),
                ("787. Когда использовать Parallel.ForEach вместо обычного foreach?","использовать параллелизм:\n"+
                                                                                     "1. Когда каждая итерация требует значительных вычислительных ресурсов\n"+
                                                                                     "2. Когда итерации независят друг от друга\n"+
                                                                                     "3. большие объемы данных и параллелизм перекроет накладные расходы\n"),

                ("788. Можно ли остановить Parallel.ForEach досрочно?","1. ParallelLoopState.Stop() немедленная остановка\n"+
                                                                       "2. ParallelLoopState.Break() остановка после чанка\n"+
                                                                       "3. CancellationToken внешнее прерывание\n"),

                ("789. Что делает Parallel.Invoke?","это метод в net который выполняет несколько действии параллельно.\n"+
                                                    "он предназначен для запуска нескольких независимых операций одновременно,\n "+
                                                    "используя возможности многопроцессорной системы\n"),

                ("790. Какие риски при использовании Parallel?","1. Состояние гонки. Несихронизированный доступ к общим данным из нескольких потоков\n"+
                                                                "2. Взаимные блокировки при работе с общими ресурсами\n"+
                                                                "3. Исключения в параллельных операциях агрегируются\n "+
                                                                "4. Избыточно для мелких операций\n"+
                                                                "5. проблемы с порядком выполнения\n"+
                                                                "6. Сложность отладки\n"+
                                                                "7. сложность правильной отработки отмены\n "),

                ("791. Чем Parallel.For отличается от Parallel.ForEach?","1. Parallel.For для числовых диапазонов\n"+
                                                                         "Parallel.ForEach для коллекций\n"+
                                                                         "2. Parallel.For эффективен для массивов\n"+
                                                                         "Parallel.ForEach гибкость для любых коллекций\n"+
                                                                         ""),
                ("792.Как можно задать ограничения по числу параллельных задач?","1. new ParallelOptions свойство MaxDegreeOfParallelism\n"+
                                                                                 "2. using SemarphoreSlims()\n"+
                                                                                 "3. SemarphoreSlims foreach Task.WhenAll\n"+
                                                                                 ""),

                ("793. Как остановить Parallel.ForEach при достижении условия?","1. ParallelLoopState.Stop() немедленная остановка\n"+
                                                                                "2. ParallelLoopState.Break() остановка после текущих итерации\n"+
                                                                                "3. CancellationToken "),

                ("794. В чём разница между Break() и Stop()?","Break() позволяет завершить текущие итерации, а Stop останавливает сразу\n"),

                ("795. Можно ли использовать async внутри Parallel.ForEach?","нет это цикл для синхронных операций\n"),

                ("796. Какие типы таймеров есть в .NET?","System.Timers.Timer работает из пула потоков и потокобезопасный\n"+
                                                         "System.Threading.Timer высокопроизводительный\n"+
                                                         "System.Windows.Forms.Timer и WPF есть свои таймеры\n"+
                                                         "PeriodicTimer современный асинхронный таймер\n"),
                ("797. В чём отличие System.Timers.Timer и System.Threading.Timer?","System.Threading.Timer более простой, нет синхронизации, точность выше, только callback\n"),

                ("798. Как отменить выполнение таймера?","timer.Stop(), timer.Enabled()=false, timer.Dispose(), timer.Change(Timeout.Infinity, Timeout.Infinity), cancellationToken\n"),

                ("799. Как реализовать асинхронный таймер?","using vat timer = new PeriodicTimer(TimeSpan.FromSeconds(1))\n"+
                                                            "Task.Delay()\n"+
                                                            "можно сделать асинхронную обертку System.Timers.Timer\n"),

                ("800. Почему нельзя использовать Thread.Sleep для периодического выполнения?","1. Блокировка потока\n"+
                                                                                                "2. неточность временных интервалов\n"+
                                                                                                "3. не работает с cancellationToken"),

                ("801. Что делает модификатор volatile?","модификатор гарантирует что запись и чтение поля будет выполняться напрямую в/из основной памяти\n"+
                                                         "Это обеспечивает видимость между потоками\n"),

                ("802. В каких случаях volatile нужен?","1. Флаги отмены или завершения\n"+
                                                        "2. Низкоуровневые операции с аппаратным обеспечением\n "+
                                                        "3. Частые чтения\n"),

                ("803. Гарантирует ли volatile атомарность операций?","нет. "),

                ("804. Чем отличается Thread.MemoryBarrier() от volatile?","volatile подход для отдельных полей, а Thread.MemoryBarrier для контроля упорядочивания опреаций в коде\n"),

                ("805. Почему volatile редко используется в .NET?","1. volatile толькоь для простых сценариев\n"+
                                                                   "2. лучше cancellationToken вместо volatile флагов\n"+
                                                                   "3. сложность отладки\n"+
                                                                   "4. Есть более производительные альтеранативы\n"),

                ("806. Что делает Interlocked.Increment(ref x)?","атомарное инкрементирование переменной.\n"+
                                                                 ""),

                ("807.Можно ли использовать Interlocked со ссылочными типами?","для ссылочных типов работает только interLocked.CompareExcgange()"),

                ("808. Когда Interlocked эффективнее, чем lock?","interlocked эффективнее для одной переменной, а lock нескольких переменных и сложных операциях\n"),

                ("809. Как реализовать флаг однократного входа с Interlocked?","private int _flag=0\n"+
                                                                               "public bool TryEnter()\n"+
                                                                               "int originalValue = InterLocked.CompareExchange(ref _flag, 1, 0)\n"+
                                                                               "return originalValue==0\n"),

                ("810. Почему Interlocked безопасен в многопоточном окружении?","1. Аппаратная атомарность на уровне процесcора \n"+
                                                                                "2. InterLocked методы неявно создают полный барьер памяти\n"),

                ("811. Что такое ManualResetEvent и AutoResetEvent?","это примитивы синхронизации в Net, которые позволяют потокам\n"+
                                                                     "взаимодействовать друг с другом через сигналы\n"+
                                                                     "оба работают по принципу светофора зеленый и красный цвет\n"+
                                                                     "ManualResetEvent ручной сброс\n"+
                                                                     ".Set() переводит в сигнальное состояние(зеленый свет)\n"+
                                                                     ".Reset() переводит в несигнальное состояние(красный свет)\n"+
                                                                     ".WaitOne блокирует поток пока событие не перейдет в сигнальное состояние\n"+
                                                                     "AutoResetEvent автоматический сброс\n"+
                                                                     ".Set() разблокирует ровно один поток ожидающий поток и автоматически сбрасывается\n"+
                                                                     ".WaitOne() блокирует поток до получения сигнала\n"),

                ("812. Чем Semaphore отличается от Mutex?","Semaphore и Mutex это примитивы синхронизации но решают разные задачи\n"+
                                                           "Mutex это замок с одним ключом\n"+
                                                           "только один поток может владеть им в любой момент времени\n"+
                                                           "mutex.WaitOne ждем пока замок станет не доступным\n"+
                                                           "mutex.ReleaseMutex() освобождаем замок\n"+
                                                           "Semaphore это турникет который пропускает ограниченное количество людей\n"+
                                                           "semaphore.WaitOne ждем свободного слота\n"+
                                                           "Dowork() делается работа на всех доступных потоках\n"+
                                                           "semaphore.Release() освобождает слот\n"),

                ("813. Когда нужно использовать EventWaitHandle?","EventWaitHandle это универсальный примитив синхронизации,\n"+
                                                                  "1. который следует использовать в конкретных сценариях межпоточного и межпроцессорного взаимодействия\n"+
                                                                  "2. координация множества потоков\n"+
                                                                  "3. ожидание системных событий\n"+
                                                                  "4. реализация паттерна Produces Consumer\n"+
                                                                  "5. Таймауты и ожидания с ограниченным временнем\n"+
                                                                  ".Set() переводит событие в сигнальное состояние\n"+
                                                                  ".Reset переводит в несигнальное состояние\n"+
                                                                  ".WaitOne() ожидание сигнала\n "+
                                                                  ".WaitAll() ожидание всех событий\n"+
                                                                  ".WaitAny() ожидание одного события\n"),

                ("814. В чём минусы ядровых примитивов?","Mutex,Semaphore,EventWaitHandle - ядровые\n"+
                                                         "lock, Monitor, interlocked, spinLock пользовательские"+
                                                        "1. Низкая производительность\n"+
                                                         "2. Переключение контекста\n"+
                                                         "3. Риск взаимоблокировок\n"+
                                                         "4. проблемы с исключениями при вызове исключения мютекс может остаться захваченным\n"+
                                                         "5. Сложность отладки\n"),

                ("815. Какие альтернативы ядровым конструкциям есть в .NET?","1. InterLocked класс\n"+
                                                                             "2. SpinLock\n"+
                                                                             "3. SemaphoreSlim\n"),

                ("816. Что такое Channel в .NET?","высокопроизводительная структура данных для реализации паттерна produces consumer\n "+
                                                  "Channel<T> представляет собой асинхронную  очередь,где\n"+
                                                  "Writter производитель отправляет данные\n"+
                                                  "Reader потребитель получает данные\n"+
                                                  "Channel.CreateUnbounded<string>() создание неограниченного канала\n"+
                                                  "Channel.CreateBouded(new BoudedChannelOptions(1000))\n"+
                                                  ""),
                ("817. Чем Channel отличается от BlockingCollection?","BlockingCollection и Channel<T> решают схожие задачи\n"+
                                                                      "BlockindCollection блокирующий поток, Channel<T> асинхронный\n"+
                                                                      "BlockingCollection для легаси кода, синхронные сценарии, когда блокировка приемлема\n"),

                ("818. Когда стоит использовать Channel?","новые проекты .net Core 3+\n"+
                                                          "асинхронные и высоконагруженные приложения\n"),

                ("819. Поддерживает ли Channel отмену и завершение передачи?","Поддержка отмены через cancellationToken\n"+
                                                                              "метод Writer.Complete\n"+
                                                                              "channel.Reader.Comletion полное завершение работы канала "),

                ("820. Что произойдет, если читать из пустого канала?","readAsync() выполнится только после появления данных. Если writer complete исключение\n"+
                                                                       "TryRead проверка вернет false\n"+
                                                                       "WaitToReadAsync() асинхронное ожидание возможности чтения . При complete возвращает false\n"+
                                                                       "ReadAllAsync асинхронный стрим при comlete завершает цикл\n"),

                ("821. В чём разница между Unbounded и Bounded каналами?","UnboadedChannel<int> неограниченный\n "+
                                                                          "BoudedChannel<int>(1000) максимум 1000 элементов\n"+
                                                                          "действия при переполнение в зависимости от опций. Ожидание, удалить поcледний добавленный, удалить старейший, игнорировать запись \n"),

                ("822. Что делает параметр SingleReader?","SingleReader это параметр оптимизации,который указывает,что канал будет \n "+
                                                          "использоваться только одним читателем(потребителем)\n"+
                                                          ""),

                ("823. Что делает параметр SingleWriter?","это параметр оптимизации, который указывает, что канал будет использоваться только одним писателем\n"),

                ("824. Что произойдёт при переполнении BoundedChannel?","1. Wait ожидание(по умолчанию)\n"+
                                                                        "2. DropNewest(удалить новейший)\n"+
                                                                        "3. DropOldest(удалить старейший)\n"+
                                                                        "4. DropWrite(Игнорировать запись)\n"),

                ("825. Что такое Channel.CreateUnbounded<T>()?","создание безлимитного канала "),

                ("826. Что делает WriteAsync?","это асинхронный метод записи данных в канал\n"+
                                               "его поведение зависит от типа канала и текущего состояния\n"),

                ("827. Чем TryWrite отличается от WriteAsync?","TryWrite синхронный возврашает bool, при переполнении отказ, не работает cancellationToken, при ошибке возвращает false\n"+
                                                                "асинхронный\n"),
                ("828. Что делает ReadAsync?","асинхронный метод чтения данных из канала. Его состояние зависит от состояния канала и наличия данных\n"+
                                              "если канал пуст и не завершен - ожидание\n"+
                                              "когда пуст и завершен исключение\n"),

                ("829. Что делает свойство Completion у ChannelReader?","это свойство, которое возвращает Task,завершающийся\n"+
                                                                        "когда канал полностью завершен и все данные обработаны\n"+
                                                                        "Это механизм для ожидания окончания работы канала\n"),

                ("830. Как безопасно завершить канал?","channel.Writer.Complete();\n"+
                                                       "ReadAllAsync()\n"+
                                                       "WaitToReadAsync + TryRead\n"),

                ("831.Как создать проект MinimalApi","ASP.Net Core Web Api без контроллеров\n"),

                ("832.запуск проекта не браузере","1. установить в json browserLauncher false\n"+
                                                  "2. под json есть файл .http\n"+
                                                  "3. и в этом файле нажать send Request\n"),

                ("833. место запуска(ядро приложения WebApi)","WebApplication.CreateBuilder\n"),

                ("834. создание возврата GetMinimalApi ","app.MapGet(/название, ()=> something)"),

                ("835.основные отличия MinimalApi от приложения с контроллерами c#","1. у MinimalApi более функциональный подход, контроллеры на ООП\n"+
                                                                                    "2. минимальность классов и файлов, контролеры это про разделение на классы и части\n"+
                                                                                    "3. минимум шаблонов, максимум полезного кода, у контроллеров атрибуты\n"+
                                                                                    "4. минимум кода, у контроллеров все расписано\n"+
                                                                                    "5. Внедрение зависисмостей более гибкое, у контроллеров через классы\n"+
                                                                                    "6. Кастомные фильтры, у контроллеров есть встроенные\n"+
                                                                                    "7. Меньше накладных расходов, быстрее запуск, меньше потребления памяти\n"),

                ("836.создание строки подключеняи к базе данных","builder.Services.AddContext<ApplicationDbContext>(\n"+
                                                                 "options=>NpgSqlServer(defaultConnection)\n"),

                ("837. добавить миграции команда ","Add-Migration имя\n"),

                ("838.обновить базу данных ","Update-Database"),

                ("839. асинхронный метод Post Minimal Api","app.MapPost(\"people\", async (Person person, ApplicationDbContext context)=>{" +
                                               " context.Add(people); await SaveChangesAsync();   })"),

                ("840. асинхронный метод GetId Minimal Api","app.MapGet(\"people\"{id:int}, async Task<Results<Ok<Person>,Not Found>>(int id, ApplicationContext context)=>)\n"),

                ("841. метод удаления Minimal Api","ExecuteDeleteAsync"),

                ("842. кеш выводы в builder как написать","builder.Services.AddOutPutCache()\n"+
                                                          "app.UseOutputCache\n"+
                                                          "c=>c.Expire(TimeSpan)"),

                ("843. Обновление кеша minimal api","IoutputCacheStore\n"+
                                                    "await outputcacheStore.EvictByTagAsync(\"people-tag\",default)\n"),

                ("844.Создание миграции через командную строк ","dotnet ef migrations add название\n"),

                ("845. обновление миграции через командную строку","dotnet ef database update\n"),

                ("846. класс для возврата результата minimal Api","статический класс Result\n"+
                                                                  "Result.Ok()-200\n"+
                                                                  "Result.Created() - 201\n"+
                                                                  "Result.BadRequest() - 400\n"+
                                                                  "Result.Unauthorized() - 401\n"+
                                                                  "Result.Forbid() - 403\n"+
                                                                  "Result.NotFound() - 404\n"),

                ("847. метод фильтра авторизации minimal Api","RequireAuthorization()"),

                ("848. безопасность JWT","builder.Services.AddAuthentication(\"Bearer\")\n"+
                                         ".AddJwtBearer(options=>\n"+
                                         "{\n"+
                                         "options.Authority=\"https://your-auth-server\"\n"+
                                         "options.Audience\n"+

                                           "}\n"+
                                           "в точку добавить атрибут [Authorize] между названием и лямбдой\n"),

                ("849.Интеграция OAuth2","builder.Services.AddAuthentication()\n"+
                                         ".AddGoogle(options=>\n"+
                                         "{\n"+
                                         "options.ClientId= \"your-client-id\"\n"+
                                         "options.ClientSecret=\"your-client-secret\\n"+
                                         "})\n"),

                ("850.Распределение ролей [Autorize]","builder.Services.AddAuthorization(options=>{\n"+
                                                      "options.AddPolicy(\"AdminOnly\",policy=>policy.RequireClaim(\"role\",\"admin\")})"+
                                                      "app.MapGet(\"admin\",[Authorize(Policy=\"AdminOnly\")] ()=> \"Admin Content\")"),

                ("851.Получение Ip в Minimal Api","app.Use(async(content, next)=>{\n"+
                                                  "var ip = context.Connection.RemoteIpAddress\n"+
                                                  "ip.ToString() == 123.456.789.0\n"),

                ("852.Кеширование Minimal Api","builder.Services.AddResponceCaching\n"+
                                               "app.ResponceCaching()\n"+
                                               "app.MapGet().CacheOutPut()\n"),

                ("853. Redis для распределенного кеширования ","builder.Services.AddStackExchangeRedisCache(options=>{\n"+
                                                               "options.Configuration=\n"+
                                                               "options.InstanceName=\n"),

                ("854. надежный способ масштабирования Kubernetes","1.Контейнеризация свой Minimal Api с помощью Docker\n"+
                                                                   "2. Развернуть образ Docker в кластере Kubernetes\n "+
                                                                   "3. настройка правил автоматического масштабирования с помощью Horizontal Pod Autoscaler\n"),

                ("855. Загрузка(прием) файлов Minimal Api","app.MapPost(\"\\/upload\", async(IFormFile file) \n"+
                                                     "var filePath = Path.Combine(\"Uploads\",file.FileName)\n"+
                                                     "using (var stream = new FileStream(filePath, FileMode.Create))\n"+
                                                     "{ await file.CopyToAsync(stream)}"),

                ("856. Отправка файлов Minimal Api ","app.MapGet(string fileNmae\n"+
                                                     "var fileBytes = File.ReadAllBytes(filePath)\n"+
                                                     "return Results.File(fileBytes, \"\", fileName)"),

                ("857. Практики по эффективной и безопасной обработки файлов\n ","1. Ограничение размеров файла\n"+
                                                                                 "2. Проверка типа файла\n"+
                                                                                 "3. Безопасное хранение файла\n"+
                                                                                 "4. Потоковая предача для больших файлов\n"),

                ("858. Передача в параметр метода Map объекта","атрибут [AsParameters]"),

                ("859. Альтернатива Swagger","Scalar\n"),

                ("860. Практика именования Rest Api","1. Get/products множество\n"+
                                                     "Get/products{product_id} один продукт с определенныи идентификатором\n"+
                                                     "2. не использовать лишние сегменты. сокращенный путь /v3/api/{listing_id}\n"+
                                                     "3. Всегда добавляйте название типа для массива\n"+
                                                     "4. Возвращайте массивы объектов вместо объектов по очереди\n"+
                                                     "5. Возвращать идентификаторы объекта как строку, если там даже число\n"+
                                                     "6. Не использовть ошибку 404 если обьект не найден или дополнительно указывать что именно поиск прошел не успешно\n"+
                                                     "7. Реализация идемпотентных механизмов\n"+
                                                     "8. использовать iso8601 для даты\n"+
                                                     "9. "),

                ("861. Api аббревиатура","Application programming interface\n"),

                ("862. Моковый сервер","временный прототип будущего сервера, который точно реализует контракт или его часть\n"),

                ("863.Эндпоинт","Эндпоинт - это URL-адрес, который принимает HTTP-запросы, выполняет определенную логику и возвращает ответ."),

                ("864.Рекомендации проектирования для Rest Api","1. если из эндпоинта нужно вернуть данные то их лучше обернутьб в объект\n"+
                                                                "2. Встраиваемые в объект данные также лучше хранить в объекте\n"+
                                                                "3. Уделять больше внимания ошибкам. Коды ошибок (не http) явно указывать в описании\n"+
                                                                "4. Не выносить схемы эквивалент базы данных, делать новые схемы\n"+
                                                                "5. Минимизация вложенности в URL\n"+
                                                                "6. Для сериализации массива  используете style: form и explode\n"+
                                                                "7. Для индефикаторов используете UUID\n"+
                                                                "8. не передавать в строке запроса персональные данные\n"+
                                                                "9. Определитсься с форматом даты и времени\n"+
                                                                "10. версионируйте Api и сразу используете префикс /api/v1\n"+
                                                                "11. Минимазации JSON за счет форматирвоания\n"+
                                                                "12. Заполнение примеров полей в спецификации\n"+
                                                                "13. название конечной точки существительное\n"+
                                                                "14. Документирование"),

                ("865. что такое Rest","Representational State Transfer и представляет собой архитектурный стиль, основанный на HHTP протоколе\n"),

                ("866. RESTful API ","это API разработанный согласно правилам REST\n"),

                ("867. 2 основных принципа REST","1. Разделение на клиента и сервер\n"+
                                                 "2. Единный протокол HTTP\n"),

                ("868. 4 доп принципа REST","1. Сервер не хранит ни какой информации о прошлых запросах\n"+
                                            "2. Многоуровневая система\n"+
                                            "3. Кэшируемость\n"+
                                            "4. Код по запросу\n"),

                ("867.что такое URI ","унифицированный идентификатор ресурса\n"+
                                      "обращение к ресурсу адресация"),

                ("868. CRUD","Create, Read, Update, Delete основные действия с базой данных выполняемые через REST API\n"),

                ("869.что такое полезная работа HTTP","данные ресурсы запрошены пользователем"),

                ("870. основные компоненты HTTP запроса","1. Метод запроса\n"+
                                                         "2. URI\n"+
                                                         "3. версия HTTP\n"+
                                                         "4. заголовок HTTP запроса\n"+
                                                         "5. Тело HTTP запроса\n"),

                ("871. Основные части ответа HTTP","1.Используемая версия HTTP\n"+
                                                   "2. строка состояния со статусом запроса или кода состояния HTTP- ответа\n"+
                                                   "3. Заголовок HTTP ответа с метаданными об ответе\n"+
                                                   "4. тело HTTP ответа с данными о запрошенном ресурсе\n"),

                ("872. успешные ответы HTTP","200 OK- запрос выполнен успешно\n"+
                                             "201 Created - Запрос успешно прошел и был создан\n"+
                                             "202 Accepted Этот статус означает что сревер принял запрос клиента, не завершил. Возможно асинхронно"),

                ("873. ответы перенаправления HTTP ","301 Moved ресурс был на постонно перемещен\n"+
                                                     "302 Found . ресурс был временно премещен\n "+
                                                     "303. "),

                ("874. неуспешные ответы HTTP","400. Bad Request ошибка запроса\n"+
                                               "401. Unauthorized ошибка авторизации\n"+
                                               "403. Forbidden клиент аутентифицирован но не авторизорован\n"+
                                               "404 Not Found сервер не смог найти запрашиваемый ресурс"),

                ("875. ошибки сервера 5**","500 Interval Server Error неприведенная проблема с сервером\n"+
                                           "502 Bad Gateway  некорректного ответа от вышестоящего сервера\n"+
                                           "503 Service Unavalibale какие то временные помехи\n"),

                ("876. GrapQl","язык запросов который позволяети клиентам запрашивать только те данные им нужны"),

                ("877. разница между Rest и SOAP","1. SOAP это строгий протокол для построения безопасных API, REST это архитектурный стиль\n"+
                                                  "2. SOAP более безопасный и не имеет кеширования\n"+
                                                  "3. SOAP только XML формат"),

                ("878. разница между AJAX и REST","AJAX это асинхронный JS. У него свой формат для отправки сообщений XMLHttpRequest вместо Http  "),

                ("879. Contract First и Code First","Contract First это сначала документация как должны взаимодействовать Api с клиентами\n"+
                                                    "Code First сначала функциоанальность API потом спецификация\n"),

                ("880. Фильтры действия ASP.Net","Action Filters это атрибуты, которые могут быть применены к методам действия контроллеров\n"+
                                                 "для выполнения предварительной или последующей обработки для этих методов\n "),

                ("881. Какие бывают фильтры действий ASP.Net ","1. Фильтры авторизации(Authorization Filter)\n"+
                                                               "2. Фильтры ресурсов(Resourse Filter)\n"+
                                                               "3. Фильтры действий(Action Result)\n"+
                                                               "4. Фильтры результатов(Result Filter)\n"+
                                                               "5. Фильтры исключений(exception Filter)\n"),

                ("882.Фильтр авторизации ASP.NET CORE","обычно используются для реализации предостовления доступа к определенным частям приложения только авторизированным или аутентифицированным пользователям"),

                ("883. Фильтр ресурсов ASP net","это фильтр действий который позволяет выполнять действия, влияющие на весть HTTP запрос\n "+
                                                "может изменять заголовки ответа или обрабатывать исключения\n"),

                ("884. Фильтр действий ASp NEt","это атрибуты позволяющие добавлять логику до и после выполения отдельных методов в контроллере"),

                ("885. Фильтр результатов ASp NEt","это тип фильтров действий которые выполняют код после выполнения метода действий,\n"+
                                                   "но до обработки и отправки ее клиенту\n"),

                ("886. Фильтр исключений в Asp.Net","это разновидность фильтров действий, специально разработанных для обработки исключений\n"+
                                                    "возникающих во время выполнения метода контроллера\n"),

                ("887.аббревиатура DDD ","предметно ориентированное проектирование Domain Driven Design"),

                ("888.Основные преимущества DDD","1. Единный язык с бизнесом\n"+
                                                  "2. Четкие границы микросервисов\n"+
                                                  "3. Простая внутренняя структура\n"+
                                                  "4. легкость понимания неподготовленным разработчиком\n"+
                                                  "5. "),

                ("889. аббревиатура CQRS","Command and Query Resposibility Segregation"),

                ("890. что такое CQRS","подход проектирования программного обеспечения при котором код,\n"+
                                       "изменяющий состояние, отделяется от кода просто читающего\n"),

                ("891. какие объекты бывают по CQS  ","1. Queries: Методы возвращают результат, не изменяя состояние объекта\n"+
                                                      "2. Commands: Методы изменяют состояние объекта не возвращая значение\n"),

                ("892. достоинства CQRS"," Меньше зависимостей в каждом классе\n"+
                                         "соблюдается принцип единственной отвественности\n"+
                                         "легко тестируется и расширяется\n"),

                ("893. Три вида паттернов CQRS","1. Regular Базовый\\Логический \n"+
                                                "2. Progressive Прогрессивный \\ с отдельными представлениями \n"+
                                                "3. Deluxe Элитный \\Полное разделение\n"),


                ("894. паттерны микросервисов DbC","Design by contract. Контрактное программирование\n"+
                                                   "1. Предусловия что должно выполняться до выполнения функции\n"+
                                                   "2. Инварианты то что должна функция обеспечить. Её основной посыл\n"+
                                                   "3. Постусловия то что придет и как это можно обработать или запросить что то еще\n"),

                ("895. LC/HC паттерны GRASP","Low coupling система не должна зависеть от большого количества сервисов\n"+
                                              "High cohesion ясна фокусировка функции определены и управляемы\n"),

                ("896. Circuit Breaker","паттерн интеграции между сервисами с гарантией ответа на запрос\n  "),

                ("897. три состояния Circut Breaker","открытое, закрытое, полуоткрытое\n"),

                ("898. Sidecar","паттерн интеграции между приложением и сервисом, развернутый на стороне приложения\n"),

                ("899. Ambassador","паттерн интеграции между приложением и сервисом, развернутый на стороне приложения\n"+
                                   "Частный случай Sidecar\n"),

                ("900. Anti-Corruption Layer","реализует фасад или адаптер между двумя подсистемами\n"+
                                              "Предполагает устранение зависимости дизайна приложения от внешних подсистем\n"+
                                              "Решает проблемы перехода на новый стек или взаимодействие с легаси кодом"),

                ("901. Async Request-Reply","паттерн интеграции для длительной обработки данных и больших объемов\n"),

                ("902. Backends For Frontends","паттерн интеграции между бэком и фронтом для разных платформ. Разделение бека на каждого фронтендера\n "),

                ("903. Cache-Aside","паттерн интеграции сервиса в базу данных на основе кеша для увелечения производительности\n"),

                ("904. Gateway","паттерн интеграции между клиентским приложением  и большим количеством сервисов\n"),

                ("905. Gateway Aggregation","паттерн интеграции между клиентским приложением и большим количеством сервисов\n"),

                ("906. GateWay Routing","паттерн интеграции между клиентским приложением и большим количеством сервисов\n"),

                ("907. Query-based Load Leveling","паттерн интеграции между приложениями на основе очередей с целью балансировки нагрузки\n"),

                ("908. 26 паттернов микросервисной разработки\n","1. Разбиение по возможностям бизнеса\n"+
                                                                 "2. Разбиение по поддоменам\n"+
                                                                 "3. Душитель\n"+
                                                                 "4. Уровень защиты от повреждений\n"+
                                                                 "5. База данных на сервис\n"+
                                                                 "6. Api композиция\n"+
                                                                 "7. Разделение команд и запросов\n"+
                                                                 "8. Поиск событий\n"+
                                                                 "9. Сага\n"+
                                                                 "10. Api шлюз\n"+
                                                                 "11. Бекенды для фронтендов\n"+
                                                                 "12. Сборка пользовательского интерфейса на стороне клиента\n"+
                                                                 "13. Сборка фрагментов страниц на стороне сервера\n"+
                                                                 "14. Обнаружение сервисов на стороне клиента\n"+
                                                                 "15. Обнаружение сервисов на стороне сервера\n"+
                                                                 "16. Экземпляр сервиса на хост\n"+
                                                                 "17. Сине-зеленое развертывание\n"+
                                                                 "18. Автоматический выключатель\n"+
                                                                 "19. Переборка\n"+
                                                                 "20. Агрегация логов\n"+
                                                                 "21. Распределенная трассировка\n"+
                                                                 "22. Проверки здоровья\n"+
                                                                 "23. Посредник\n"+
                                                                 "24. Коляска\n"+
                                                                 "25. Тестирование контрактов ориентированных на потребителя\n"+
                                                                 "26. Внешнняя конфигурация\n"),

                ("909. Что такое ProtoBuf","бинарный формат данных где хранятся значения\n "),

                ("910. gRPC ","это современный фреймворк для удаленного вызова процедур RPC\n"+
                              "работает на HTTP/2.0 и протокол ProtoBuf\n"+
                              "кросс платформенный и языконезависимый\n "+
                              "встроеные механизмы аутентификация, шифрование, контроль времени выполнения"),

                ("911. 4 основных паттерна gRPC","1.Унарный RPC\n"+
                                                   "     аналогичен запросу HTTP один запрос один ответ\n"+
                                                  "2. Серверный потоковый RPC\n    Клиент отправляет один запрос а сервер возвращает поток из нескольких сообщений\n "+
                                                  "3. Клиентский потоковый RPC\n    Клиент отправляет серверу поток данных а получает один aggragate ответ\n"+
                                                  "4. Двунаправленный потоковый RPC\n    Оба участника обмениваются потоками данных независимо друг от друга\n "),

                ("912. GraphQL","это язык запросов разработанный Facebook.\n Позволяет клиенту запрашивать именно те данные, которые нужны ему с сервера  "),

                ("913. Отличие Rest от gRPC","1. Протокол и производительность\n"+
                                             " REST работает поверх HTTP 1.1 текстовый формат(JSON/XML) большой размер данных медленнне парсится\n"+
                                             "gRPC работает поверх HTTP 2.0 бинарный формат(Protocol Buffers) малый размер, очень быстрая сериализация\\десериализация. Выигрыш в скорости и эффективности\n "+
                                             "2. Контракт и типизация\n"+
                                             "   REST: Контракт(формат\\запрос) часто описан неформально(Swagger\\OpenApi). Слабая типизация\n  "+
                                             "   gRPC: Строгий, обязательный контракт в proto-файле. Код генерируется автоматически. Строгая типизация на уровне архитектуры\n"+
                                             "3. Паттерны взаимодействия\n"+
                                             "   REST: Только-запрос ответ(Request-Responce). Стриминг очень сложен\n"+
                                             "   gRPC: 4 модели: Запрос-Ответ, Серверный стриминг, Клиентский стриминг, двусторонний стриминг. Идеален для real-time данных\n"+
                                             "4. Поддержка браузера\n"+"" +
                                             "   REST: Полная нативная поддержка. Основа веба\n"+
                                             "   gRPC: Ограниченная поддержка. Требует использования прокси(gRPC-Web) для работы в браузере"),

                ("914. что это RabbitMQ","это программный брокер сообщений с открытым исходным кодом,\n который реализует протокол AMQP(Advanced Message Queuing Protocol)\n "+
                                         "Это посредник(middleware), который принимает, хранит и пересылает сообщения между приложениями,\n обеспечивая их надежную асинхронную коммуникацию\n "+
                                          "1. Отправитель(Producer) отправляет ненапрямую получателю, а в RabbitMQ \n "+
                                          "2. RabbitMQ принимает сообщения, сохраняет его в очереди(queue) и ждет\n "+
                                          "3. Получатель(Consumer) забирает сообщения из очереди и обрабатывает его,\n когда будет готов"),

                ("915. 2 архитектуры брокеров сообщений","1. Push архитектура. если у сервера(брокера) есть сообщения для получателя(consumer)\n, то он по своей инциативе отправляет сообщение получателю\n"+
                                                         "2. Pull архитектура. Клиент(Consumer) по своей инциативе запрашивает у сервера(брокера)\n, и если у брокера есть сообщения для клиента, то отправляет эти сообщения\n "),

                ("916. Saga","Сага это последовательность локальных транзакций в распределенных системах\n, где каждая следующая транзакция запускается только после успешного завершенного предыдущей\n"+
                             "Если одна из транзакций fails,\n сага запускает компенсирующие операции(компенсации) для отката изменений предыдуших шагов\n"),

                ("917. 2 способа координации Saga","1. Хореография(Choreography)\n"+
                                                   "Децентрализиванное управление. Каждая служба самостоятельно прослушивает события от других и решает,\n выполнить ли ей следущий шаг или компенсацию. \n Обмен сообытиям через брокер сообщений(RabbitMQ)\n"+
                                                   "2. Оркестрация(Orchestration)\n"+
                                                   "Централизированное управление. Единственный координатор(оркестратор) управляет всем процессом:\n"+
                                                   "он говорит службам, какую транзакцию выполнить и решает что делать в случае успеха или fail.\n Оркестратор вызывает службы напрямую(напhимер через HTTP ) и хранит состояние сети\n"),

                ("918. Чем MapGet(\"/path\", ...) отличается от MVC-экшена по жизненному циклу?","Главное отличие в том, что экшен MVC контроллера проходит полный MVC pipeline(including Model Building, Validation, Action Filters)\n"+
                                                                                                 "в то время как эндпоинт минимальных API(MapGet) обрабатывается непосредственно эндпоинтами middleware,\n что делает его жизненный цикл короче и эффективнее\n"+
                                                                                                 ""),
                ("919. Что такое эндпоинт","это адрес или URL точка в веб приложении, которая принимает запросы и возвращает responces\n"+
                                           "Проще говоря, это конкретный маршрут(путь), по которому клиент( браузер, мобильное приложение) может обратиться к серверу для выполнения определенной операций\n"),

                ("920.Что такое IResult и зачем он нужен?","IResult это интерфейс в ASP.Net CORE, представляющий результат выполения HTTP запроса\n. Альтернатива IActionResult из MVC\n "),

                ("921. Как происходит привязка параметров в обработчике MapPost?","Это автоматический процесс, который извлекает данные из различных частей HTTP запроса(тело,путь,query-строка,заголовки)\n и преобразует их в аргументы вашей функции обработчика\n Проще говоря нужно обьявить параметры в методе,\n а фреймворк сам понимает откуда их взять"),

                ("922. Как добавить констрейнты в шаблон маршрута?","Констрейнты в шаблонах маршрутов ASP.Net Core это правила,\n которые ограничивают значения параметров в URL\n"+
                                                                    "Они позволяют точно контролировать,\n какие запросы должны соответствовать вашему эндпоинту\n"+
                                                                    "Базовый синтаксис: {parameter:constraint}\n Для нескольких констрейнтов{parameter:constraint1:constraint2}\n"),

                ("923. Как вернуть поток/файл из Minimal API?","есть  методы встроенные прямо в Results и TypedResults\n"+
                                                               "1. Results.File() вернуть файл с диска\n"+
                                                               "2. Results.Stream(stream, путь) - вернуть поток из памяти\n"+
                                                               "3. Result.Stream(async(stream)=>логика) - вернуть поток с ручным управлением\n"+
                                                               "4. Results.File(массив байтов) - вернуть массив байтов\n"),

                ("924. Как внедрить сервис в делегат обработчика Api?","Достаточно обьявить параметры в методе-обработчике,\n а ASP.Net Core автоматически разрешит их из Dependency injection(DI) контейнера\n"+
                                                                       "1. автоматическое внедрение сервисов\n"+
                                                                       "builder.Services.AddScoped<IUserService, UserService>()\n"+
                                                                       "app.MapGet(\"/users/{id}\",(int id, IUserService userService))\n"+
                                                                       "2. Внедрение нескольких сервисов через запятую\n"+
                                                                       "3. Внедрение в асихронные обработчики: async(IUserService userService)\n"+
                                                                       "4. Явное указание [FromRoute] IUserService"),

                ("925. Какие подходы к валидации моделей доступны в Minimal API?","В Minimal Api нет встроенной автоматической валидацией как MVC\n"+
                                                                                  "но доступна ручная проверка или полноценные решения с FluentValidation\n"+
                                                                                  "RuleFor(x=>x.Name) создаем в конструкторе\n"+
                                                                                  "в методе вызываем проверку validation.ValidateAsync(user).\n IsValid свойство возврашает bool"),

                ("926. Что такое Endpoint Filters и чем они отличаются от Action Filters?","Это механизмы для перехвата и обработки запросов на разных этапах жизненого цикла в ASP.NET Core\n но они работают в разных контекстах и  имеют важные различия\n"+
                                                                                           "EndPoint Filters, которые работают в контексте EndPoint Middleware и предназначены для обработки запросов  к эндпоинтам\n"+
                                                                                           "Action Filters это часть MVC pipeline  и работают исключительно в контексте MVC контроллеров\n"),

                ("927. EndPoint Middleware","это ключевой компонент в конвейере обработки запроса ASP.NET Core,\n"+
                                            "который отвечает за выполнение конечной точки(endpoint), найденной на этапе маршрутизации\n"),

                ("928. MVC pipeline(конвейер обработки MVC )","это упорядоченная последовательность компонентов в ASP.NET Core\n которая обрабатывает HTTP запрос, предназначенный для MVC контроллера"),


                ("929. Как реализовать версионирование Minimal API?","1. добавление версии в  URL пути \"api/v1/users\"\n"+
                                                                     "2. Передается как параметр context.Request.Query[\"api-version\"]\n"+
                                                                     ""),

                ("930.Как включить авторизацию на уровне эндпоинта/группы?"," делается с помощью метода .RequireAuthorization()\n"+
                                                                            "app.MapGet().RequireAuthorization()"),

                ("931. Какие пакеты нужны для Swagger?","Swachbackle.AspNetCore и Microsoft.AspNetCore.openApi\n"+
                                                        "builder.Service.AddEndPointsApiExploler()\n"+
                                                        "builder.Service.AddSwaggerGen()\n"),

                ("932.  Как включить UI только в Development?","стандартный подход с проверкой Environment\n"+
                                                               "if(app.Environment.IsDevelopment()){app.Swagger(), app.SwaggerUI() }"),

                ("933. DTO ","Data Transfer Object - это объект который предназначен для передачи данных между подсистемами приложения\n Его основная цель передать данные через сеть или между слоями приложения\n"),

                ("934. Как описывать схемы DTO без атрибутов?","/// <summary>\r\n    /// User's age in years\r\n    /// </summary>\r\n    /// <example>30</example>"),

                ("935. Где задаются Title/Version/Description спецификации?","Задаются в методе AddSwaggerGen() при настройке сервисов\n"+
                                                                             "build.Services.AddSwaggerGen(options=>options.SwaggerDoc)\n"),

                ("936.Как документировать Minimal API эндпоинты? ","Документирование Minimal Api эндпоинтов делается с помощью методов расширения\n"+
                                                                   "app.MapGet(\"/user/{id}\").WithName(\"GetUser\")"),

                ("937. Как описать Bearer/JWT схему безопасности?","Описание Bearer/JWT делается через настройку AddSwaggerGen()\n"+
                                                                   "builder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)\n"+
                                                                   ".AddJwtBearer(options=>)\n"),

                ("938. Как разделить спецификации по версиям API?","builder.Services.AddSwaggerGen(options=>)\n{\n"+
                                                                   "options.SwaggerDoc(\"v1\", new OpenApiInfo\n{\n"+
                                                                   "Title=\"My Api\"\n"+
                                                                   "Version = \"v1\"\n"+
                                                                   "Description = \"Initial version of the Api\"})"),

                ("939. Для чего используются OperationFilter и DocumentFilter?","OperationFilter и DocumentFilter это мощные механизмы для кастомной настройки\n"+
                                                                                "и расширения Swagger/OpenApi документации ASP.NET Core. Но служат разным целям\n"+
                                                                                "OperationFilter используется для модификации отдельных операций(endpoints) в Swagger документации()\n (отдельные операции, локальная, модификация параметров)\n"+
                                                                                "DocumentFilter используется для модификации всей Swagger документации целиком\n(вся документация, один раз для документа, глобальная, серверы)\n"+
                                                                                ""),


                ("940. Как скрыть эндпоинт из Swagger?","аттрибут [ApiExplorerSettings(IgnoreApi=true)]\n"+
                                                        ".ExcludeFromDescription() для Minimal Api\n"+
                                                        "DocumentFilter для глобальных правил\n"+
                                                        "OperationFilter для точечного сткытия"),

                ("941. Как отдавать OpenAPI JSON на проде без UI?","builder.Service.AddSwaggerGen(options=>{\n"+
                                                                   "options.SwaggerDoc(\"v1 \",new OpenApiInfo{Title = \"My Api\",Version=\"v1\"})\n"+
                                                                   "app.UseSwagger оставляем, app.UseSwaggerUI закоментируем\n"),

                ("942. Чем PUT отличается от PATCH?","это оба HTTP метода для обновления ресурсов, но они имеют фундаментальные различия в семантике\n"+
                                                     "Put заменяет целиком\n"+
                                                     "Patch применяет частичные изменения к ресурсу\n"),

                ("943. Когда возвращать 201 Created и что добавить в ответ?","код состояния возвращается в ответ на успешный запрос,\n который привел к созданию нового ресурса на сервере\n"+
                                                                             "1. (обязательно) Заголовок(Location) содержит URL адрес только что созданного ресурса\n"+
                                                                             "2. (рекомендуется) Тело ответа() содержит представление созданного ресурса\n"+
                                                                             "3. (обязательно) сам код статуса в строке ответа\n"),

                ("944.Что такое идемпотентность методов?","Идемпотентность это свойстов операции, при котором многократное выполнение одной и той же операции\n приводит к одному и тому же результату\n"),

                ("945. Как различать 400, 404, 409 и 422?","400 общая ошибка валидации, синтаксиса\n"+
                                                           "404 ресурс не найден\n"+
                                                           "409 Конфликт версий, оптимистическая блокировка\n "+
                                                           "422 Семантическая ошибка в данных\n"),

                ("946. Как оформлять ошибки по единому контракту?","Единый контракт ошибок - это стандартизированный формат возврата ошибок от API\n"+
                                                                   "который обеспечивает согласованность и удобство обработки на клиентской стороне\n"+
                                                                   "1. Создание класса ошибки\n"+
                                                                   "2.Middleware для обработки исключений\n"),

                ("947. Какие схемы пагинации вы знаете и их плюсы/минусы?","1. Offset/Limit\n"+
                                                                           "Простая реализация, универсальная поддержка всеми БД,\n низкая производительность, возможна потеря данных при изменении данных во время пагинации"+
                                                                           "2. KeySet(Cursor) пагинация\n"+
                                                                           "Высокая производительность, Стабильность\n, нет прямой навигации, не показывает общее количество страниц\n"+
                                                                           "3. Seek пагинация(улучшенный Keyset)\n"+
                                                                           "самая высокая производительность, составная сортировка, стабильность\n"+
                                                                           "сложная реализация, требует уникального ключа для сортировки, сложный Api для клиентов\n"+
                                                                           "4. PageToken пагинация\n"+
                                                                           "Гибкость, производительность, скрывает детали от реализации\n "+
                                                                           "сложная реализация и нет прямой навигации\n"),

                ("948.Как проектировать фильтры и сортировки безопасно?","безопасное проектирование фильтров и сортировок - это критически важно\n для защиты от SQL - инъекций и обеспечение производительности\n "+
                                                                         "1. Использовать белые списки разрешенных полей и операторов\n"+
                                                                         "2. Валидировать все входные данные\n"+
                                                                         "3. Использовать параметризированные запросы\n"+
                                                                         "4. Ограничивать сложность запросов\n"+
                                                                         "5. Логируйте подозрительную активность\n"+
                                                                         "6. Обновлять белые списки при изменении модели данных\n"+
                                                                         "7. Тестируйте на уязвимости регулярно\n"),

                ("949.  Как кэшировать ответы с помощью HTTP?","это мощный механизм повышения производительности и снижения нагрузки на сервер\n"+
                                                               "1. Базовое кэширование с ResponceCacheAttribute\n [ResponseCache(Duration=60, Location=ResponseCacheLocation.Any)]"+
                                                               "2. "),

                ("950.Как версионировать REST API","1. Версионирование через URL\n"+
                                                   "services.AddVersioning(options=>\n{\n"+
                                                   "options.DefaultApiVersion = new ApiVersion(1,0);\n"),

                ("951.  Как сделать создание по POST идемпотентным?","1. Использование idempotency-Key\n"+
                                                                     "2. реализация с помощью Redis\n"+
                                                                     "3. Middleware для автоматической обработки\n"+
                                                                     "4. Аттрибут для контроллеров\n"+
                                                                     "5. "),

                ("952. Перечислите типы фильтров в MVC.","1. Фильтры авторизации(Authorization Filters) IAuthorizationFilter\n"+
                                                         "2. Фильтры ресурсов(Resource Filters) IResourceFilter\n"+
                                                         "3. Фильтры действия(Action Filters) IActionFilters\n"+
                                                         "4. Фильтры исключений(Exception Filters)\n"+
                                                         "5. Фильтры результатов (Results Filters)\n"+
                                                         "6. "),

                ("953. Каков порядок выполнения фильтров?","1. Authorization Filters(фильтры авторизации)\n"+
                                                           "2. Resource Filters часть до\n"+
                                                           "3. Action Filters часть до\n"+
                                                           "4. Выполнение метода действия(Action Method)\n"+
                                                           "5. Action Filters часть после\n"+
                                                           "6. Exception Filters (только если бы исключение)\n"+
                                                           "7. Result Filters часть до\n"+
                                                           "8. Выполнение результата (Result Execution)\n"+
                                                           "9. Result Filters (часть после)\n"+
                                                           "10. Resource Filters (часть после)\n"),

                ("954.Как внедрить зависимости в фильтр ASP NET? ","1. через конструктор(ServiceFilter) private IMyService service\n service.AddScoped<IMyService, MyService>()\n service.AddScoped<MyFilter>()\n[ServiceFilter(typeof(MyFilter))]\n"+
                                                                   "2. TypeFilter [TypeFilter(typeof(MyFilter))]\n"),

                ("955. Разница между глобальным, на контроллер и на действие?","1. Глобальный:\n   Применяются ко всем контроллерам и действиям\n   Выполняются для каждого запроса\n   Регистрируются глобально в конфигурации\n"+
                                                                               "2. Фильтры на контроллер:\n  Применяются ко всем действиям на контроллера\n  не влияют на другие контроллеры\n   можно комбинировать с фильтрами действий\n "+
                                                                               "3. Фильтры на действие:\n   Применяются только к конкретному действию\n   Наиболее точечное применение\n   Можно навешивать несколько фильтров\n"),

                ("956. Как подходите к тестированию фильтров?","1. Фильтр с зависимостью\n"+
                                                               "2. Unit тестирование\n"+
                                                               "3. Тестирование с HttpContext\n"+
                                                               "4. Тестирование с ServiceProvider\n"+
                                                               "5. Интеграционное тестирование\n"),

                ("957. Когда использовать middleware вместо фильтра?","1. Обработка на уровне всего приложения\n2.Работа с сырым HTTP-запросом/ответом до маршрутизации\n 3.Обработка статических файлов или ошибок на низком уровне\n "),

                ("958. Когда использовать Action/Exception фильтр?","IActionFilter\n два метода для обработки логики до и после\n 1. Логирование запросов и ответов\n "+
                                                                    "2. Валидация моделей и параметров\n"+
                                                                    "3. Измерение времени выполнения действия\n"+
                                                                    "4. Кеширование результатов\n"+
                                                                    "5. Модификация входных\\выходных данных\n"+
                                                                    "6. Проверка прав доступа к конкретному действию\n"+
                                                                    "Exception Filter(IExceptionFilter)\n для обработки исключений в рамках MVC конвейера\n"+
                                                                    "1. Глобальная обработка исключений MVC\n"+
                                                                    "2. Преобразование исключений в HTTP ответы\n"+
                                                                    "3. Логирование ошибок с контекстом MVC\n"+
                                                                    "4. Кастомные HTTP ответы для разных типов ошибок\n"+
                                                                    "5. Обработка специфичных для бизнес логики исключений\n"),


                ("959. Когда уместны Endpoint Filters?","IEndPointFilter для Minimal Api и endpoint-based приложениях\n"+
                                                        "1. Когда нужна производительность\n"+
                                                        "2. Для кастомной обработки pipeline\n"+
                                                        "3. Когда нужна композиция фильтров\n"+
                                                        "4. Для работы с результами end поинтов\n"),

                ("960. Что такое pipeline","это цепочка middleware компонентов через которые проходит HTTP запрос и ответ\n Каждый компонент может обработать запрос и передать его следующему\n"),

                ("961. Как централизованно обрабатывать исключения?","1. Middleware для обработки исключений\n"+
                                                                     "2. UseExceptionHandler с контроллером\n"+
                                                                     "3. Глобальный Exception Filter\n"+
                                                                     "4. Интеграция с логгированием\n"+
                                                                     " "),

                ("962. Как навесить политику авторизации на группу Minimal API?","1. Создание политики авторизации\n"+
                                                                                 "builder.Services.AddAuthorizition(options=>{\n"+
                                                                                 "options.AddPolicy(\"AdminOnly\", policy=>policy.RequireRole(\"Admin\"))\n"+
                                                                                 "2. Навешивание политики на группу endpoints\n app.MapGroup(\"admin\").RequireAuthorization(\"AdminOnly\")"),

                ("963. Повсеместный\\единый язык ","1. Ubiquitous Language - это единый, структуированный язык, общий для всех участников проекта:\n"+
                                                   "   разработчиков, экспертов предметной области(domain experts),аналитиков, тестировщиков\n"+
                                                   "   Основные принципы: Совместная разработка, Живой документ, Точность\n"+""
                                                   ),

                ("964. Ограниченный контекст","Bounded Context\n"+
                                              "  Это четкая граница внутри которой определенная модель и ее единый язык имеют точное и единое значение\n"+
                                              "  Это способ борьбы со сложностью большой предметной области путем ее разделения на более мелкие независимые части\n"+
                                              "  Ключевые принципы: Граница, Своя модель и свой язык, \n"),

                ("965. Как связаны Ubiquitous Language и Bounded Context?","Bounded Context определяет границы действия Ubiquitous Language\n"+
                                                                           "Bounded Context это четкая граница, внутри которой конкретный Ubiquitous Language\n"+
                                                                           "является точным, непротиворечивым и единственно верным\n"+
                                                                           "Ubiquitous Language обеспечивает целосность и ясность модели внутри границ Bounded Context\n"+
                                                                           ""),
                ("966. Чем Bounded Context отличается от модуля или сервиса?","Bounded Context это логическая концепция из области проектирования,\n"+
                                                                              " в то время как Модуль и Сервис это физические способы организации кода\n"),

                ("967. Как определить границы контекста на практике?","1. Понимание предметной области и формирование UL(поиск сущностей, событий, процессов)\n"+
                                                                      "2. Ищите точки напряжения в языке. Границы часто проходят там, где язык ломается\n"+
                                                                      "3. Анализ функциональных и нефункциональных требований\n"+
                                                                      "4. Черновая наброска карты контекстов\n"+
                                                                      "5. Проверка на запахи(smells) и итеративная корректировка\n"),

                ("968. Что такое Domain Model в DDD?","Модель предметной области это цифровая копия правил, сущностей и процессов из реального мира\n"+
                                                      "Эта цифровая копия и есть Domain model\n Построена на Ubiquitous Language(Повсеместный единый язык)\n Инкапсулирует поведение, а не только данные\n"),

                ("969. Чем Domain Model отличается от схемы базы данных?","Простая аналогия:\n"+
                                                                          "Схема базы данных - это планировка склада книг.\n " +
                                                                          "Она оптимизирована на хранение: чтобы быстро найти книгу по автору или жанру.\n"+
                                                                          "Главная задача эффективность хранение и поиск\n "+
                                                                          "Domain model это правило самой библиотеки.\n"+
                                                                          "Это процессы как читатель берет книги, как библиотекароь выдает\n"+
                                                                          "Главная задача: бизнес-логика и поведение\n"),

                ("970. Зачем разделять модель предметной области и модель хранения?","Модель предметной области это как должно работать\n"+
                                                                                     "Модель предметной области это Где и как мы храним данные\n"+
                                                                                     ""),

                ("971. Как Domain Model помогает при изменениях в бизнес-правилах?","Domain Model главный защитник при изменении бизнес требований\n"+
                                                                                    "1. Изменения локализованы в одном месте\n"+
                                                                                    "2. Безопасное экспериментирование и рефакторинг\n"+
                                                                                    "3. Понятный контекст для изменений\n"+
                                                                                    "4. Упрощенное тестирование\n"+
                                                                                    "5. Реакция на изменения через события\n"),

                ("972. Как выявить основные элементы Domain Model?","1. Анализ событий\n"+
                                                                    "    Какие события происходили или происходят\n    какие команды вызывают события\n    какие сущности меняются при событии\n    какие значения у сущности "+
                                                                    "2. Декомпозиция и уточнение\n"+
                                                                    " Вопросы о поведении\n  Выявите бизнес правила\n   определите контекстные границы\n  "+
                                                                    "3. Наброски кода\n"+
                                                                    "    Создание ключевых классов\n   основные методы отражающие команды\n   добавление правил\n"+
                                                                    ""),

                ("973. Что делает объект сущностью в DDD?","Сущность(Entity) в DDD - это объект, который уникально идентифицируется своим идентификатором\n"+
                                                           "а не своими атрибутами\n"+
                                                           "Ключевые признаки Сущности:\n"+
                                                           "1. Идентичность(identity)\n"+
                                                           "2. Непрерывность и отслеживание жизненного цикла\n"+
                                                           "3. Изменяемость(Mutability)\n"),

                ("974. Пример сущности из e-commerce?","Анализ заказа как Сущности\n"+
                                                       "1. Идентичность(identity) у каждого заказа свой номер\n"+
                                                       "2. Непрерывность и отслеживание жизненного цикла (оформлен,оплачен, доставлен и может быть отменен)\n"+
                                                       "3. Изменяемость(Mutability) Состояние заказа и его свойство может меняться, но его идентичность нет\n"),

                ("975. Почему идентичность важнее состояния при определении сущности?","Сущность это не моментальный снимок, а история изменений\n"+
                                                                                       "Идентичность это якорь, который позволяет другим частям системы безопасно ссылаться на сущность,\n"+
                                                                                       "не беспокоясь о ее текущем состоянии\n"+
                                                                                       "Два объекта могут выглядеть абсолютно одинаково, но быть разными сущностями\n"+
                                                                                       ""),

                ("976. Как лучше всего хранить идентификатор сущности?","1. Создать свой класс обертку\n"+
                                                                        "2. Лучше использовать Guid\n"+
                                                                        "3. Неиспользовать составные ключи в модели, создавать отдельный класс\n"),

                ("977. Могут ли сущности быть вложенными в другие?","Да. Вложенные сущности принадлежат какой то одной главной сущности аггрегату\n"+
                                                                    ""),

                ("978. Что такое Агрегат и корень агрегата","Aggregate это кластер из нескольких связанных сущностей и объектов значений\n"+
                                                            "которые рассматриваются как единое целое\n"+
                                                            "У агрегата есть корень - главная сущность, через которую происходит все взаимодействие с внутренимим объектами\n"+
                                                            "Вложенные сущности - это остальные сущности, которые живут внутри границ  агрегата и не имеют смысла без своего корня\n"),

                ("979. Что такое Value Object?","Value Object это ключевой строительный блок в DDD\n"+
                                                "который представляет собой объект, не имеющий собственный идентичности\n"+
                                                "и определяемый исключительно своими атрибутами\n"+
                                                "Ключевые характеристики:\n"+
                                                "1. Нет идентичности\n"+
                                                "2. Определяется по атрибутам. Его сущность - это совокупность его полей\n"+
                                                "3. Неизменяемость. Это самое важное свойство. Чтобы изменить придется создать новый объект\n"+
                                                "4. Взаимозаменямость. Можно заменять на другие объекты с теми же объектами\n"),

                ("980. Почему Value Objects должны быть иммутабельными?","1. Предсказуемость и отсутствие побочных эффектов\n"+
                                                                         "2. Безопасность в многопоточных средах\n"+
                                                                         "3. Корректное сравнение по значению. Работа со словарем\n"+
                                                                         "4. Упрощение логики и предотвращение ошибок\n"+
                                                                         "5. Value object это концепция значения а не вещи\n"),

                ("981. Пример Value Object в e-commerce?","Деньги(money) определяется валютой или количеством\n"),

                ("982. Как сравнивать Value Objects?","Value Object сравниваются по их полям(атрибутам), а не по идентичности\n"+
                                                      "1. использовать record\n"+
                                                      "2. Ручная реализация через Equals и GetHashCode\n"+
                                                      ""),

                ("983. Почему полезно использовать VO для инкапсуляции инвариантов?","Это мощный прием, который повышает надежность и ясность кода\n"+
                                                                                     "1. Гарантированная валидность объекта. Проверка в конструкторе\n"+
                                                                                     "2. Устранение дублирования кода. Проверка только в внутри VO.\n Не нужно проверять в методе или контроллере\n"+
                                                                                     "3. Делает неявные инварианты явными\n"+
                                                                                     "4. Упрощение сложных инвариантов\n"+
                                                                                     "5. Улучшение безопасности\n"),

                ("985. что такое инвариант","это условие или правило, которое должно всегда быть истинным для объекта\n"+
                                            "или системы на протяжении всего его жизненного пути\n"),

                ("986. Что такое агрегат в DDD?","Агрегат в DDD это кластер из тесно связанных объектов(сущностей и value objects),\n"+
                                                 "который рассматривается как единое целое для операций изменения данных\n"+
                                                 "У каждого агрегата есть корень(Aggregate Root) и граница(Boundary)\n"+
                                                 "Внешние объекты могут ссылаться только на корень агрегата, а не на любые его внутренние объекты\n "),

                ("987. Что такое Aggregate Root?","Это главная сущность внутри агрегата,\n которая выступает его единственной точкой входа из внешнего мира\n"+
                                                  "Все операции с агрегатом должны проходить через его корень\n"),

                ("988. Зачем ограничивать доступ только через Aggregate Root?","1. Обеспечение целосности данных и соблюдение инвариантов\n   Инвариант это бизнес правило, которое всегда должно соблюдаться в рамках агрегата\n"+
                                                                               "2. Четкое определение границ транзакций\n   Агрегат - это единица сохранности данных\n"+
                                                                               "3. Упрощение кода и снижение связанности\n   Внешний код знает только про интерфейс\n "+
                                                                               "4. Улучшение производительности и предсказуемости\n  Поскольку точки входа известны, точно известно что метод выдаст\n "+
                                                                               "5. Более ясная и выразительная модель\n  Агрегат с корнем - это не просто набор классов\n  Это смоделированное понятие предметной области со своим четким контрактом\n"),

                ("989. Как определить границы агрегата?","1. Оттакливаться от инвариантов\n Бизнес правило, которое должно всегда соблюдаться\n для группы объектов в рамках одной транзакции\n "+
                                                         "2. Анализируйте шаблоны доступа\n Какие объекты почти всегда запрашиваются и изменяются вместе\n"+
                                                         "3. Доверяйте Единому языку(Ubiquitous language)\n Язык говорит находится в, а не имеет составную часть\n"+
                                                         "4. Руководствуйтесь практическими ограничениями.\n Агрегат не должен быть слишком большим. \n Производительность и согласованность\n"),

                ("990. Чем агрегаты помогают в масштабировании системы?","Агрегаты это не просто паттерн для целосности данных,\n но и мощный инструмент для масштабирования сложных систем\n"+
                                                                         "Они помогают масштабироваться как вертикально(производительность одного сервиса), так и горизонтально(распределение системы)\n"+
                                                                         "1. Естественные границы для распределенных систем(Микросервисы)\n  Поскольку агрегат - это автономная единица с четкими границами\n"+
                                                                         "  и собственным жизненным циклом, его часто можно выделить в отдельный микросервис\n"+
                                                                         "2. уменьшение конфликтов блокировок в БД\n Агрегат это граница транзакции. Транзакция работает только с одним агрегатом.\n"+
                                                                         "  Поэтому агрегаты небольшие и сфокусированные, время удержания блокировки минимально\n"+
                                                                         "3. Упрощение стратегий постоянства (Persistence) и кеширования\n  (Запись)Поскольку агрегат сохраняется целиком, его легко сериализовать в документ NoSql. Это ускорит запись\n  "+
                                                                         "(Чтение) Агрегат - это идеальная единица для кеширования. Часто используемый агрегат можно целиком закешировать в Redis\n"+
                                                                         "4. Основа для шардирования(Sharding) Агрегат предоставляет идеальный ключ шардирования - ID своего корня\n"+
                                                                         "5. Управление нагрузкой на основе предметной области\n"+
                                                                          "Поскольку агрегаты отражают бизнес-концепции, вы можете масштабировать части системы в соответствии с реальной нагрузкой\n"),


                ("991.Sharding что такое ","Шардирование это метод горизонтального деления на части базы данных,\n при котором один логический набор данных\n"+
                                           "разделяется и рапределяется по множеству баз данных(шардов) на разных серверах\n"+
                                           "каждый шард является самостоятельной базой данных, а вместе они образуют единую логическую базу\n"),

                ("992. Какую роль играет репозиторий в DDD?","Репозиторий в DDD играет критически важную роль,\n "+
                                                             "выступая в качестве посредника между доменным слоем и слоем доступа к данным\n"+
                                                             "Основная цель:\n"+
                                                             "1. Абстракция доступа к данным\n Скрывает все детали реализации базы данных от доменного слоя\n"+
                                                             "2. Работа с агрегатами\n Репозиторий оперирует целыми агрегатами, а не их отдельными частями\n"+
                                                             "3. Предоставление коллекции в памяти.\n  Репозиторий имитирует коллекцию объектов в памяти\n"+
                                                             "4. Предоставление методов атомарного сохранения\n"),

                ("993. Почему репозиторий не должен возвращать DTO или данные напрямую из БД?","1. Нарушение инкапсуляции и потеря бизнес логики.\n  В DTO не содержится никакой логики. Нельзя вызвать методы\n "+
                                                                                               "2. Нарушение границ и целосности данных\n Репозиторий должен загружать весь агрегат целиком\n чтобы обеспечить его целосность\n  Агрегат это единица целосности.\n Его нужно загружать полностью либо не загружать вообще\n"+
                                                                                               "3. Превращение Репозитория в слой презентации\n  Репозиторий принадлежит доменному слою\n  Его задача предоставлять доменные объекты для бизнес логики\n"+
                                                                                               "4. Сложности с обновлением данных\n Работа с DTO усложняет механизм отслеживания изменений\n"),


                ("994. DTO ","Data Transfer Object - это объект,\n который используется для передачи данных между подсистемами приложения \n или разными процессами\n"),

                ("995. Можно ли использовать ORM внутри репозитория?","Нужно. Это стандартная практика и рекомендуемая практика в DDD\n"),

                ("996. Чем репозиторий отличается от DAO?","Репозиторий и DAO(Data Access Object) часто путают, потому что оба абстрагируют доступ к данным\n"+
                                                           "однако есть ключевые отличия\n"+
                                                           "DAO предоставляет абстракцию для работы с таблицами БД,\n а Репозиторий - абстракцию для работы с коллекцией доменных объектов\n"+
                                                           "методы DAO  это прямые аналоги SQL операций\n возвращает DTO"),

                ("997. Когда стоит использовать доменный сервис вместо сущности?","Сначала помещайте поведение в сущности\n"+
                                                                                  "Используйте доменный сервис, тогда когда операция по своей природе не принадлежит ни одной сущности\n Поведение должно находится внутри сущности:\n" +
                                                                                  "1. Изменяет внутреннее состояние этой сущности\n"+
                                                                                  "2. Относится к одному конкретному объекту и является его неотъемлемой ответственностью\n"+
                                                                                  "3. Выражается языком предметной области как действие, которое объект совершает или с ним происходит\n"+
                                                                                  "Когда использовать доменный сервис:\n"+
                                                                                  "1. Не принадлежит ни одной сущности(координирует несколько сущностей)\n"+
                                                                                  "2. Реализует сложный алгоритм или бизнес правило, требующих внешних зависимостей\n"+
                                                                                  "3. Представляет концепцию из предметной области, которая не является объектом\n"+
                                                                                  ""),

                ("998. Пример доменного сервиса в e-commerce?","Сервис проверки лимита склада\n"+
                                                               "При добавлении товаров в корзину нужно проверить его наличие на складе\n"+
                                                               "Но эта логика не принадлежит ни корзине, ни товару, так как требует обращения\n"+
                                                               "к репозиторию и координации нескольких сущностей\n"),

                ("999. Почему доменные сервисы должны быть чистыми и без состояния?","Требование к чистоте и отсутствия состояния для доменных сервисов\n"+
                                                                                     "это фундаментальное правило, которое вытекает из самих принципов DDD и обеспечивает\n"+
                                                                                     "надежность, предсказуемость и простоту требования доменного слоя\n"+
                                                                                     "1. Чистая функция которая всегда возвращает один и тот же результат,\n"+
                                                                                     "для одних и тех же входных данных\n Не имеет побочных эффектов(не изменяет состояние внешнего мира или переданных ей объектов)\n"+
                                                                                     "2. Легкость тестирования. Без состояния и без побочных эффектов мечта тестировщика\n"+
                                                                                     "3. Безопасность в многопоточной среде и отсутствие скрытых зависимостей\n "),

                ("1000. Чем доменный сервис отличается от application service?","Domain Service содержит бизнес логику(правила предметной области)\n"+
                                                                                "Application Service координирует workflow(последовательность действий для выполнения сценария)\n"+
                                                                                "аналогия:\n"+
                                                                                "Domain Service - эксперт(знает правила)\n"+
                                                                                "Application Service - менеджер(координирует процесс)\n"),

                ("1001. Где хранить доменные сервисы?","Интерфейс доменного сервиса хранится в Domain Layer(доменном слое)\n"+
                                                       "Реализация доменного сервиса хранится в Infrastructure Layer(инфраструктурном слое),\n"+
                                                       "если она требует внешних зависимостей или Domain Layer, если она чисто вычислительная\n"),

                ("1002. Что такое Domain Event?","Domain Event(доменное событие) - это объект, котjрый представляет факт, произошедщий\n"+
                                                 "в предметной области домене, который имеет значение для экспертов предметной области\n"+
                                                 "Проще говоря это способ уведомить другие части системы о том, что то важное уже произошло\n"),

                ("1003. Пример Domain Event?","1. Вы оплачиваете заказ\n"+
                                              "2. Касса выдает билет и отправляет вам электронное письмо с потверждением\n"+
                                              "3. Отправка email это не часть процесса оплаты. Это реакция на факт ЗакаЗ Оплачен\n"+
                                              "Заказ Оплачен это и есть Domain Event\n"),

                ("1004. Зачем использовать Domain Events?","Domain Events(Доменные события) это не просто технический паттерн,а\n"+
                                                           "фундаментальный концепт DDD для постороения гибких, масштабируемых систем\n"+
                                                           "1. Для реализации согласованности без блокировки в транзакции\n"+
                                                           "2. Для уменьшения связи между агрегатами\n"+
                                                           "3. Для явного моделирования бизнес процессов\n"+
                                                           "4. Для интеграции с внешними устройствами\n"),

                ("1005. Как события помогают синхронизировать bounded contexts?","Domain events это основной механизм для синхронизации\n "+
                                                                                 "Bounded Context в DDD. Они позволяют им работать согласовано, оставаясь полностью независимыми\n"+
                                                                                 "Работает принцип публикация\\подписка\n Публикация Publish(один Bounded Context), Подписка Subscribe(другой Bounded Context), Реакция(React) подписчик обновляет свое состояние после события\n "+
                                                                                 ""),

                ("1006. Как хранить Domain Events?","1. Временное хранение(для немедленной публикации)\n Самый распространенный подход\n  "+
                                                    "События хранятся в памяти агрегата только на время выполнения бизнес транзакций,\n"+
                                                    "чтобы быть опубликованным сразу после сохранения в БД\n"+
                                                    "2. Постоянное хранение\n паттерн Outbox(событие сохраняется в ту же БД, что и агрегат в рамках той же транзакции\n)"+
                                                    "паттерн Event Sourcing Это радикальный подход при котором состояние агрегата не сохраняется вообще\n"+
                                                    "Сохраняется только последовательность всех событий, которые с ним произошли\n"),

                ("1007. В чём ключевое различие между командой и запросом в CQRS?","Ключевое различие между командой(Command) и запросом(Query) в CQRS\n"+
                                                                                    "заключается в их фундаментальном намерении(invent ) и принципе CQS(Command-Query Separetion)\n"+
                                                                                    "Команда(Command) это намерение изменить состояние системы\n"+
                                                                                    "Запрос(Query) это намерение получить данные из системы, не изменяя ее состояния\n"+
                                                                                    "Команда(Command)(Сделай что то) не возвращает результат,а вместо этого может вернуть статус\n"+
                                                                                    "Запрос(Query) Дай мне что то\n Запрос представляет собой просьбу предоставить информацию\n "+
                                                                                    "Он не должен влиять на состояние системы\n Он должен быть идемпотетным и не вызывать побочных эффектов\n"),

                ("1008. Почему важно разделять модели для команд и запросов?","Разделение моделей для команд(запись) и запросов(чтение) - это фундаментальный принцип CQRS\n"+

                                                                                "который приносит огромные преимущества\n"+
                                                                                "1. Команда(Write Model) Ее цель обеспечить целостность данных и выполнить бизнес правила\n  Модель данных должна быть строгой, нормализованной и защищенной\n"+
                                                                                "2. Запрос(Read Model) Его цель быстро отдать данные для отображения.\n"+
                                                                                "Модель чтения должна быть быстрой, денормализованной и удобной для клиента\n"+
                                                                                "3. Оптимизация производители\n"+
                                                                                "Для записи нормализовааную базу, а для чтения денормализованные проекции"),

                ("1009. Может ли команда возвращать данные?","Нет можно только статус, id созданого объекта\n"),


                ("1010. Как это разделение помогает в масштабировании?","разделение команд(запись) и запросов(чтение) - это ключевой архитектурный прием\n"+
                                                                        "для горизонтального масштабирования\n Оно помогает именно потому, что признает фундаментально\n"+
                                                                        "разную природу операций записи и чтения и позволяет их оптимизировать их независимо друг от друга\n"+
                                                                        "1. независимое масштабирование компонентов\n"+
                                                                        "2. Разные модели данных для разных целей\n"+
                                                                        "3. Разделение по коду и развертыванию\n"+
                                                                        "4. Разные стратегии кеширования\n"+
                                                                        "5. Гибкость выбора технологий\n"),

                ("1011. Как определить, что операция — команда, а не запрос?","1.меняет ли она состояние.\n Да это команда, нет скорей всего запрос\n"+
                                                                              "2. можно ли ее безопасно вызывать много раз подряд без изменения результата\n Да это запрос, нет это команда"+
                                                                              "3. что она возвращает? \n Данные - это запрос\n Статус выполнения - это команда\n"+
                                                                              "4. Как она названа?(неявное) Глагол это команда, Существительное или вопрос запрос"),

                ("1012. Что такое идемпотентность команды?","Это свойство означающее что повторное выполнение одной и той же команды(с одинаковыми параметрами)\n"+
                                                            "не оказывает дополнительного эффекта после первого успешного выполнения"),

                ("1013. Зачем нужна идемпотентность в распределённых системах?","если в системе что то пойдет не так, то не будет дублей, сохранится состояние или перенапрвиться без потери данных"),

                ("1014. Как можно реализовать идемпотентность команды?","1. Паттерн Уникальный идентификатор команды. Каждая команда получает свой идентификатор\n "+
                                                                        "2. Реализация обработчика команд с проверкой идентичности\n"+
                                                                        "3. Репозиторий для отслеживания обработанных команд\n"+
                                                                        "4. Конкретная реализация обработчика команды\n"+
                                                                        "5. Middleware для автоматической обработки идемпотентности\n"),

                ("1015. Пример неидемпотентной команды?","Списание денег\n"+
                ""),

                ("1016. Пример идемпотентной команды?","Установка точного баланса счета\n"),

                ("1017. Что делает Command Handler?","1. Принятие команды\n"+
                                                     "2. Валидация команды\n"+
                                                     "3. Извлечение агрегатов\n"+
                                                     "4. вызов бизнес логики\n"+
                                                     "5. сохранение изменений\n"+
                                                     "6. Публикация событий\n"),

                ("1018. Что делает Query Handler?","Query Handler(обработчик запросов) - это компонент паттерна CQRS,\n"+
                                                   "который отвечает исключительно за чтение данных и не изменяет состояние системы\n"+
                                                   "Основанная ответственность Query Handler:\n"+
                                                   "1. Получение данных для чтения\n"+
                                                   "2. Фильтрация и проекция данных\n"+
                                                   "3. Агрегация и статистика\n"+
                                                   "4. Пагинация и сортировка\n"+
                                                   " "),

                ("1019. Почему стоит разделять обработчики?","Разделение обработчиков это прямое следствие принципа CQRS(Command Query Responsibility Segregation)\n"+
                                                             "Ключевые причины почему стоит их разделять:\n"+
                                                             "1. Принцип единственной отвественности(Single Responsibility Principle)\n  Command HAndler отвечает за состояние системы,\n  Query Handler отвечает только за получение данных\n"+
                                                             "2. Различная семантика и поведение поэтому и разная реализация\n"+
                                                             "3. Масштабируемость. Паттерны чтения и записи в большинтсве случаев неравномерны\n"+
                                                             "4. Гибкость и эволюция модели. Модели можно изменять независимо\n"+
                                                             "5. Упрощение кода и повышение его понятности\n"),

                ("1020.Как реализовать обработчики с MediatR?","1. Установка NuGet пакета\n"+
                                                               "2. Регистрация Mediatr в Startup.cs\n"+
                                                               "3. Создание Команд(Commands) и Запросов(Queries)\n"+
                                                               "4. Создание обработчиков HAndlers\n"+
                                                               "5. Использование IMediator в контроллере или других сервисах\n"+
                                                               ""),

                ("1021. Можно ли объединять несколько обработчиков в один?","можно, но не нужно. Это антипаттерн\n"+
                                                                            "нарушение принципа единственной ответственности, потеря преимущества CQRS "),

                ("1022. Зачем нужны разные модели чтения и записи?","Модели записи и чтения служат кардинально разным целям,\n поэтому их требования оптимизации полностью противоположны\n "+
                                                                    "Модель записи: безопасное и корректное изменение состояния.\n  Обеспечить соблюдение бизнес-правил.\n   Оптимизирована под целосность данных\n  Нормализованная БД\n  Содержит сложную бизнес логику\n"+
                                                                    "Модель чтения: максимальное быстрое и удобное получение данных,\n  (индексы, денормализация, кеширование)\n"+
                                                                    "Неравномерность нагрузки\n"+
                                                                    "Гибкость и независимое развитие\n"),

                ("1023. Что хранит Write Model?","1. Состояние бизнес объектов(Агрегаты и сущности)\n"+
                                                 "2. Бизнес правила и инварианты(write model инкапсулирует поведение)\n"+
                                                 "3. Domain Events(События домена) Write model часто ответсвенна за генерацию  события домена\n"+
                                                 "4. Write model активно используют ValueObject для описания атрибутов "),

                ("1024. Что хранит Read Model?","1. Read model хранит данные не в том виде котором они сохранены,\n а в том виде котором они нужны клиенту\n"+
                                                "2. Read model часто содержит результаты расчитанных вычислений, что бы не делать их на лету\n"+
                                                ""),

                ("1025. Можно ли их хранить в одной базе?","Да можно. Хранение Write model и read model в одной физической базе данных\n это абсолютно нормальнгый и распространненый подход\n особенно на начальных и средних этапах\n "+
                                                           "Таблицы для Write model:\n Нормализованные\n,с foreign keys, используются командами для внесения изменений\n" +
                                                           " таблицы\\представления для read model:\n Денормализованные, содержат рассчитанные данные\n оптимизированы индексами для быстрого чтения\n используются запросами для выборки\n"),

                ("1026. Что делает MediatR в CQRS?","1. MediatR предоставляет конкретные абстракции(IRequest, IRequestHandler)\n"+
                                                    "2. MediatR формализует различия между командой и запросом через свои интерфейсы(IRequest и IRequest<T>)\n"+
                                                    "3. Mediatr выступает в роли посредника между клиентом(контроллером) и бизнес логикой(обработчиком). \n  контроллер зависит только от абстракция IMediator\n"+
                                                    "4. Упрощает контроллеры и повышает тестируемость\n"+
                                                    "5. реализация паттерна декоратор"),

                ("1027. Как вызвать команду через MediatR?","Получаем класс IMediator через внедрение зависимости в класс\n"+
                                                            "await _mediator.Send(command)\n"),

                ("1028. Как вызвать запрос через MediatR?","Внедрение IMediator через внедрение зависимости\n"+
                                                           "await _mediator.Send(query)\n"),

                ("1029. Можно ли регистрировать несколько обработчиков на одну команду?","Одна команда - один обработчик\n"),

                ("1030. Что такое согласованность в CQRS?","В CQRS согласованость между моделями чтения и записи почти всегда явялется eventual consistency\n"+
                                                           ""),

                ("1031. Eventual Consistency","Eventual consistency - это модель согласованости данных,\n"+
                                              "которая гарантирует, что если в системе не происходит новых изменений,\n"+
                                              "то через некоторое время все узлы(базы данных ) придут к одному и тому же состоянию\n"),

                ("1032. Когда использовать транзакцию в CQRS?","Транзакции нужны для обеспечения целосности Write Model.\n" +
                                                                 " Read Model в транзакции не участвует\n"+
                                                                 "Что инкасулируется в транзакцию:\n"+
                                                                 "1. Изменение состояния агрегата(корня агрегата)\n"+
                                                                 "2. Сохранение этого изменения в базе данных\n"+
                                                                 "3. Сохранение событий домена(Domain Events), связанных с этим изменением, в ту же базу данных\n"+
                                                                 "ДЛЯ обработки Одного агрегата в рамках одной команды"),

                ("1033. Чем опасна слишком большая транзакция?","Слишком большая транзакция это антипаттерн\n"+
                                                                "1. Блокировки\n"+
                                                                "2. Потребление ресурсов\n"+
                                                                "3. Нарушение принципов CQRS и микросервисов\n"+
                                                                "4. Сложность и риск ошибок\n"+
                                                                "5. Проблемы масштабирования\n"),

                ("1034. Как обеспечить согласованность между Read и Write Model?","Обеспечение согласованости между Read и Write Model заключается в том,\n чтобы отказаться от немедленной согласованости в пользу eventual consistency\n"+
                                                                                  "и использовать для этого надежные инструменты\n"+
                                                                                  ""),

                ("1035. Как обрабатывать ошибки при частичном выполнении команды?","1. Транзакция БД\n"+
                                                                                   "2. Паттерн компенсирующих операций(Compensating Action)/Saga\n"+
                                                                                   "3. Паттерн повторитель(Retry) с идемпотетностью\n"+
                                                                                   "4. "),

                ("1036. Что такое Domain Event в CQRS?","В CQRS Domain Events являются тем самым клеем,\n"+
                                                        "который обеспечивает eventual consistency между write и Read Model\n"+
                                                        "Это основной механизм для уведомления других частей системы об изменениях\n"+
                                                        "Последовательность работы:\n "+
                                                        "1. Команда изменяет агрегат(Write Model)\n"+
                                                        "2. Агрегат генерирует одно или несколько Domain Events как результат\n"+
                                                        "3. События сохраняются(часто в той же транзакции что и агрегат)\n"+
                                                        "4. События публикуются и доставляются всем заинтересованным обработчикам\n"+
                                                        "5. Обработчики события обновляют Read Model или запускают другие процессы\n"),

                ("1037.  Зачем публиковать события после команд?","1. синхронная и асинхронная связь между контекстами(Bounded Context)\n"+
                                                                  "2. построение проекций(Read Models) в CQRS\n База данных часто оптимизирована под конкретные запросы\n"+
                                                                  "3. Логгирование\n "),

                ("1038. Как хранить события?","1. Хранение в качестве журнала событий(Event Store)\n"+
                                              "2. Хранение в качестве историй событий(Event History)\n"),

                ("1039. Как MediatR помогает в обработке событий?","1. Главная задача убрать прямые зависимости\n"+
                                                                   "2. INotification события должны реализовавать этот интерфейс\n"+
                                                                   " "),

                ("1040. Чем отличаются события домена и интеграционные события?","1. Domain Event - это факт, произошедший в пределах одного доменного контекста(микросервиса) \n Его основная цель - уведомить внутренние части системы об изменении\n"+
                                                                                 "2. Integration Event - это факт, который готов для публикации внешним потребителем(другим сервисом)\n Его основная цель - обеспечить согласованность данных между разными контекстами или сервисами\n"),

                ("1041. Что такое eventual consistency?","это модель гарантии согласованности данных, при которой обновления, примененые к одному узлу системы,\n рано или поздно распростараняются на другие узлы системы, но не мгновенно\n"),

                ("1042. Почему это важно в CQRS?(eventual consistency)","это не побочный эффект, а основа архитектуры и ключевая проектная особенность\n Это выбор в пользу производительности, масштабируемости и гибкости"),

                ("1043. Как реализовать eventual consistency?","1. асинхронная коммуникация через события\n"+
                                                               "2. паттерн Transaction Outbox\n"+
                                                               "3. паттерн Идемпотентный потребитель\n"+
                                                               "4. паттерн Saga для управления распределенными транзакциями\n"+
                                                               "5. компенсирующие операции\n"+
                                                               "6. проектирование подходящего пользовательского интерфейса\n"),

                ("1044. Как уведомить пользователя о задержке обновления?","через визуальные индикаторы состояния\n"),

                ("1045. Когда не стоит применять eventual consistency?","1. Финансовые операции\n"+
                                                                        "2. Система реального времени с высокой координацией\n"),

                ("1046. Чем отличается маппинг между моделями и ORM-маппингом?","Маппинг между моделями - это преобразование данных\n из одной структуры(формата) в другую внутри кода приложения\n"+
                                                                                 "ORM маппинг это преобразование (отображение) объектов в памяти на структуру релиационной базы и обратно\n"),

                ("1047. Какие библиотеки используют для маппинга в CQRS?","1. AutoMapper самый популярный. Весьма гибкий в работе\n"+
                                                                          "2. Mapster более производительный\n"+
                                                                          "3. Иногда в ручную самый удобный способ\n"),

                ("1048. Чем опасен автоматический маппинг?","может быть null при ошибке именования\n"+
                                                            "нарушение инкапсуляции\n"+
                                                            "более медленные\n"+
                                                            "усложнение тестирования\n"+
                                                            ""),
                ("1049. Как защитить Write Model от прямого маппинга из внешних данных?","1. Никогда не использовать маппинг для преобразования команд и DTO в доменные сущности\n"+
                                                                                         "2. Использование в DDD AutoMapper это антипаттерн\n"+
                                                                                         "3. использование валидацци, сеттеров, конструкторов\n"),

                ("1050. Как оптимизировать маппинг для Read Model?","1. Делать сразу проекцию(ProjectTo)\n"+
                                                                    "2. Специальные read model\n"+
                                                                    "3. Денормализованные модели\n"+
                                                                    "4. Индексы\n"+
                                                                    "5. Кеширование и пагинация\n"),

                ("1051. Как тестировать Command Handler?"," Проверить что:\n "+
                                                          "1. Валидная команда приводит к правильному состоянию системы\n"+
                                                          "2. Невалидная отклоняется\n"+
                                                          "3. Вся бизнес логика работает\n"+
                                                          "4. Правильные зависимости вызываются с правильными агрументами\n"),

                ("1052. Как тестировать Query Handler?","Проверить что:\n"+
                                                        "1. Возвращает правильные данные для заданных условий\n"+
                                                        "2. Корректно фильтрует данные по параметрам запроса\n"+
                                                        "3. Правильно сортирует и пагинирует результаты\n"+
                                                        "4. вызывает правильные методы репозиториев с правильными параметрами\n"),

                ("1053. Зачем разделять тестирование команд и запросов?","1. Принциально разное назначение\n"+
                                                                         "2. Разные стратегии Проверок\n"+
                                                                         "3. Разный подход к тестовым данным\n"+
                                                                         "4. Разные последствия ошибок\n"+
                                                                         "5. разная сложность и количество тестов\n"),

                ("1054. Как тестировать идемпотентность команды?","1. юнит тестирование повторных запросов\n"+
                                                                  "2. интеграционное тестирование \n"+
                                                                  "3. тестирование различных сценариев\n"+
                                                                  "4. тестирование состояния механизма идемпотетности\n"+
                                                                  "5. тестирование с различными статусами команды\n"),

                ("1055. Что такое business capability?","Business capability(бизнес возможность) - это способность или потенциал компании выполнять\n"+
                                                        "определенную основную деятельность для достижения конкретной цели или результата\n"+
                                                        "Что делает компания а не как она это делает\n"),

                ("1056. Почему разбиение по бизнес-возможностям предпочтительнее по техническим слоям?","Фокус на бизнес-ценности, а не на технологиях\n"+
                                                                                                         "масштабируемость команд\n"+
                                                                                                         "более четкие границы и контексты\n"),

                ("1057.Как найти границы сервисов при разбиении по бизнес-возможностям? ","1. Составить список Business Capabilities\n"+
                                                                                          "2. проведите Event Storming\n"+
                                                                                          "3. определить ограниченных контекстов\n"+
                                                                                          "4. проверка границ ограниченных контекстов\n"+
                                                                                          "5. анализ как сервисы будут общаться между собой\n"+
                                                                                          "6. "),
                ("1058. Как business capability соотносится с bounded context в DDD?","Business Capability это то ЧТО делает бизнес\n"+
                                                                                      "Bounded Context это КАК эта возможность реализована в програмной системе\n"+
                                                                                      "включая четкие границы терминов и моделей\n"),

                ("1059. Как часто меняется business capability?","Bisiness Capability меняется очень редко. По сути описывает саму систему бизнеса\n"),

                ("1060. Что такое поддомен в DDD?","Поддомен это часть предметной области(Domain), которую бизнес хочет автоматизировать\n"+
                                                   "или улучшить."),

                ("1061. Какие бывают типы поддоменов?","1. Core Subdomain(Ядровой/основной)\n"+
                                                       "2. Supporting Subdomain(Поддерживающий поддомен)\n"+
                                                       "3. Generic Subdomain(общий поддомен)\n"+
                                                       " "),
                ("1062. Как определить core subdomain?","1. Сложная и уникальная бизнес логика\n"+
                                                        "2 .Высокая частота изменений\n"+
                                                        "3. Требует глубоких знаний экспертов\n"+
                                                        "4. Потенциал для инноваций\n"),

                ("1063. Почему generic subdomain часто выносят во внешние сервисы или покупают?","Это стратигическое решение которое основано на приницпе не изобретать велосипед\n"),

                ("1064. Как поддомены помогают в управлении сложностью?","1. Декомпозиция\n"+
                                                                         "2. Расстановка приоритетовю Фокус на главном\n"+
                                                                         "3. Создание четких границ\n"+
                                                                         "4. Фокусировка команд\n"+
                                                                         "5. Выбор правильных инструментов и архитектуры\n"),
                ("1065. Что делает паттерн Strangler?","Душитель. один из ключевых архитектурных паттернов для постепенной\n"+
                                                       "безопасной и контролируемой миграции легаси кода\n "+
                                                       "1.Трансформация. Создается новая система\n"+
                                                       "2. Маршрутизация между клентом и старой и новой системами\n"+
                                                       "3. Уничтоженение старой системы\n"),

                ("1066. Как он помогает снизить риски миграции?","Миграции происходят небольшими, управляемыми частями\n"),

                ("1067. Как реализовать Strangler для монолита?","1. Создать единую точку(фасад)\n"+
                                                                 "2. Создать новый сервис\n"+
                                                                 "3. Настроить наршрутизацию  на новый сервис\n"+
                                                                 "4. Сделать со всеми новыми сервисами и отключить монолит\n"),

                ("1068. В чём опасность слишком долгого strangler-периода?","создание распределенного монолита и бюджетные риски\n"),

                ("1069. Когда лучше всего использовать Strangler?","1. Когда есть старый критически важный монолит\n"+
                                                                   "2. Когда нужно минимум бизнес рисков\n"+
                                                                   "3. Когда можно четко определить границы модулей\n"+
                                                                   "4. Когда есть долгосрочная стратегия и ресурсы\n"),

                ("1070. Что такое ACL и зачем он нужен?","Anti corruption Layer это архитектурный паттерн, основная задача которого\n"+
                                                         "защитить новую систему от негативного влияния старой системы\n"),

                ("1071.Какие инструменты используются для реализации ACL? ","Собственная библиотека + брокер сообщений\n"),

                ("1072. Где размещать ACL?","Как отдельный сервис или клиентская библиотека в новой системе \n"),

                ("1073. Что произойдет, если не использовать ACL?","В новую систему попадут старые проблемы\n"),

                ("1074. Как тестировать ACL?","Unit тесты, интеграционное тестирование, тестирование устойчивости при legacy сбое"),

                ("1075. Database per Service. В чем основные преимущества подхода?","это фундаментальный принцип микросервисной архитектуры,\n"+
                                                                                     "согласно которому каждый сервис владеет своей собственной базой данных\n"+
                                                                                     "и только он имеет к ней прямой доступ\n"),

                ("1076. Какие минусы у подхода Database per Service.?","1. Сложность работы где надо задействовать несколько баз данных\n"+
                                                                       ""),

                ("1077. Как реализовать кросс-сервисные выборки? Database per Service","Создать отдельный сервис композитор или CQRS\n"),

                ("1078. Как подход влияет на транзакции  ? Database per Service","согласованость Eventual consistency, нужно использовать сага, ручной откат компенсирующих транзакций"),

                ("1079. Как мигрировать схемы? Database per Service","Расширение за счет добаваления новых функций, не удаляя старых\n "+
                                                                     "Постепенные миграции и удаление старых "),

                ("1080. Какой главный риск у Shared Database?","Общая база данных(жесткая связаность)\n Потеря независимости сервисов и команд.\n"),

                ("1081. Shared Database Когда этот подход допустим?","На начальном этапе монолита, для тесно связанных сервисов и высокопроизводительные отчеты и аналитика\n"),

                ("1082. Как снизить риски при общем доступе? Shared Database","Строгое управление правами доступа и у каждой таблицы должен быть единственный сервис владелец\n"),

                ("1083. Как перейти с Shared Database на независимые базы?","обычно через паттерн душитель\n"),

                ("1084. Что такое API composition?","API Composition этот архитектурный паттерн в микросервисной архитектуре,\n"+
                                                    "который решает проблему получения данных, путем создания специального композитного сервиса(API Composer)\n"),

                ("1085. Где лучше всего размещать композицию?","На стороне клиента,внутри сервиса или специального Api шлюза\n"),

                ("1086.Как избежать проблемы N+1 запросов? API Composition ","паттерн запрос пачкой"),

                ("1087. Как обеспечить отказоустойчивость?","Таймауты, повторные попытки, разрыв цепи\n"),

                ("1088. API Composition Как поддерживать согласованность данных?","Транзакции"),

                ("1089. В чем суть CQRS?","разделение ответствености между операциями которые меняют данные(команды),\n и операциями которые их читают(запросы)"),

                ("1090. Какие плюсы даёт разделение?","Масштабируемость, производительность, упрощение сложных моделей и гибкость и ясность кода"),

                ("1091. Как обновляется Read Model?","обновление в той же транзакции что write model\n "+
                                                     "асихронное обновления через события генерируемое write model\n"+
                                                     "периодическое обновление"),

                ("1092. Где происходят транзакции? CQRS","Транзакция в рамках одного сервиса(монолит или единая БД)\n"+
                                                         "Транзакция базы данных на стороне записи\n"+
                                                         "Распределение транзакций между сервисами САГА"),

                ("1093. Когда не стоит применять CQRS?","Простые приложения, требуется строгая согласованость\n"),

                ("1094. В чем суть подхода? Event Sourcing","Суть подхода заключается в том что состояние приложения не определяется последним снимком данных\n"+
                                                            "а последовательностью событий, которые привели к этому состоянию\n"),

                ("1095. Какие плюсы? Event Sourcing","Есть вся история действий\n"+
                                                     "можно восстановить любое состояние системы на любой момент в прошлом\n"+
                                                     "гибкость и ясная бизнес логика\n"),

                ("1096. Какие минусы? Event Sourcing","Сложность "),

                ("1097. Для чего нужны snapshots?Event Sourcing","Загрузить все события из потока этого агрегата и применить последовательно\n"),

                ("1098. Как Event Sourcing сочетается с CQRS?","Увеличивается производительность и независимость Записи и Чтения\n"),

                ("1099. Что такое сага?","Сага это последовательность шагов, которые вместе образуют бизнес-транзакцию,\n"+
                                         "распределенную на несколько сервисов\n"+
                                         "Если один из шагов завершается неудачей,\n"+
                                         "сага запускает компенсирующие действие\n"),

                ("1100. Оркестрация vs хореография?","1. Существует центральный координатор(оркестратор) который явно управляет потоком выполнения процесса\n"+
                                                     "2. Управление процессом разделено между участниками.\n" +
                                                     " Каждый сервис самостоятельно решает какие действия предпринять в ответ на события,\n"+
                                                     "произошедшие в системе\n"),

                ("1101. Что такое компенсация в саге?","это бизнес транзакция которая логически отменяет эффект предыдущего успешного выполненого шага в саге\n"),

                ("1102.Зачем идемпотентность в шагах саги?","Компенсацию можно вызвать многократно и результат должен быть одинаковым\n"),

                ("1103. Как диагностировать выполнение саги?","Логгирование и трассировка в рамках единой системы\n"),

                ("1104. Что делает API Gateway?","Это мощный и многофункциональный оркестратор, который упрощает взаимосвязь \n"),

                ("1105. Какие риски при использовании API Gateway?","1. Отказывает весь ваш продукт, сложный в разработке"),

                ("1106. Как версионировать API через Gateway?","через URL Path\n"),

                ("1107. Как обеспечивается безопасность API Gateway?","Напоминает стену(авторизация, защита от ошибок и перегрузок)"),

                ("1108. Как собирать метрики и логи API Gateway?","Logging"),

                ("1109. Зачем нужен BFF (Backends for Frontends)?","это архитектруный паттерн, который решает конкретные проблемы,\n"+
                                                                   "возникающие при использовании общего API для разных типов клиентов\n"),

                ("1110. Как BFF соотносится с API Gateway?","API GAteWay это единая точка входа(проверка), а BBF собирает данные\n"),

                ("1111. Где должна находиться бизнес-логика в BFF?","должна быть клиенто-спецефическая бизнес логика\n"),

                ("1112. Как версионировать BFF?","создание отдельного экземпляра\n"),

                ("1113. В чём опасность неправильного BFF? ","Это антипаттерн")


































































            };
        }

        public int GetNumber()
        {
            Random random = new Random();
            //0-130 git
            //131-478 sql
            //479-830     продвинутый C#
            //831-917 3 блок без чек листа
            //return random.Next(505, 515);
            return random.Next(831, listQA.Count-1);
        }

        public void PrintQA()
        {
            int number = GetNumber();
            Console.WriteLine($"Вопрос номер {number}");
            Console.WriteLine(listQA[number].Item1);
            Console.WriteLine("\n");
            Console.ReadKey();
            Console.WriteLine($"Ответ номер {number}");
            Console.WriteLine(listQA[number].Item2);
            Console.WriteLine("\n");

        }
    }
}

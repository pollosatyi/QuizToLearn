using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Xml.Schema;

namespace QuizToLearn
{
    internal class ListQA
    {
        public List<(string, string)> listQA { get; set; }
        public ListQA()
        {
            listQA = new List<(string, string)>()
            {
                ("0. Что такое git-flow?"," это модель ветвления для Git, которая предлагает стандартизированный подход к управлению ветками в проекте.\n"+
                                          "Основные ветки в Git-flow:\n"+
                                           "master. В нем стабильный код. Хранит в себе версии релизов \n"+
                                           "develop. Основная ветка для разработки.В нее сливаются все ветки feature и из нее создаются release ветки\n"+
                                           "feature.Создаются  от develop и сливаются в develop.\n "+
                                            "release. Создаются от develop.Тестирование и документация. Сливается в master и develop\n"+
                                            "hotfix. Создаются для исправления багов. Сливаются в master и develop"),

                ("1. Чем git-flow отличается от trunk-based development?","это методология разработки, при которой вся команда работает в одной основной ветке (trunk или main)\n" +
                                                                        ", а изменения интегрируются как можно чаще (в идеале — несколько раз в день).\n" +
                                                                        " Это противоположность Git-flow, где используется множество долгоживущих веток."),

                ("2. Почему git-flow может тормозить команды, работающие по Scrum?","В Git-flow фичи разрабатываются в изоляции, а мержатся в develop только после полной готовности.\n" +
                                                                                  "merge часто происходит в ручную из за большого обьема кода\n "+
                                                                                  "У Scrum принцип \"работющий код каждый спринт\"\n"+
                                                                                  "Что подразумевает частный и простой merge "),

                ("3. Как установить git-flow на macOS через brew?","Проверить через терминал установлен и обновлен Homebrew\n" +
                                                                 " в терминале brew install git-flow.\n"),

                ("4. Как проверить, установлен ли git-flow и его версия?","which git-flow выдает путь где установлен git-flow\n"+
                                                                           "git-flow version выдает версию"  ),


                ("5.Можно ли использовать git-flow без установки расширения? ","Можно в ручную создать ветки и управлять ими с помощью гит\n "),




                ("6.Как проинициализировать git-flow?","git flow init"),

                ("7.Какие ветки создаются при инициализации?","Две ветки получают названия\n"+
                                                                "main (или master) — стабильная ветка для релизов.\n"+
                                                               "develop — основная ветка для разработки.\n"+
                                                               "Остальные просто получают префикс.\n"+
                                                               "feature/ —  ветка фич.\n"+
                                                               "release/ — ветка релизов\n"+
                                                                "hotfix/ — ветка срочных исправлений.\n"),

                ("8.Что произойдёт, если репозиторий уже содержит другие ветки?","Если уже есть ветки то git flow init не повредит их\n"+
                                                                                 "Init настроит git flow,учитывая существующую структуру\n"+
                                                                                 "Если изначально были ветки main или developer\n"+
                                                                                 "они остаются вместо создания новых\n"+
                                                                                 "При отсутствии developer создается от main\n "+
                                                                                 "Если совпадают старые вспомогательные остаются\n"+
                                                                                  "а новые создаются с префиксом\n"),

                ("9.Почему develop должна быть защищена в CI/CD? ","Нужно поддерживать стабильность ветки develop\n "+
                                                                   "Все коммиты должны делаться через merge/pullRequests\n "+
                                                                   "Это снижает риск поломанного коммита и делает историю измений контролируемой\n"+
                                                                   "иначе весь процесс теряет смысл\n"),

                ("10.Как начать фичу?","Переключится на develop git checkout develop\n"+
                                       "Убедиться что локальная ветка соответствует удаленной git pull origin develop\n"+
                                       "Создать новую фичу ветку и перейти на неё git checkout -b feature/new-feature-name\n"+
                                       "Добавить код и сделать коммит git add . git commit -m\n"+
                                       "Снова проверить обновления из develop git pull origin develop\n"+
                                       "Запушить ветку и открыть Merge/PullRequests  git push origin feature/newFeature\n"+
                                       "Затем зайти в git host и запросить слияние\n"+
                                       "После удачного слияния удаляем ветку локально: git branch -d feature/newFeature\n "+
                                       "и на удаленном сервере git push origin --delete feature/newFeature\n"),

                ("11. Что делает feature finish?","Код из feature/NewFeature, объединяется с develop через merge/pullRequests\n"+
                                                   "Удаляется ветка локально и удаленно\n"),

                ("12.Что произойдёт при feature finish, если есть незакоммиченные изменения?","выйдет ошибка. Можно сделать коммит \n"+
                                                             "git commit -m\n"+
                                                             "Или сделать временные сохраненее\n"+
                                                             "git stash\n"+
                                                             "git flow finish feature/newFeature\n"+
                                                             "git pop - возвращение изменений\n"+
                                                             "можно удалить изменения\n"+
                                                             "git reset --hard\n"),

                ("13.Как работать с фичей вдвоём?","один разработчик создает feature\n"+
                                                "git flow feature start newFeature\n"+
                                                "Пушим ветку на сервер\n"+
                                                "git push -u origin feature newFeature\n"+
                                                "второй разработчик получает актуальные ветки\n"+
                                                "git fetch --all\n"+
                                                "переходим на feature\n"+
                                                "git checkout feature\n"+
                                                "подтягиваем последние изменения\n"+
                                                "git pull origin feature\n"),
                ("14.Как начать релиз?","Ветка develop стабильна\n"+
                                         "Тесты проходят (CI/CD зелёный)\n"+
                                         " Версия проекта обновлена\n"+
                                         "git checkout develop\n"+
                                         "git pull origin develop\n"+
                                         "git flow release start new\n"
                                         ),
                ("15.Что делает release finish","смержит release в main\n"+
                                                "смержит release в develop\n"+
                                                "удалит release\n"+
                                                "переключит на develop\n"),

                ("16.Что делать, если хотфиксы уже в master,\n"+
                "а develop отстаёт?",
                                                       "Есть два способа:\n"+
                                                       "Первый способ:\n"+
                                                       "Merge master в develop\n"+
                                                       "git checkout develop\n"+
                                                       "git pull origin develop\n"+
                                                       "git merge master\n"+
                                                       "git push origin develop\n"+
                                                       "Второй способ:\n"+
                                                       "Перенос хотфиксов по одному. Cherry pick хотфиксов\n"+
                                                       "git checkout develop\n"+
                                                       "git pull origin develop\n"+
                                                       "git cherry-pick <хеш хотфикса>\n"+
                                                       "git push origin develop\n"),

               ("18.Когда использовать hotfix?","Когда критический баг в production, а релиз ожидается не скоро\n"),

               ("19.Что делает hotfix finish","Завершает ветку hotfix\n"+
                                               "merge в master и develop\n"+
                                               "а также делается теги\n"+
                                               "возвращение в исходную ветку\n"),

                ("19.Какие есть альтернативы GitHub?","GitLab, Bitbucket, Azure DevOps"),

                ("20.Можно ли работать в команде без GitHub?","Если только использовать свой сервер или одну папку с проектом"),

                ("21.Что такое origin в контексте GitHub?","Алиас псевдоним для адреса вашего  на удаленного репозитория\n"+
                                                           "Сокращенная ссылка чтоб не вводить полный url адрес каждый раз\n"),

                ("22.Что происходит при git add .","В индекс(staging area) добавляются:\n"+
                                                    "Новые файлы untracked\n"+
                                                    "Измененные файлы modified\n"+
                                                    "Удаленные файлы deleted\n"+
                                                    "Технически:\n"+
                                                    "git вычисляет хеш каждого файла и сохраняет его временной зоне\n "+
                                                    "данные файлов записываются в объектную базу Git(папка .git/objects\n"),

                ("23.В чём разница между git commit и git commit -a","git commit требует git add\n"+
                                                                     "git commit -a добавляет в коммит  все изменения  tracked файлов\n"+
                                                                     "добавление новых untracked требует git add\n"),

                ("24.Что делает git add -p?","Это инструмент для интерактивного выбора изменений,\n"+
                                              "которые нужно добавить в staging area\n"+
                                              "Позволяет разбить изменения в файле на кусочки(hunks)\n"+
                                              "и выбрать какие попадут в коммит, а какие нет\n "+
                                              "не работает для новых файлов\n"),

                ("25.Что такое индекс в Git?","Индекс это промежуточная область(staging area или cache),\n"+
                                              "где Git временно хранит изменения перед тем как они попадут в коммит\n"+
                                              "Untracked - новый файл, еще не отслеживаемый\n"+
                                              "Modified - файл изменён, но не добавлен в индекс\n"+
                                              "Staged - изменения добавлены в индекс(готовы к коммиту)\n"+
                                              "Committed - изменения сохранены в репозиторий\n "+
                                              "git reset удаляет изменения в индексе\n"+
                                              "git diff --cached Показывает изменения добавленные в индекс\n"),

                ("26.Можно ли сделать коммит без git add","Можно с помощью команды git commit -a\n"),

                ("27.Что делает git checkout branch-name?","переключение на указанную ветку в git"),

                ("28.Как переключиться на предыдущий коммит?","git checkout Head~1\n"+
                                                              "git checkout SHA 1\n"+
                                                              "просмотр изменений git show HEAD~1\n"),

                ("29.Как вернуться к последнему коммиту после checkout на хеш? ","git switch - переключение на предыдущую\n"+
                                                                                  "git switch имя ветки\n"+
                                                                                  "git checkout имя ветки\n"+
                                                                                  "Если название ветки неизвестно\n"+
                                                                                  "git reflog в сообщение будет написано названии ветки\n"),

                ("30.В чём разница между git switch и git checkout?","switch новая команда для простого и понятного переключения между ветками\n"+
                                                                     "откажется работать если есть незакоммичные изменения\n"+
                                                                     "требуется явного --merge или --discard-changes\n"+
                                                                     "checkout попытается сохранить изменеия автоматически\n"),

                ("31.Как найти хеш нужного коммита?","git log\n"+
                                                     "--oneline - сокрашенная хеш и сообщение\n"+
                                                     "--graph с визуализации ветвления\n"+
                                                     "-n 5 последние пять коммитов\n"+
                                                     "-- author \n+" +
                                                     "--grep\n по сообщению"),

                ("32.Как создать аннотированный тег?","git tag -a имя -m \"сообщение\"\n"+
                                                      "git push origin имя - отправка\n"+
                                                      "git push origin --tags - отправка всех\n"),

                ("33.Как перейти к тегу?","git checkout имя\n"+
                                           "git switch --detach имя\n"),

                ("34.Как посмотреть все теги?","git tag\n"
                                               + "или git ls-remote --tags удаленные,\n"+
                                              "git tag -n аннотированные теги\n"),

                ("35.В чём разница между легковесным и аннотированным тегом?","Разницами между тегами заключается в способе их хранения и дополнительной информации\n"+
                                                                               "Легковесный тег Lightweight Tag это указатель на конкретный коммит\n"+
                                                                               "не содержит дополнительной информации\n"+
                                                                               "git tag имя тега\n"+
                                                                               "Аннотированный тег Annotated Tag это полноценный объект в Git, который хранит:\n"+
                                                                               "Имя тега\n"+
                                                                               "Сообщение(как у коммита)\n"+
                                                                               "Автор тега\n"+
                                                                               "Дату создания\n"+
                                                                               "Указатель на коммит\n+" +
                                                                               "Может быть подписан GPG(для верификации)\n"+
                                                                               "git tag -a имя тега -m соббщение тега\n"),

                ("36.Как отправить тег в удалённый репозиторий?","git push origin имя тега\n"+
                                                                 "git push origin --tags  -отправка всех тегов\n"),

                ("37.Как создать и сразу перейти в новую ветку?","git checkout -b имя ветки\n"+
                                                                 "git switch -c имя ветки\n"+
                                                                 "git checkout -b имя ветки источник\n"),

                ("38.Как посмотреть список всех веток?","git branch - только локальные\n"+
                                                        "git branch -r только удаленные ветки\n"+
                                                        "git branch -a все ветки\n"+
                                                        "git branch -vv подробный вывод(с коммитами и связями)\n"+
                                                        "git show-branch графическое представление\n"+
                                                        "git log --oneline --graph --all история всех веток в виде графа\n"),

                ("39.Как создать ветку от определённого коммита?","git branch имя ветки хеш\n"+
                                                                  "git checkout -b новая ветка хеш коммита - с переходом\n"+
                                                                  "git switch -c новая ветка хеш коммита - с переходом\n"),

                ("40.Что делает git switch -c name?","создание ветки с переходом\n"),

                ("41.Где хранятся ссылки на ветки?","Вся информации о ветках локальных и удаленных хранится в папке .git\n"+
                                                    "Каждая ветка это файл, содержащий SHA-1 хеш последнего коммита в этой ветке\n"+
                                                    ".git/refs/heads\n"+
                                                    ".git/refs/remotes/origin\n"),

                ("42.Что делает git merge feature?","объединяет изменения из ветке feature в текущую\n"+
                                                     "git checkout main\n"+
                                                     "git merge feature\n"+
                                                    "Fast-Forward Merge(быстрая перемотка)\n"+
                                                    "Если main не имеет новых коммитов после ответвления feature:\n"+
                                                    "Git просто перемещает указатель main на последний указатель feature\n"+
                                                    "История остается линейной(без нового коммита)\n"+
                                                    "Recursive merge(Рекурсивное слияние)\n"+
                                                    "Если в main и feature есть изменения\n"+
                                                    "Git создает новый коммит слияния(merge commit)\n"+
                                                    "В истории появляется развилка(ветвление и соединение)\n"+
                                                    "Конфликты слияния. Если в main и feature затрагивают одни и те же строки \n"+
                                                    "Git останавливает процесс и сообщает от конфликте\n"+
                                                    "Нужно в ручную исправить конфликт,затем завершить слияние\n"+
                                                    "git add .\n"+
                                                    "git merge --continue\n"+
                                                    "Флаги:"+
                                                    "--no --ff всегда создает коммит сляиния\n"+
                                                    "--squash - объединяет все изменения в один коммит сливаемой ветки\n"+
                                                    "--abort - отменяет слияние при конфликтах\n"),

                ("43.Что такое fast-forward merge?","Это тип слияния в Git, при котором история веток остается линейной, не создает новый коммит слияния\n+" +
                                                    "Он возможен, если целевая ветка не получила новых изменений с момента создания сливаемой ветки\n"+
                                                    "а просто перемещает указатель текущей ветки вперед до конца целевой\n"
                                                    ),

                ("44.Как отменить конфликтное слияние?","Если конфликты не разрешены git merge --abort\n"+
                                                        "Кофликты разрешены, но нет коммита  git reset --hard HEAD\n"+
                                                        "Merge уже закомичен git reset --hard HEAD~1(локально)\n"+
                                                                             "git revert -m 1 <commit> если был отправлен\n"),

                ("45.Как увидеть коммиты, которые будут вливаться?","git log имя1 имя2\n"+
                                                                    "git log --online --graph --all графический просмотр\n"),

                ("46.Что делает git merge --no-ff","выполняет слияние веток в Git всегда создавая новый коммит\n"+
                                                    "даже если можно сделать fast-forward\n"),

                ("47.Как связать локальный проект с GitHub?","git init\n"+
                                                              "git add .\n"+
                                                              "git commmit -m\"сообщение\"\n"+
                                                              "git remote add origin ссылка\n"+
                                                              "git push -u origin main\n"),

                ("48.Как отправить первую версию на GitHub?", "git init\n"+
                                                              "git add .\n"+
                                                              "git commmit -m\"сообщение\"\n"+
                                                              "git remote add origin ссылка\n"+
                                                              "git push -u origin main\n"),

                ("49.Как переименовать удалённый репозиторий?","В репозитории GitHub Settings - Repository name - Rename\n"+
                                                               "Обновление локального git remote set-url origin новая ссылка\n"),

                ("50.Как проверить адрес удалённого репозитория?","git remote get-url origin\n"),

                ("51.Как удалить привязку к удалённому?","git remote remove origin \n"+
                                                         "git remote rm origin старая версия\n"+
                                                         "git remote -v проверка"),

                ("52.Какие типы объектов есть в Git?","Есть 4 основных типа обьектов в Git\n"+
                                                      "которые хранят историю и структуру репозитория\n"+
                                                      "Они лежат в папке .git/objects и имеют хеш индекаторы SHA-1\n"+
                                                      "Blob Binary Large Object:\n"+
                                                      "В нем содержимое файлов в сжатом ввиде\n"+
                                                      "Tree (Дерево):\n"+
                                                      "Структуру каталогов (аналогично папкам в файловой системе)\n"+
                                                      "Ссылки на blobs(файлы) и другие trees(подкаталоги)\n"+
                                                      "Метаданные: имена файлов, права доступа\n"+
                                                      "Commit(Коммит)\n"+
                                                      "Ссылку на tree (состояние файлов на момент коммита)\n"+
                                                      "Ссылки на родительские коммиты. Коммитов может быть один или два(при слияние)\n"+
                                                      "А также автора, дату и сообщение\n"+
                                                      "Tag(Аннотированный тег):\n"+
                                                      "Ссылку на коммит(обычно версию)\n"+
                                                      "Имя тега, автора, дату, описание\n"),

                ("53.Где они физически хранятся объекты Git?","Все объекты хранятся в .git/objects\n"+
                                                  "git cat-file -t sha или tag показать тип объекта\n"+
                                                  "git cat-file -p показать тип объекта\n"),

                ("54.Что такое Blob?","Binary Large Object. Один из четырех основных типов объектов в Git\n"+
                                       "которое хранит содержимое файла\n"+
                                       "Создается командой git add\n"+
                                       "Вычисляется SHA1 и сохраняет сжатые данные\n"),

                ("55.Что такое Tree?","Это объект Git которое описывает структуру каталогов и файлов\n"+
                                       "Он связывает blob объекты и другие tree объекты \n"+
                                       "в единую файловую систему\n"),

                ("56.Что такое Commit-объект?","Это объект Git, который фиксирует состояние репозитория\n"+
                                               "в определенный момент времени. Он хранит:" +
                                               "Снимок файловой структуры(через tree объекты)\n"+
                                               "Метаданные: автора, дату, сообщение и ссылку на родительские коммиты\n"),

                ("57.Что делает команда git init folder-name, если папка уже существует?","Если папка пустая:\n"+
                                                                                          "Создает новый git репозиторий в указанной папке\n" +
                                                                                           "Git создаст скрытую подпапку .git\n"+
                                                                                           "и инициализирует в ней репозиторий\n"+
                                                                                           "Иначе выдаст ошибку\n"),

                ("58.В чём принципиальная разница между git init и git clone?","init создает новый репозиторий с нуля\n"+
                                                                               "clone копирует существующий репозиторий(локальный или удаленный)\n"),

                ("59.Можно ли использовать git init внутри уже инициализированного репозитория?","Git проигнорирует команду git init и выдаст предупреждение\n"),

                ("60.Что хранится в папке .git после git init?"," два основных файла:\n"+
                                                                "HEAD указывает на текущую ветку\n"+
                                                                "config локальные настройки репозитория\n"+
                                                                "Служебные папки:\n"+
                                                                "hooks скрипты для автоматизации\n"+
                                                                "info файл для игнорирования файлов\n"+
                                                                "objects хранилище объектов Git\n"+
                                                                "refs ссылки на ветки и теги\n"),

                ("61.Как проверить, инициализирован ли каталог как Git-репозиторий?","проверить есть ли папка .git\n"+
                                                                                     "git status\n"+
                                                                                     "git branch\n"+
                                                                                     "git remote -t\n"),

                ("62.Что произойдёт, если выполнить git clone <https://url.git> . в уже инициализированной папке?","Выдаст ошибку\n"),

                ("63.Как клонировать репозиторий без загрузки содержимого (bare)?","git clone --bare url\n"),

                ("64.Что означает FolderName в команде git clone url FolderName?","Создаст папку и клонирует туда репозиторий\n"+
                                                                                  "Если папка есть то выдаст ошибку\n"),

                ("65.Как клонировать только определённую ветку?","git clone --branch dev --single-branch Url - клонирование одной ветки\n"+
                                                                 "git fetch origin other-branch - добавление ветки позже\n"),

                ("66.Что делает параметр --depth при клонировании? ","Позволяет клонировать репозиторий без полной истории\n"+
                                                                     "загружая только последние N коммитов указанной ветки\n"+
                                                                     "Это называется поверхностным клонированием(shallow clone)\n"),

                ("67.Чем отличается git diff от git diff --staged?","git diff сравнивает рабочую директорию и индекс(Staging Area)\n"+
                                                                    "git diff --stage сравнивает индекс и последний коммит\n"+
                                                                    "git diff HEAD рабочую директорию vs последний коммит\n"),

                ("68.Что покажет git diff master...feature?","Сравнивает изменения,внесенные в ветку feature\n"+
                                                             "Относительно точки расхождения с веткой master\n"+
                                                             "git diff origin/master...origin/feature\n удаленной ветки\n"),

                ("69.Что произойдёт, если файл изменён, но не проиндексирован? Где он появится в git status?","файл будет строке modified\n"),

                ("70.Что делает флаг --name-only у git diff?","Упрощает вывод, показывая только имена изменных файлов, без деталей самых изменений\n"+
                                                               ""),

                ("71.Почему git diff игнорирует неотслеживаемые файлы?","Потому что до добавления Git не знает про них\n"+
                                                                        "--no--index для принудительного сравнения\n"),

                ("72.Что делает git add -p и зачем это нужно?","запускает интерактивный режим добавления изменений в индекс\n"+
                                                               "Она позволяет выборочно добавлять части файлов(отдельные части, а не весь файл целиком\n"+
                                                               "y - yes добавить в текущий кусок в staging\n"+
                                                               "n - no пропустить кусок\n"+
                                                               "s - split разделить на более мелкие части\n"+
                                                               "e  - edit в ручную отредактировать кусок перед добавлением\n"+
                                                               "q - quit выйти из режима\n"+
                                                               "? - справка по всем опциями\n"),

                ("73.Чем отличается git add -i от git add -p?","git add -i работает с целыми файлами\n"+
                                                               "Имеет текстовое меню с опциями\n"+
                                                               "update - добавить файлы в staging\n"+
                                                               "revert - убрать файлы из staging\n"+
                                                               "add untracked - добавить неотслеживаемые файлы\n"+
                                                               "patch перейти в режим git add -p для выбранного файла\n"),

                ("74.Что произойдёт, если после git add . изменить файл?","Будет две версии файла одна в staging area,\n"+
                                                                           "другая в рабочей директории\n"),

                ("75.Как удалить файл из индекса, но оставить его в рабочей директории?","git rm --cached\n"+
                                                                                           ""),

                ("76.Можно ли добавить в индекс только часть изменений одного файла?","git add -p\n"+
                                                                                      "git add -e ручное редактирование патчей\n"+
                                                                                      "git add -i добавление отдельных строк\n"),

                ("77.Что удаляет git reset --hard?","Отменить все изменения до последнего коммита\n"+
                                                    "git reset hard <хеш коммита> отменить все изменения до коммита\n"+
                                                    ""),

                ("78.Как отменить только последние изменения, оставив индекс нетронутым?","git restore имя\n"+
                                                                                          "git restore .\n"+
                                                                                          "git checkout --\n"),

                ("79.Зачем нужен git clean -df и что он удаляет?","Он удаляет untracked файлы\n"+
                                                                   "d - флаг для удаления директорий\n"+
                                                                   "f - флаг опасных операций\n"+
                                                                   "x - флаг удаления из списка gitignore\n"),

                ("80.Что будет, если сделать git reset без аргументов?","покажет список флагов для git reset\n"),

                ("81. Чем reset --hard отличается от revert","revert создает коммит отменяющий изменения\n"+
                                                             "сохраняет историю коммитов, добавляя новый\n"),

                ("82.Что делает команда git commit -a -m \"msg\" и чем она отличается от git commit -m \"msg\"?",""+
                                                          "-a позволяет добавить изменения в файлах без git add .\n"),

                ("83.Можно ли закоммитить новые файлы с помощью git commit -a","новые файлы обязательно нужно добавлять в индекс\n"),

                ("84.Как отменить последний коммит, не удаляя изменения в рабочей директории?","git reset --soft HEAD~1\n"+
                                                                                               "git reset --mixed HEAD~1\n"+
                                                                                               "git revert HEAD\n"),

                ("85.В чем разница между git reset --soft, --mixed и --hard","--soft Перемещает указатель, не трогает изменения\n"+
                                                                             "--mixed Перемещает указатель, изменения становятся unstaged\n"+
                                                                             "--hard Перемещает указатель, сбрасывает изменения\n "),

                ("86.Что делает команда git commit --amend?","позволяет изменить коммит без создания нового\n"+
                                                             "-m изменить сообщение\n"+
                                                             "Git не удаляет старый коммит,а создает новый\n"+
                                                             "старый коммит становится недостижимым\n"),

                ("87.Что делает git revert HEAD --no-edit?","Выполняет отмену последнего коммита,\n"+
                                                            "создавая новый коммит с обратными изменениями\n"+
                                                            "при этом автоматически используя стандартное сообщение коммита\n"+
                                                            "без открытия редактора коммита\n"),

                ("88.В каких случаях git revert безопаснее, чем git reset?","когда коммит отправлен на удаленный репозиторий\n"+
                                                                            "нужно сохранить историю изменений\n"+
                                                                            "когда работают в одной ветке больше одного разработчика\n"+
                                                                            "reset может удалить измения другого разработчика\n"+
                                                                            "когда нужно отменить конкретный коммит, \n"+
                                                                            "reset удалит всё до указанного коммита\n"+
                                                                            "когда нужно уменьшить количество конфликтов\n"),

                ("89.Что произойдёт после выполнения git reset --hard @~2","полный сброс состояния репозитория до 2 коммита\n"),

                ("90.Что делает git reset --keep @~ и когда он полезен?","безопасная альтернатива git reset --hard\n"+
                                                                         "Перемещает указатель HEAD на предыдущий коммит\n"+
                                                                         "Сохраняет незакомиченные изменения в рабочей директории,\n "+
                                                                         "если не конфликтуют с целевым коммитом\n"+
                                                                         "сбрасывает индекс\n"),

                ("91.Какой командой можно безопасно заменить последний коммит новым, не создавая отдельного коммита отката?",""+
                                                                 "сделать изменения и выполнить команду git commit --amend\n"+
                                                                 "если только нужно изменить сообщение то git commit --amend -m\n"+
                                                                 "изменить автора git commit --amend --reset-author\n"+
                                                                 "если изменений много то git reset --soft HEAD^ + новый коммит\n"),

                ("92.Что делает git checkout b9533bb?","Переключение рабочей директории на состояние коммита с указанным хешом\n"),

                ("93.Как вернуться обратно в ветку main после переключения на старый коммит?","git checkout имя ветки\n"+
                                                                   "git switch main\n"+
                                                                   ""),

                ("94.Чем опасен detached HEAD и как его \"обезвредить\"?","Новые коммиты висят в воздухе\n"+
                                                                          "Они не принадлежат ни одной ветке и могут быть потеряны\n"+
                                                                          "если не создать новую ветку\n"+
                                                                          "Git не предупредит об удалении\n"+
                                                                          "Чтоб обезвредить detached HEAD\n"+
                                                                          "вернуться в ветку\n"+
                                                                          "Если есть изменения, но не закомичены, то сохранить изменения в новой ветке\n"+
                                                                          "Если закомичены то сделать новую ветку, а потом merge\n"+
                                                                          "Если изменения не нужны просто выйти\n"+
                                                                          "коммиты можно найти только через git reflog\n"+
                                                                          "найти хеш коммита git reflog\n" +
                                                                          "создать ветку от коммита git branch saved-commits хеш\n"),

                ("95.Как создать новую ветку, начиная с произвольного коммита?","git branch имя хеш\n"+
                                                                                "git checkout -b имя хеш\n"),

                ("96.Что произойдёт после git checkout master?","Git переключится на ветку master\n"+
                                                                "и рабочая директория обновится до последнего сотояния коммита этой ветки\n"+
                                                                "Если в текущей ветки были незакомиченные изменения,\n"+
                                                                "Git попытается сохранить изменения или выдаст предупреждения\n"+
                                                                "Указатель HEAD переместится на ветку master\n"),

                ("97.Что делает git checkout 5589877 index.html?","Выполняет восстановление кокретного файла из указанного коммита\n"+
                                                                  "в рабочую директорию и индекс\n"+
                                                                  "альтернативный вариант:\n"+
                                                                  "git restore --source хеш --worktree имя файла\n"),

                ("98. Можно ли отменить это восстановление?(git checkout sha1 имя файла)","Если еще не закомичены:\n"+
                                                             "вернуть файл к последней закомиченной версии\n"+
                                                             "git checkout HEAD --имя файла\n"+
                                                             "git restore имя файла\n"+
                                                             "отменить все изменения,если они не были добавлены в staging\n"+
                                                             "git checkout --имя файла\n"+
                                                             "Если уже закомитили восстановленый файл:\n"+
                                                             "Создать новый коммит, отменяющий изменения\n"+
                                                             "git revert HEAD\n"+
                                                             "Откатить последний коммит(если он не был отправлен в удаленный коммит)\n"+
                                                             "git reset --soft HEAD~1 отмена коммита, но сохранение изменений в stage\n"+
                                                             "git reset HEAD имя файла убирает файл из stage\n"+
                                                             "git checkout --имя файла\n"+
                                                             "или полный откат коммита git reset --hard HEAD~1\n"+
                                                             "Чтоб вернуть файл к состоянию до всех изменений(включая staged)\n"+
                                                             "git reset HEAD имя убирает из staged\n"+
                                                             "git checkout --имя  сбрасывает изменения в рабочей директории\n"+
                                                             ""),

                ("99.Как перенести изменения из одного коммита в другую ветку?","git cherry-pick если нужно перенести конкретный коммит\n"+
                                                                                "переключение на целевую ветку git checkout имя\n"+
                                                                                "git cherry-pick хеш коммита\n"+
                                                                                "git merge полное слияние\n"+
                                                                                "git rebase имя целевой ветки когда нужно перебросить коммиты одной ветки на другую\n"+
                                                                                "git checkout <коммит> -- <файлы> если нужны только некоторые файлы\n"+
                                                                                ""),

                ("100.Что произойдёт, если сделать git cherry-pick master~2..master?","Git перенесет два последних коммита из ветки мастер\n"+
                                                                                     "master~2 начало отсчета коммитов\n"+
                                                                                     ".. диапазон\n"+
                                                                                     "master окончание диапазона\n"+
                                                                                     "создаст новый коммит, а потом добавит два коммита в текущей ветке\n"),

                ("101.Что делать при конфликте во время cherry-pick?","При возникновении конфликта слияния Git останавливает операцию и требует ручного разрешения конфликта\n"+
                                                                      "В ручную разобрать в редакторе конфликт\n"+
                                                                      "git add .\n"+
                                                                      "git cherry-pick --continue\n"+
                                                                      "git cherry-pick --abort вернет состояние до выполнения команды\n"+
                                                                      "git cherry-pick --skip пропустить текущий конфликтный коммит\n"),


                ("102.Что произойдёт при выполнении команды git rm text.txt?","Полностью удалится файл из рабочей директории и индекса\n"+
                                                                              ""),

                ("103.В чем отличие git rm и git rm --cached","-- cached Файл будет удален только из индекса\n"),

                ("104.Что делает git rm -f и зачем нужен флаг -f","Принудительно удаляет файл из рабочей директории и индекса,\n"+"" +
                                                                  "игнорирует любые предуждения или конфликты\n"),

                ("105.Когда удобно использовать git rm --cached?","Полезна в ситуациях когда нужно перестать отслеживать изменения файлов\n"+
                                                                   "Добавление файлов в gitignore после того как его закомитили\n"+
                                                                   "Удаление случайно добавленных файлов\n"+
                                                                   "Прекращение отслеживания без удаления файла\n"),

                ("106.Что делает git rm ind*?","Удаляет файлы из рабочей директории и индекса, соответствующие шаблону\n"+
                                               "Работает только с отслеживаемыми файлами,иначе выдаст ошибку\n"+
                                               "для удаления файлов с незакомиченными изменениями нужен флаг -f\n"+
                                               "-r рекурсивное удаление в поддерикториях\n "),

                ("107.Что делает команда git branch -f master 5589877?","Принудительно перемещает ветку master на указанный коммит\n"+
                                                                        "Все коммиты после указанного теряют связь с веткой\n"),

                ("108.Как создать ветку new_branch на два коммита назад от master","git log master --oneline -3 поиск нужно коммита\n"+
                                                                                   "git branch имя ветки имя SHA1\n"+
                                                                                   "git branch имя master~2\n"+
                                                                                   "git checkout имя master~2\n"),

                ("109.Чем git checkout -b отличается от git checkout -B?","-b выдаст ошибку при перезаписи\n"+
                                                                          "-B перезапишем\n"),

                ("110.Что делает git branch -d hotfix?","Удаляет ветку при условии что она была слита в другую ветку\n"+
                                                        "иначе будет ошибка\n"+
                                                        "D удаление в любом случае\n"),

                ("111.Как посмотреть ветки, которые не были слиты в текущую?","Основной способ: git branch --no-merged\n"+
                                                                              "git branch --no-merged проверка конкретной\n"+
                                                                              "git branch -r --no-merge удаленные ветки\n"+
                                                                              "git branch merge просмотр слитых веток\n"+
                                                                              "git log --online --no-merge имя имя текущей\n"+
                                                                              "git log --graph --oneline --all графическое представление\n"),

                ("112.Что делает git stash?","Временно сохраняет незакомиченные изменения в рабочей директории\n"+
                                              "-a изменения в индексе\n"+
                                              "- include-untracked включая новые файлы\n"),

                ("113.Что произойдёт при git stash pop","Git возьмет самый свежий stash\n"+
                                                        "Применит изменения к рабочей директории и индексу\n"+
                                                        "Удаляет stach из списка\n"+
                                                        "При конфликте:\n"+
                                                        "Git останавливает операцию\n"+
                                                        "Stach не будет удален\n"+
                                                        "разрешить конфликт в ручную\n"+
                                                        "git add. \n"+
                                                        "git stach drop для удаления\n"+
                                                        "git stach apply не удаляет stach\n"),

                ("114.Можно ли сделать несколько stash-записей?","В Git можно делать несколько stach\n"+
                                                                 "они сохраняются ввиде стека\n"+
                                                                 ""),

                ("115.Что произойдёт, если после git stash создать новую ветку?","Stach останется доступным в новой ветке\n"+
                                                                              "Stach в Git привязан к репозиторию,а не конкретной ветке\n"+
                                                                              ""),

                ("116.Как посмотреть список всех stash-записей?","git stach list\n"),

                ("117.Как посмотреть URL удалённого репозитория?","git remote -v\n"+
                                                                  "git remote --verbose\n"+
                                                                  "конкретного git remote get-url origin\n"+
                                                                  "git remote просмотр всех\n"+
                                                                  "git remote show origin подробный просмотр\n"),

                ("118.Что делает git remote remove origin?","Удаляет связь вашего репозитория с удаленным\n"+
                                                            "git remote rm origin сокращеная\n"+
                                                            ""),

                 ("119.Что делает git push origin :old_branch_name new_branch_name?","Удаляет старую удаленную ветку\n"+
                                                                                     "Пушит локальную ветку на удаленный репозиторий\n"+
                                                                                     "Локальные ветки остаются, удаляется только удаленная\n"+
                                                                                     ""),

                 ("120.Как посмотреть удалённые ветки?","git branch -r\n"+
                                                        "git remote show origin подробный список\n"+
                                                        "git branch -a список локальных и удаленных\n"+
                                                        ""),

                 ("121. Что делает git remote show origin?","Выводит подробную информацию о подключенном удаленном репозитории\n"+
                                                            "URL\n"+
                                                            "отслеживаемые ветки\n"+
                                                            "настройки и статус синхронизации\n"),

                 ("122.Чем git rebase отличается от git merge?","git merge создает новый коммит слияния\n"+
                                                                "История остается нелинейной\n"+
                                                                "git rebase перемешает коммиты одной ветки поверх другой\n"+
                                                                "история остается линейной\n"+
                                                                "merge безопасен для командной работы\n"+
                                                                "Конфликты разрешаются один раз\n"+
                                                                "Для публичных веток\n"),

                 ("123.Почему использование git rebase может привести к конфликтам?","Переписывает историю, а не объединяет ее\n"+
                                                                                     "Применяет каждый коммит отдельно, увеличивая точки потенциальных конфликтов\n"+
                                                                                     "Требует больше ручной работы, но дает чистую историю\n"),

                 ("124. Как выполнить rebase ветки с основной веткой?","git rebase main\n"+
                                                                       ""),

                 ("125.Как отменить git rebase, если возникли проблемы с конфликтами?","git rebase --abort\n"),

                 ("126.Как продолжить git rebase после разрешения конфликтов?","git add .\n"+
                                                                                "git rebase --continue\n"),

                 ("127. Что делает команда git rebase --onto master feature","Выполняет сложную операцию перебазирования,\n" +
                                                                              "позволяет перенести часть коммитов из одной ветки в другую\n"+
                                                                              "минуя промежуточные изменения\n"),

                 ("128.Когда и почему полезно использовать git rebase --onto","Когда нужно перенести только часть коммитов\n"+
                                                                              "Когда нужно отрезать ненужные коммиты из истории\n"+
                                                                              "Когда нужно перебазировать несколько веток\n"+
                                                                              "Когда нужно исправить ошибку в базой ветке\n"+
                                                                              "Когда нужно разделить историю\n"),

                 ("129. Как использовать git reflog, чтобы найти коммит, на который можно откатить ветку после неудачного rebase?",""+
                                                                              "git reflog хронологический список всех действий,\n"+
                                                                              "включая переключение веток, коммиты и rebase\n"+
                                                                              "поиск стабильного коммита\n"+
                                                                              "git reset --hard HEAD@{2} или хеш\n"+
                                                                              "или создать ветку git branch HEAD@{2}"),

                 ("130.Как вернуться к коммиту до выполнения git rebase","\"git reset --hard HEAD@{2} или хеш\\n\"+\r\n " +
                                                                              "\"или создать ветку git branch HEAD@{2}"),


                 ("131.Что делает команда SELECT * FROM table_name?","Выбирает все столбцы из таблицы\n"+
                                                                      "* это wildcard(символ подстановки)\n"+
                                                                      "используют обычно для тестирования\n"+
                                                                      "в продакшен использует конкретные столбцы"),

                 ("132.Чем отличается SELECT DISTINCT от обычного SELECT?"," Distinct возвращает только уникальные значения"),

                 ("133.Можно ли в SELECT запросе использовать несколько таблиц? Как это сделать?","Можно после FROM через запятую,\n"+
                                                                                     "а можно осмысленно через JOIN"),

                 ("134.Что делает оператор INNER JOIN?","INNER JOIN(внутреннее соединение) - это оператор, который объединяет строки\n"+
                                                         "из двух таблиц только тогда, когда выполняется условие связи\n"+
                                                         "Если совпадений нет, то такие строки не попадают в результат\n"+
                                                         "можно написатьь кратко JOIN\n"),

                 ("135.Чем отличается LEFT JOIN от RIGHT JOIN?","Оба оператора объединения, но работают в разных направлениях\n"+
                                                                "LEFT JOIN все строки из левой таблицы + совпадения из правой,\n " +
                                                                "если нет совпадения в правой части будет NULL\n"+
                                                                "RIGHT JOIN все строки из правой таблицы + совпадения из левой,\n"+
                                                                "если нет совпадения то в левой части NULL\n"),

                 ("136.Можно ли объединить более двух таблиц? Приведите пример.","Таблицы можно объединить последовательными JOIN\n"+
                                                                   "SELECT users.name,\n"+
                                                                    "products.name,\n"+
                                                                    "orders.quantity\n"+
                                                                    "orders.order_date\n"+
                                                                   "FROM users\n"+
                                                                   "INNER JOIN orders ON users.id=orders.id\n"+
                                                                   "INNER JOIN products ON orders.product_id=products.id\n"),

                 ("137.Что делает GROUP BY в SQL?","Это оператор, который группирует строки по указанным столбцам\n"+
                                                   "и позволяет применять к ним агрегатные функции(COUNT,SUM,AVG,MAX,MIN)\n"+
                                                   "Все неагрегированные поля в SELECT должны быть в GROUP BY\n"),

                 ("138.Как использовать COUNT с GROUP BY в SQL","Функция COUNT совместно с GROUP BY позволяет подсчитывать количестов\n"+
                                                                "строк в каждой группе. Это полезно для анализа данных,например:\n"+
                                                                "Сколько заказов у клиента?\n"+
                                                                "Сколько товаров в каждой категории?\n"+
                                                                "Сколько сотрудников в каждом отделе?\n"),

                 ("139.Что возвращает функция AVG() и как она используется?","Это агрегатная функция,которая вычисляет среднее арифмитическое по числовым столбцам\n"+
                                                                             "Если применяется с GROUP BY вычисляет среднее по группам\n"+
                                                                             "Практическое применение:\n"+
                                                                             "Расчет средней зарплаты по отделам\n"+
                                                                             "Анализ среднего времени доставки\n"),

                 ("140.Что такое подзапрос и когда его следует использовать?","Подзапрос(subquery) - это SQL-запрос, вложенный внутрь друго запроса\n"+
                                                                              "(SELECT,FROM, WHERE, HAVING, INSERT, UPDATE, DELETE)\n"+
                                                                              "Подзапросы полезны:\n"+
                                                                              "Фильтровать данные на основе другого запроса(WHERE, HAVING)\n"+
                                                                              "Создавать временные таблицы для основного запроса(FROM)\n"+
                                                                              "Заменить JOIN в сложных сценариях\n"+
                                                                              "Обновлять или удалять данные на основе условий\n"+
                                                                              "Типы подзапросов:\n"+
                                                                              "1. по месту использования:\n"+
                                                                              "  В WHERE, HAVING возвращает одно значение или список\n"+
                                                                              "  В FROM возвращает таблицу\n"+
                                                                              "  В SELECT возвращает одно значение для каждой строки\n"+
                                                                              "2. По количеству возвращаемых значений:\n"+
                                                                              "  Скалярный(1 столбец, 1 строка) используется с =,<,>\n"+
                                                                              "  Список значений(1 столбец, много строк) используется IN,ANY,ALL\n"+
                                                                              "  Табличный(много строк и столбцов) используется в FROM\n"+
                                                                              "Плюсы:\n"+
                                                                              "   Упрощает сложные запросы разбивая их на части\n"+
                                                                              "   Позволяют избежать многоступенчатых JOIN\n"+
                                                                              "   Читаемы для многоэтапной логики\n"+
                                                                              "Минусы:\n"+
                                                                              "   Могут быть медленнее JOIN(если СУБД не оптимизирует их)\n"+
                                                                              "   Вложенные подзапросы снижают читаемость\n"),

                 ("141. Вопрос: Чем отличается подзапрос в SELECT от подзапроса в WHERE?","Подзапрос в SELECT используется, когда нужно добавить вычисляемое поле к результату запроса\n"+
                                                                                          "Подзапрос WHERE ипользуется для фильтрации строк основоного запроса\n"+
                                                                                          ""),

                 ("142.Что делает функция CONCAT() в SQL?","Это строковая функция которая склеивает две и более строк\n"+
                                                           "|| для Postgres\n"),

                 ("143.Как используется функция NOW() в SQL?","Возвращает текущую дату и время\n"),

                 ("144.Как извлечь только год из даты с использованием функции SQL?","SELECT EXTRACT(YEAR FROM дата_столбец) AS год FROM\n"+
                                                                                     "SELECT DATE_PART('year',дата_столбец) AS год FROM\n"),

                 ("145. Что такое домены в SQL? Пример","Домены в SQL объединяет тип данных и ограничения в одно\n"+
                                                   "CREATE DOMAIN название AS text constraint format CHECK(\n"+
                                                   "VALUE~ '^d{5}$' OR VALUE ~'^d{5}-'d{4}$'"),

                 ("146.COLLATE Что это? стандартный пример","Определяет правила сортировки и сравнения\n"+
                                                            "en_US.UTF-8\n"),

                 ("147.Пример создания сортировки","Создание регистронезависимой сортировки\n"+
                                                   "CREATE COLLATION en_us_ci(\n"+
                                                   "provider = icu,\n"+
                                                    "locale = 'en-US-u-ks-level1'\n"+
                                                    "deterministic = false\n"),
                 ("148.Что сделает команда SELECT md5('hello world)?","Создаст хеш код. Небозапасен\n"+
                                                                       "Лучше использовать sha256 для безопасности\n"+
                                                                       "или uuid для экономии места\n"),

                 ("149. Тип данных для хранения файлов в PostgreSQL?","bytea"),

                 ("150. Тип uuid. Что это такое?","Универсальный уникальный идентификатор. Занимает 16 байт.\n"+
                                                  "Отображается как строка и может быть приведен к строке\n"+
                                                  "но как строка занимает больше места\n"),

                 ("151. Команда для вызова рандомного uuuid","SELECT get_random_uuid()"),

                 ("152. Сколько версий uuid существует? В какой версии есть время создания","Версий 8. В 7 есть временнная ментка. По ней можно сортировать"),

                 ("153. Что такое BOOLEAN? Какие состояния бывают?","Это логический тип данных размером 1 байт,который хранит истину,ложь или неизвестность\n"),

                 ("154. Какие варианты написания значений в BOOLEAN?","TRUE FALSE\n"+
                                                                       "'true' 'false'\n"+
                                                                       "'t' 'f'\n"+
                                                                       "'1' '0'\n"+
                                                                       "'on' 'off'\n"+
                                                                       "'yes' 'no'\n"+
                                                                       "NULL"),

                 ("155. Как создать перечисление ENUM и добавить новый тип","CREATE TYPE название AS ENUM ('first','second','third')\n"+
                                                                            "ALTER TYPE название ADD VALUE 'four'"),


                 ("156. Особенности сортировки ENUM","Сортировка происходит по порядку добавления В ENUM\n"+
                                                     "С помощью команды ALTER TYPE название ADD VALUE 'first' before 'zero'\n"+
                                                     "'after' для добавления после\n"),

                 ("157. Что за формат timestamp? Его особенности?","Это временная ветка. Бывает с указанием часового пояса и без\n"+
                                                                   "timestamp without time zone\n"+
                                                                   "timestamp with time zone\n"+
                                                                   "timestamptz с часовым поясом\n"+
                                                                   "timestamptz(0-6) точность в милисекундах, 6 по умолчанию\n"+
                                                                   "SELECT NOW()::timestamp получение текущего времени\n"),

                 ("158. Форматы дата и время?","ISO 8601 2024-01-31 15:30:08.234\n"+
                                               "может быть Т между датой и время\n"+
                                               "z в конце это гринвич\n"+
                                               "-06:00 указание часового пояса\n"),

                 ("159. Посмотреть и настроить формат даты","show DateStyle стандарт ISO,DMY\n"+
                                                            "установка своего DateStyle:\n"+
                                                            "set DateStyle= 'ISO, MDY'"),

                 ("160. Работа с часовым поясом. Как посмотреть и установииь часовой пояс","show time zone проверить часовой пояс\n"+
                                                  "set time zone 'America/Chicago'\n"+
                                                  "ALTER database название SET time zone 'UTC' время базы данных\n"+
                                                  "show config_file редактирование файла настройки\n"+
                                                  "время::timestampz at time zone 'CDT' установка времени по названию пояса\n"+
                                                  "at time zone '-06:00'  установка через разницу. Делает перевод в обратную сторону\n"+
                                                  "at time zone interval '-06:00' корректное смещение\n"),

                 ("161.Посмотреть все часовый пояса","SELECT * FROM pg_timezone_names"),

                 ("162. Формат даты и времени отдельно","DATE без часового пояса\n"+
                                                        "TIME with time zone\n"+
                                                        "TIME without time zone\n" +
                                                        "CURRENTDATE текущая дата\n"+
                                                        "LOCALTIME текущее время без указания времени\n"),

                 ("163. Что такое INTERVAL интервалы? Как создать интервал?","Интервал это тип данных, представляющий отрезок в шкале типа этих данных. Удобно использовать например при бронировании\n"+
                                                       "SELECT '' ::interval создание интервала\n"+
                                                       "show intervalstyle стиль отображения интервала\n"+
                                                       "SET intervalstyle = установка стиля отображения интервала\n"),

                 ("164. Как посмотреть добавленные данные после INSERT INTO VALUES?","VALUES() RETURNING *"),


                 ("165. Как создать идентификатор?","SERIAL PRIMARY KEY\n"+
                                                    "BIGSERIAL PRIMARY KEY\n"+
                                                    "BIGINT GENERATED ALWAYS AS IDENTITY PRIMARY KEY"),

                 ("166. Как создать последовательность?","CREATE SEQUENCE название\n " +
                                                         "AS BIGINT\n"+
                                                         "INCREMENT 1 шаг\n"+
                                                         "START 1\n"+
                                                         "MINVALUE 1\n"+
                                                         "CACHE сколько кешировать прежде чем начнет запршивать новые\n"),

                 ("167. Функции для SEQUENCE","SELECT nextval('название') возвращает следующее значение и увеливает последовательность\n"+
                                              "SELECT setval('название',2) устанавливает текущее значение последовательности\n"+
                                              "SELECT currval('название') возвращает последнее значение в этой последовательности в текущей сессии\n"+
                                              "SELECT lastval() возвращает последнее значение любой последовательности текущий сессии "),

                 ("168. Какие бывают INTEGER","smallint - int2\n"+
                                              "integer int4\n"+
                                              "bigint int8\n"),

                 ("169. Тип данных NUMERIC","Тип данных для хранения чисел с произвольной точностью\n"+
                                            "Идеальный выбор для вычислений с высокой точностью\n"),

                 ("170. Дробные числа SQL","Дробные числа быстрые, но с ограниченной точностью\n"+
                                            "real 4 байт\n"+
                                            "double precision 8 байт\n"+
                                            "float(1-52)"),

                 ("171. Тип данных деньги","MONEY имеет точность два знака до запятой\n"+
                                           "имеет префикс ввиде валюты\n"+
                                           "просмотр префикса show lc_monetary \n"+
                                           "установка префикса SET lc_monetary = 'en_US.UTF-8'\n"+
                                           "MONEY не рекомендуется использовать. Возможны проблемы с точностью и конвертацией\n"+
                                           "Лучше использовать целые числа умноженные на 100\n"+
                                           "или NUMERIC\n"),

                 ("172. Что такое NaN","NaN это не число. Может быть у numeric и чисел с плавающей точкой\n"),

                 ("173. Что такое infinity","Это бесконечность может быть у numeric ,без ограничений и чисел с плавающей точкой\n"+
                                            "может быть отрицательной\n"),

                 ("174. Как можно преобразовать типы в Postgres","команда CAST(значение AS тип) или значение :: тип"),

                 ("175. Команда для определения типа Postgres","pg_typeof()"),

                 ("176. Команда для определения размера типа Postgres","pg_column_size()"),

                 ("177. Три символьных типа","char(размер) не гарантирует размер, просто выравнивает длину до нужного размера\n"+
                                             "character varying это varchar для postgres\n"+
                                             "text строка"),

                 ("178. Какие способы ограничений есть? Как сделать чтоб было название проверки","CHECK(название столбца >0) для целых чисел \n" +
                                                                                                 "CHECK(LENGTH(название столбца)>5) для строк\n" +
                                                                                                 "если ограничение записать через запятую то работает на уровне таблицы\n"+
                                                                                                 "CONSTRAINT название CHECK "),

                 ("179. Как создать автоматический идентификатор Postgres","id BIGINT GENERATED ALWAYS AS IDENTYTI PRIMARY KEY\n"+
                                                                           ""),

                 ("180. Как добавить принудительно значение идентификатора","INSERT INTO название таблицы (id) OVERRIDING SYSTEM VALUE values(значение id)\n"),

                 ("181. Как узнать номер последовательности для столбца","SELECT pg_get_serial_sequence('название таблицы','название столбца')\n"+
                                                                         "SELECT setval('название последовательности',(SELECT MAX(id) FROM 'название таблицы')"),

                 ("182. Какие типы данных есть для хранения строк IP адресов? " +
                 "Какие преимущества их использования?",                    "INET разные варианты ip адресов\n"+
                                                                            "CIDR хранит ip4 и ip6 вместе с маской\n"+
                                                                            "macaddr6 macaddr8 MAC адрес\n"+
                                                                            "Использование этих типов данных экономит место\n"+
                                                                            "а также имеет специальные функции для работы с ними\n"),

                 ("183. Какие типы данных для хранения json в Postgres\n"+
                 "Какие отличия",                                        "json имеет меньше размер,есть только защита от невадилидных данных\n"+
                                                                         "jsonb имеет больше размер, но скорость обработки выше потому,\n"+
                                                                         "что хранит в себе биты, а не текст\n"+
                                                                         "включает только последние значения по ключу, сортирует по ключу, удаляет лишние пробелы\n"),

                 ("184. Представление значения json в строку","::json->string строка в кавычках\n"+
                                                               "::json->>string строка без кавычек\n"),

                 ("185. Как указать тип данных массив в Postgres","ARRAY или []"),

                 ("186. Как можно добавить значения в массив Postgres","INSERT INTO название таблицы(int_array, text_array, bool_array)\n" +
                                                                       "VALUES \n"+
                                                                       "(\n"+
                                                                       "ARRAY [1, 2, 3, 4],\n"+
                                                                       "ARRAY ['marigold','daisy','poppy','sunflower'],\n"+
                                                                       "ARRAY [true, false, true, false]\n"+
                                                                       ")\n"+
                                                                       "Второй вариант:\n"+
                                                                       "VALUES '{1,2,3}'\n"+
                                                                       "Вариант для вложенного массива:\n"+
                                                                       "'{{},{},{}}'"),

                 ("187. Извлечение элементов из массива Postgres","SELECT text_array[1] FROM название таблицы\n"+
                                                                  "Индексация начинается с 1\n"+
                                                                  "Можно использовать срезы text_array[1:3] выдаст с 1 по 3 элементы\n"+
                                                                  "text_array[:3] все элементы по 3\n"+
                                                                  "text_array[3:] все элементы с 3\n"),

                 ("188.Как найти массив SQL в котором, есть искомый элемент","SELECT text_array FROM table\n"+
                                                                             "WHERE text_array @> ARRAY['значение']\n"),

                 ("189. Как получить набор результатов из массива SQL","SELECT unnest(text_array)\n"+
                                                                       "Сделает выборку,где каждое значение массива будет строкой\n"),

                 ("190. Создание временной таблицы с помощью массива SQL","WITH flowers AS {\n"+
                                                                "SELECT id, unnest(text_array) AS flower\n"+
                                                                "FROM array_example}\n"+
                                                                "Это код создает временную таблицу с id и каждом цветком из таблицы\n"),

                 ("191. Как сделать сгенерированный столбец Postgres","CREATE TABLE people(\n"+
                                                                      "heigth_cm numeric\n"+
                                                                      "heugth_in numeric GENERATED ALWAYS AS (height/2.54) STORED)\n"+
                                                                      "можно вставить функцию после AS\n"+
                                                                      "Ограничения:\n"+
                                                                      "Должны быть стабильные данные,\n"+
                                                                      "нельзя генерировать столбец от генерированого\n"),

                 ("192. Типы данных для полнотекстового поиска","to_tsvector('строка') перевод в тип tsvector это отсортированный список различных лексим\n"+
                                                                "to_tsquery('слово') перевод в тип tsquery. Через оператор @@ можно проверить есть ли в tsvector tsquery\n"+
                                                                 "SELECT ts_vector('язык','строка') создание tsvector с указанием языка\n"),

                 ("193.Создание генерируемого столбца tsvector","название столбца TSVECTOR generated always AS(to_tsvector('english', content)) stored"),

                 ("194. Чтот такое битовые строки. Как их записывать?", "bit(3) точный размер\n"+
                                                                        "bit varying(32) размер до 32 включительно\n"+
                                                                        "B'0001'\n"+
                                                                        "'0001'::BIT(4)\n"+
                                                                        "Можно использовать как список true false\n"),

                 ("195. Что такое диапазон. типы диапазона. Правило ограничений","Это специальный тип данных, который позволяет хранить и эффективно\n"+
                                                                                 "рабоать с диапазоном значений\n"+
                                                                                 "'[1,5]'::int4range это диапазон [1,6) --1,2,3,4,5\n"+
                                                                                 "'[1,5]'::numrange это диапазон [1,5]  --1,1.1,5.9 \n"+
                                                                                  "numrange(1,5) -- [1,5)  --1,4.9\n"+
                                                                                  "int4range(1,5) --[1,5) --1,2,3,4\n"+
                                                                                  "numrange(1,5,'[])' --[1,5] --1,5.9\n"+
                                                                                  "int4range(1,5,'(]) --(1,5] --2,3,4,5\n"+
                                                                                 "[] - края диапазона включены\n"+
                                                                                 "() - края диапазона невключены\n"+
                                                                                 "empty пустой диапазон включает все\n"+
                                                                                 "(,) полностью закрытый диапазон. Не включает ничего \n"),

                 ("196. Функции диапазона","WHERE столбец целых чисел @>5 диапазон целых чисел, который включает 5\n"+
                                           "WHERE столбец целых чисел && '[10,20)' есть ли пересечение между интервалами [1,11] включается\n"+
                                           "перемножение интервалов int4range(10,20)*int4range(15,25) -- [15,20)"),

                 ("197. Что такое мультидиапазон?","'{[3,7),[8,9)}'::int4multirange --3-6,8"),

                 ("198. Как создать составной тип Postgres","CREATE TYPE address AS(\n"+
                                                            "number text,\n"+
                                                            "street text);\n"+
                                                            "Нет возможности ввести ограничения на типы полей\n"),

                 ("199. Как заполнить составной тип","SELECT ROW ('1','street')::address Можно без ROW\n"+
                                                      ""),

                 ("200. Как получить отдельное поле составного типа","SELECT (название столбца).название поля"),

                 ("201. Какие ограничения в первичного ключа по умолчанию","NOT NULL UNIQUE"),

                 ("202. Может быть уникальное значение быть NULL","NULL всегда будет уникальным,\n"+
                                                                  "если не указать not distinct\n"),

                 ("203. Как создать внешний ключ","Первый вариант:\n"+
                                                   "название столбца тип данных(такой же тип данных как у столбца, на который ссылается)\n"+
                                                  "REFERENCES название таблицы название столбца, на который сслылается\n"+
                                                  "Второй вариант на уровне таблицы:\n"+
                                                  "FOREIGN KEY (название столбца) REFERENCES название таблицы(название столбца) на который ссылается\n"),

                 ("204. Удаление строк в родительской таблице в Postgres","1.ON DELETE RESTRICT по умолчанию вызовет ошибку\n"+
                                                                          "2.ON DELETE CASCADE удаление и в родительской и дочерней таблицы\n"+
                                                                          "3.ON DELETE SET NULL при удаление родительской строки во внешнем ключе ставится NULL\n"+
                                                                          "4.ON DELETE SET DEFAULT во внешнем ключе устанавливается значения по умолчанию. DEFAULT 0 REFERENCES при создании\n"+
                                                                          ""),

                 ("205. Что такое индексы в Postgres","Это отдельная структура данных,которые ускоряют поиск и извлечение данных из таблиц,\n"+
                                                      "но замедляют операции вставки и удаления\n"+
                                                      "содержит в себе копию части данных из таблицы\n"+
                                                      "содержит ссылки на таблицы и полную строку\n"),

                 ("206. Что такое ctid в Postgres","Скрытая системная таблица,показывающая где хранится строка\n"),

                 ("207. Типы индексов в Postgres"," 1. B-tree Бинарное дерево. Стандартный тип индекса. Для большинства операций >,=,BETWEEN,ORDER BY\n"+
                                                    "CREATE INDEX index_name ON table_name(column_name)\n"+
                                                    "2.HASH подходит только для = Быстрее бинаронго дерева\n"+
                                                    "CREATE INDEX index_name On table_name USING HASH (column_name)\n"+
                                                    "3.GIN GENERALIZED INVERTED INDEX для составных значений массивов,полнотекстовый поиск, JSON\n"+
                                                    "CREATE INDEX index_name ON table_name USING GIN(column_name)\n"+
                                                    "4.GiST GENERALIZED SEARCH TREE для полнотестового поиска\n"+
                                                    "CREATE INDEX ind_name ON table_name USING GiST(column_name)\n"+
                                                    "5.SP-GiST Space-Partitioned GiST для неоднородных данных\n"+
                                                    "CREATE INDEX ind_name ON table_name USING SP-GiST(column_name)\n"+
                                                    "6. BRIN Block Range Index для очень болиших таблиц с коррелированными данными\n"+
                                                    "CREATE INDEX idn_name ON table_name USING BRIN(column_name)\n"),

                 ("208.Какой тип для первичного ключа лучше использовать?","Лучше всего использовать большие целые числа\n"+
                                                                            "Если нужно улучшить безопасность первичного ключа\n"+
                                                                            "Есть два решения дополнительная таблица с ключами или UUID\n"+
                                                                           "При использовании UUID нужно учитывать что их бывает 6 видов и 2 похожих типа\n"+
                                                                           "Стандартный UUID это случайный UUID. Случайная вставка потребует перестроения дерева. Поэотму лучше использовать UUID 7 версии.\n"+
                                                                           "У него в начале идет дата и по ней можно сортировать и располагать строки по дате создания\n"+
                                                                           "Еще UUID имеет преимущество, если например пользователь получает ID раньше подключение к базе данных\n"+
                                                                           "UUID можно сразу присвоить ID\n"),

                 ("209.Какие столбцы желательно использовать под индекс.\n"+
                 "При какой ситуации поиск происходит по таблице, а не по индексу ","Нужно выбирать более уникальные столбцы\n"+
                                                                                    "Если выборка более половины таблицы,\n"+
                                                                                    "то вероятно поиск будет по таблице, а не индексу\n"),

                 ("210.Как создать составной индекс","CREATE INDEX multi ON users USING BTREE(first_name,last_name,birthday)\n"),

                 ("211.Как правильно создавать и использовать составной индекс","Нужно использовать правило слева направо\n"+
                                                                            "Перечесление столбцов в индексе должно соответствовать таблице\n"+
                                                                            "При поиске нужно задавать самый левый столбец, иначе будет поиск по таблице\n"+
                                                                            "При пропуске столбца вовремя поиск добавляет все строки из предущего\n"),

                 ("212. Покрывающие индексы. Для чего они?","Покрывающие индексы включает в себя столбец(ы),который был указан при создании\n"+
                                                            "Нужна, если часто происходит выдача результата, поиск,сортировка или группировка по только указанному столбцу\n"+
                                                            "Это позволяет получать результат не обращаясь к таблице\n"+
                                                            "Если нужно просто добавить в индекс без влияния на результат сортировки использовть USING(столбец)"),

                 ("213.Частичные индексы. Как записываются и как работают","Позволяют создать индекс для части таблицы,\n"+
                                                                           "Включая ограничения для части таблицы\n"+
                                                                           "CREATE INDEX email ON user(email) WHERE is_pro = true\n"+
                                                                           "Чтоб при выдачи результата использовался индекс, вместо таблицы\n"+
                                                                           "Нужно в SELECT продублировать WHERE из индекса\n"),

                 ("214. Есть ли разница в сортировки индекса ASC и DESC?, Особенность сортировки составного индекса","Индекс одинаково сортирует по возрастанию и по убыванию\n"+
                                                                          "Если индекс составной и столбцы нужно сортировать в разном направлении\n"+
                                                                          "то при создании индекса нужно указать сортировку в разном направлении\n"+
                                                                          "и не важном в каком потому,что индекс сортирует одинаково\n"),


                 ("215.NULL самый большой элемент? Как сделать чтоб  сортировалось иначе\n","NULL самый большой элемент, ORDER BY название столбца(ASC DESC) nulls (first или last)\n"),

                 ("216. Как создать индекс что при сортировке по возрастанию NULL был первым\n","CREATE INDEX название ON название таблицы(столбец ASC NULLS FIRST)"),

                 ("217. Как создать индекс на основе функции и как с ним работать?","CREATE INDEX название ON название таблицы((split(email,'@',2)))\n"+
                                                                                    "Чтоб индекс сработал нужно WHERE split(email,'@',2) = 'beer.com'"),

                 ("218. Как создать hash индекс. Для чего он полезен?","Работает быстрее,чем BTREE. Занимает меньше места\n"+
                                                                       "Можно использовать только для строгого равенства\n"+
                                                                       "CREATE INDEX email_hash ON users USING HASH(email)\n"+
                                                                       "до версии Postgres 10 были опасны\n"),

                 ("219. Рекомендация для названия индекса","таблица_столбец_idx"),

                 ("220.Что такое план объяснения? Как его создать?","QUERY PLAN это древовидная структура,состоящая из узлов\n"+
                                                                     "нужен для анализа запроса\n"+
                                                                     "EXPLAIN перед SELECT\n"+
                                                                     "можно EXPLAIN(format json) для подробного и машиночитаемого результата\n"+
                                                                     "читать план нужно снизу вверх\n"),

                 ("221. Типы сканирования","1.Последовательное сканирование таблицы\n"+
                                           "Seq Scan прочтение всей таблицы в физическом порядке\n"+
                                           "2.Сканирование по побитовой карте\n"+
                                           "Bitmap Index Scan сканирование битовой кучи. Физический просмотр таблицы по карте созданной по указателям\n"+
                                           "3.Сканирование по индексу\n"+
                                           "Index Scan сканирование по индексу с обращением к куче\n"+
                                           "Index Only Scan сканирование по покрывающему  индексу без обращения к куче\n"),

                 ("222. QUERY PLAN какие показатели есть","cost некоторая единица стомости(чтение последовательной, случайной) Postgres\n"+
                                                          "rows сколько строк передается\n"+
                                                          "width размер строк\n"),

                 ("223. Аналитика запроса. Основные показатели и моменты","explain (analyze) select это запрос будет выполнен\n"+
                                                                        "Основные показатели:\n"+
                                                                        "Время подготовки и выполнения\n"+
                                                                        "loops количество циклов\n"+
                                                                        "(analyze,cost off) отключить показатель cost\n"),

                 ("224. Как можно указать столбы с одинаковым названиями при Join","ON USING(user_id)"),

                 ("225. Full JOIN","Все совпадения плюс NULL левой и правой таблицы\n"),

                 ("226. Как всю включить после объединения таблиц","ON true"),

                 ("227. INNER JOIN LATERAL","Это специальный тип соединения, который позволяет подзапросу\n"+
                                            "или функции, следующий за ключевым словом LATERAL,\n"+
                                            "ссылаться на столбцы из таблицы указанных ранее\n"),

                 ("228. Выравнивание строк через ROW пример","SELECT * FROM ROWS FROM(\n"+
                                                             "generate_series(1,10), -- это функции генерации от 1 до 10\n"+
                                                             "generate_series(101,110)  -- это функции генерации от 101 до 110)\n"+
                                                             "AS t(lower,upper)\n"+
                                                             "Будет создано два столбца по 10 строк\n"+
                                                             "если один столбец будет иметь больше строк\n"+
                                                             "то в другой будет NULL\n"),

                 ("229. Функция,которая ставит значение по умолчанию, если значение NULL","coalesce(столбец, значение по умолчанию)\n"),

                 ("230. Объединение Postgres","UNION объединяет два и более запросов, удаляя дубликаты\n"+
                                              "UNION ALL объединяет запросы без удаления\n"+
                                              "Количество строк в запросах должно быть одинаковое"),

                 ("231.Пересечение Postgres","INTERSECT возвращает только те строки, которые есть в результатах обоих запросов\n"),

                 ("232.Разность Postgres","EXCEPT возврашает только строки из первого запроса, которых нет во втором\n"),

                 ("233. Получение строк из массива","SELECT unnest(ARRAY[1,2,3,4,5]) AS tag_name"),

                 ("234.Получение строк из массива с порядковым id","SELECT ordinality, element FROM\n"+
                                                                   "unnest(ARRAY['first','second','third]) WITH ORDINALITY AS t(element, ordinality)\n"),

                 ("235.Преобразование массивов JSON в таблицу","SELECT * FROM json_to_recorderset('[\n"+
                                                               "{id}:1, name:ALICE, email: alice@example.com]')\n"+
                                                               "AS x(id INT, name TEXT, email TEXT)\n"+
                                                               "Чтоб сделать тоже самое с JSONB нужно:\n"+
                                                               "jsonb_to_recorderset и ]'::JSONB\n"),

                 ("236.Получение строк из строки через регулярное выражение\n","SELECT regexp_matches('строка','\\m\\w{4}\\M'','g') AS match"),

                 ("237. Разделить строку на один столбец","SELECT string_to_table('apple,banana,cherry',',') AS fruit\n"),

                 ("238.Как можно ускорить связь между таблицами","Создать индекс для внешнего ключа\n"),

                 ("239.Необчные агрегатные функции","ANY_VALUE(столбец) любое значение\n"+
                                                    "ARRAY_AGG(столбец) агрегирование массива\n"+
                                                    "JSON_AGG(столбец)\\JSONB_AGG агрегирование JSON\n"+
                                                    "BOOL_AND(столбец) покажет true где все столбцы совпадают\n"+
                                                    "BOOL_OR где есть хоть одно совпадение\n"+
                                                    "COUNT(*) FILTER(WHERE) фильтр\n"+
                                                    "STRING_AGG(строковый столбец,'разделитель') объединение столбцов через разделитель в один столбец\n"+
                                                    "" +
                                                    ")"),

                 ("240. Сеты  в GROPUP BY","SELECT emploee_id, region, sum(amount) FROM sales\n"+
                                                 "GROUP BY grouping sets((employee_id),(region))\n"+
                                                 "() вывод общей пустой групировки\n"+
                                                 "вывод разных группировок"),


                ("241 Сварачивание в GROUP BY","rollup(region, employee_id) выведет:\n"+
                                               "region + employee_id\n"+
                                               "region + NULL\n"+
                                               "NULL\n"),

                ("242. Куб в GROUP BY","CUBE(employee_id, region) Все возможные варианты группировки\n"),

                ("243. Оконная функция"," Функция, которая работает с выделенным набором строк(окном, партицией)\n"+
                                        "и выполняет вычисление для этого набора строк в отдельном столбце\n"),

                ("244.Партиции","(окна из набора строк).Это набор строк, указанный для оконной функции по одному из столбцов\n"+
                                "или группе столбцов таблицы. Партиции для каждой оконной функции в запросе могут быть разделены по различным колонкам таблицы"),

                ("245. CTE? ","Это временные наборы результатов, которые существуют только во время выполнения запроса\n"+
                                            "Они позволяют создавать именованные подзапросы,\n"+
                                            "которые можно многократно использовать в основном запросе\n"+
                                            "WITH имя_cte AS(\n"+
                                            "SELECT)\n"+
                                            "SELECT * FROM имя_cte"),

                ("246. Обобщенное табличное выражение CTE для чего полезны","1. Улучшают читаемость сложных запросов\n"+
                                             "2. Позволяют избежать дублирования кода\n"+
                                             "3. Поддерживают рекурсию для работы с иерархическими данными\n"+
                                             "4. Могут материализоваться для оптимизации производительности\n"),

                ("247. Материализация CTE","Postgres сам выбирает материализовать или нет. Обычно при маленьком количестве вызовов не матеарилизует\n" +
                                           "WITH cte_name AS not matearilized\n"+
                                           "AS matearilized\n"),

                ("248. Рекурсивный CTE. Пример","WITH RECURSIVE имя AS\n"+
                                                "можно перечислить столбцы после AS(id,name)\n"+
                                                "WITH recursive numbers AS(\n"+
                                                "SELECT 1 AS n\n"+
                                                "UNION ALL\n"+
                                                "SELECT n+1 FROM numbers WHERE n < 10)\n"+
                                                "SELECT * FROM numbres\n"),

                ("249. CTE рекурсия. Пример с фибоначи\n","WITH RESURSIVE numbres(id, a, b) AS (\n"+
                                                          "SELECT 1, 0, 1\n"+
                                                          "UNION ALL\n"+
                                                          "SELECT id + 1, b, a + b FROM numbres WHERE id < 20)\n"+
                                                          "SELECT id, a FROM numbres\n"),

                ("250. CTE рекурсияю Иерархия пример","WITH RECURSIVE all_categories AS(\n"+
                                                      "SELECT id, name, name AS path\n"+
                                                      "FROM categories WHERE parent_id IS NULL\n"+
                                                      "UNION ALL\n"+
                                                      "SELECT categories.id, categories.name, CONCAT(path, '-->', categories.name)\n"+
                                                      "FROM all_categories\n"+
                                                      "INNER JOIN categories ON all_categories.id=categories.parent_id)\n"+
                                                      "SELECT* FROM all_categories\n"),

                ("251. Способ сравнения с NULL","SELECT 1 IS DICTINCT FROM NULL\n"+
                                                " IS NULL"),

                ("252. Функция возвращает NULL, если выражение TRUE","NULLIF(1,1),если неравны возрваащется первое значение\n"),

                ("253. Сравнение строк ROW","SELECT (1,2,3) = (1,2,3) - TRUE\n"+
                                            "SELECT (1,2,3) = (1,2,4) - FALSE\n"+
                                            "SELECT (1,2,3) = (1,NULL,3) - NULL\n" +
                                            "SELECT (1,2,3) = (1,NULL,4) - FALSE\n"),

                ("254. Представление VIEW синтаксис","CREATE VIEW имя AS();"),

                ("255. Отличие VIEW от WITH","VIEW сохраняется в базе, WITH временное(на время запроса)\n"+
                                             "VIEW может кешироваться, WITH вычисляется каждый раз\n"+
                                             "VIEW не поддерживает рекурсию\n"+
                                             "VIEW для многократного использования в разных запросах, WITH только в текущем запросе\n"),

                ("256. Как сделать Upsert при вставке","INSERT INTO kv (key,value) values ('cache:foo', 123)\n"+
                                                       "on conflict (key) do nothing - ничего не делай\n"+
                                                       "on conflict (key) do update set value='there was conflict' - вставка с заменой\n"+
                                                       "on conflict(key) do update set value=excluded.value - вставка с заменой на value\n"+
                                                       "set value = kv.value - вставка с заменой\n"+
                                                       "where как допусловие, при несоответствии не выполняется обновление\n"+
                                                       "returning позволяет отобразить вставку\n"),

                ("257. Операторы по поиску соответствия в тексте","LIKE\n"+
                                                                  "ILIKE без учета регистра\n"),

                ("258. Полнотекстовый поиск пример","SELECT title FROM movies\n"+
                                                    "WHERE to_tsvector(title) @@ to_tsquery('star & wars')\n"+
                                                    "& и то и другое\n"+
                                                    "| одно из двух\n"+
                                                    "<-> после первого идет сразу второе\n"+
                                                    "'star <-> (wars | trek)'\n"+
                                                    "<1> через сколько слов должно быть следующее слово\n"+
                                                    "'star & trek & !generation исключение слова\n"),

                ("259. Функция ранжирование полнотекстового поиска. Пример","ts_rank(to_tsvector(title), to_tsquery('star & (wars | trek)')) AS rank\n"+
                                                                            "FROM movies\n"+
                                                                            "WHERE to_tsvector(title) @@ to_tsquery('star & (wars | trek)')\n"+
                                                                            "ORDER BY rank DESC\n"+
                                                                            ""),
                ("260. Векторы полнотестового поиска","to_tsquery() стандартное\n"+
                                                      "phraseto_tsquery('star wars') - 'star'<->'war'\n"+
                                                      "plainto_tsquery('star wars') - 'star' & 'war\n"+
                                                      "websearch_to_tsquery() допускает двойные кавычки, не выдает ошибку\n"),
                ("261. Языковая допопция to_tsvector()","to_tsvector('simple',title) - простой поиск. Включает предлоги и артикулы\n"+
                                                         "to_tsvector('english', title) - желательно указывать язык\n"+
                                                         "setweight(to_tsvector(title),'A') установка приоритета при ранжировании, при совпадении\n"),

                ("262. Как сделать чтоб полнотекстовый поиск реагировал на точность совпадения","ts_rank(to_tsvector(title), to_tsquery('flight'),1)\n"+
                                                                                                "+(case when genre like %action% then 0.1 else 0)\n"+
                                                                                                "добавление к рейтингу\n"),
                ("263. Оптимизация полнотестового поиска. Пример","ALTER TABLE movies ADD COLUMN search_vectors tsvector generated always AS(\n"+
                                                                  "setweight(to_tsvector('english', coalesce(title, '')), 'B')\n+" +
                                                                  "|| ''\n"+
                                                                  "|| to_tsvector('english', coalesce(plot, '')))stored\n"+
                                                                  "Создали генерируемый столбец\n"+
                                                                  "SELECT * FROM movies\n"+
                                                                  "WHERE search_vectors @@ websearch_to_tsquery('\"stars wars\"')\n"+
                                                                  "ORDER BY\n"+
                                                                  "ts_rank(search_vectors, websearch_to_tsquery('\"stars wars\"')) desc\n"+
                                                                  "Вызваем запрос\n"+
                                                                  "CREATE index idx_movies_search_gin on movies using gin(search_vectors)\n"+
                                                                  "Создание индекса\n"),

                ("264. Поиск полнотекстовый с выделением","ts_headline('english', title, websearch_to_tsquery('\"stars wars\"'),\n" +
                                                          "'StarSel=<mark>,StopSel=</mark>'"),

                ("265. Функции для валидации и определения JSON","json_typeof(value) IS NOT NULL\n"+
                                                                 ""+
                                                                  "val IS JSON\n"+
                                                                 "IS JSON scalar - скалярное ли\n"+
                                                                 "IS JSON array - массив ли\n"+
                                                                 "IS JSON object - объект\n"+
                                                                 "IS JSON object with unicue keys - объект с уникальными ключами\n"),

                ("266. Функции для создания JSON","json_build_object - создание объекта JSON\n"+
                                                  "json_build_array - создание массива JSON\n"+
                                                  "to_json('aaron'::text) возврат текста в типе JSON\n"+
                                                  "Создание строки JSON из запроса\n"+
                                                  "SELECT row_to_json(u) AS users_json FROM\n"+
                                                  "(SELECT * FROM users WHERE email= ' ') u\n"+
                                                  "json_agg(row_to_json(u)) - массив JSON строк\n"+
                                                  "Создать массив объектов JSON\n"+
                                                  "json_agg(\n"+
                                                  "json_build_object(\n"+
                                                  "'id', id,\n"+
                                                  "'email', email))\n"),

                ("267. Получение значений из JSON","::JSON) -> ключ - возвращает в формате JSON\n"+
                                                   "->> ключ - возвращает в формате текст\n"+
                                                   "-> ключ -> ключ - возвращает вложенный JSON\n"+
                                                   "-> ключ ->1 - возвращает элемент массива,число может быть отрицательным, считает с конца\n"+
                                                   "#>{customer,name} продвижение как по стрелкам.Формат json\n"+
                                                   "#>> формат текст\n"+
                                                   "если не найдет ничего вернет NULL\n"),

                ("268. Получение значений из JSONB","SELECT jsonb_path_query('JSON с массивом', '$.items[0].product' - возвращает элемент в формате JSON\n"+
                                                    "'$.status') #>> '{}'  без кавычек\n"+
                                                    ""),
                ("269.",""),

                ("270. Сравнение JSONB","SELECT '{\"a\":1, \"b\":2}'::jsonb @> '{\"a\":1}'::jsonb  - TRUE\n"+
                                       "SELECT '{\"a\":1, \"b\":2}'::jsonb <@ '{\"a\":1}'::jsonb - FALSE\n"+
                                       "'[apple, banana, cherry]'::jsonb @> '[apple,cherry]::jsob - TRUE\n'"+
                                       "::jsonb @> '{customer: {name: Alice}}' - сравнение вложенного JSONB\n"+
                                       "WHERE details @> '{status:shipped}' фильтр в запросе\n"+
                                       "WHERE details ->> status = shipped фильтр в запросе\n"),

                ("271. Проверка ключей JSONB","::jsonb ? 'status' - есть ли ключ status\n"+
                                              "SELECT '[apple, banana]' ? 'asdf' содержит ли элемент\n"+
                                              "::jsonb ?| array['status','created_at'] содержит ли какой нибудь ключ из массива\n"+
                                              "&| все совпадения\n"+
                                              ""),

                ("272. Преобразование JSONB в таблицу","SELECT * FROM jsonb_each('{\"a\":1}') - выведет два столбца ключ и значение\n"+
                                                       "jsonb_each_text() - выведет таблицу, где ключ и значение будет в текстовом формате\n"+
                                                       "lateral jsonb_each_text(столбец из таблицы с JSONB) - выведет дополнительные столбцы Key и Value\n"+
                                                       "SELECT * FROM jsonb_to_recordset('[{\"a\":1,\"b\":\"foo\"}]') AS t(a int, b text) создаст столбцы с названиями a и b, и значениями 1 и foo\n"+
                                                       "SELECT * FROM jsonb_to_recordset(jsonb_build_array('{\"theme\":\"light\"}'::jsonb)) AS t(theme text) преобразование сначала в массив а потом столбец\n"+
                                                       ""),
                ("273. Update JSON","Update config - обновить таблицу\n"+
                                    "set\n " +
                                    "settings = jsonb_set(settings,'{theme}', json_scalar('syntwave')::jsonb)\n"+
                                    "в столбце settings по ключу theme обновит значение на syntwave\n"+
                                    "set settings = settings - 'theme' удаление ключа theme\n"+
                                    "set details =json_set(details, ключ, значение) установка вложенного значения по ключу\n"+
                                    "set details = jsonb_set(details, '{items,0,price}',to_json(899)::jsonb\n установка в ключе items,в 0 значении-массиве,по ключу price значения 899\n" +
                                    "set details = jsonb_insert(details, '{items,0}','{\"price\": 199, \"product\":\"HeadP\"}'::jsonb, true)\n"+
                                    "добавление в массив если true, обновление если fasle\n"),


                ("274. Добавление индекса JSON","Первый вариант:\n"+
                                           "CREATE INDEX orders_json_email_idx ON orders_json(\n"+
                                           "((details -> 'customer' ->> 'email')::text));\n"+
                                           "Запустить поиск по индексу" +
                                           "WHERE details->'customer'->>'email'::text = '.com'\n"+
                                           "Второй вараинт:\n"+
                                           "column email text GENERATED ALWAYS AS(details->'customer'->>'email'::text) STORED\n"+
                                           "создание обычного индекса по email\n"),

                ("275.Индекс GIN для JSON","CREATE INDEX название ON таблица USING GIN(столбец) подходит для @>,?,?|\n"+
                                       "USING GIN(столбец json_path) - оператор по умолчанию\n"+
                                       "USING GIN(столбец json_path_ops) - подходит только @>\n"+
                                       ""),

                ("276.Создать расширение для vector","CREATE EXTENSION IF NOT EXISTS vector\n"+
                                                     ""),

                ("277. Пример с vector расширением","CREATE TABLE products_v(\n"+
                                                    "id BIGINT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,\n"+
                                                    "name TEXT,\n"+
                                                    "embedding VECTOR(4));\n"+
                                                    "INSERT INTO products_v(name, embedding) VALUES\n"+
                                                    "('Product A', '[1,2,3,4]')\n"+
                                                    "('Product B', '[10,11,12,13]')\n"+
                                                    "SELECT *, embedding <->[1,2,3,4] вычисляет расстояние в эвклидовой геометрии\n"+
                                                    "Результат цифры. Чем больше соответствия тем меньше\n"+
                                                    "ORDER BY embedding <->[1,2,3,4]"+
                                                    "<=> cosine для нормализованных\n"+
                                                    "<+> L1\n"+
                                                    "<#> Inner Product\n"),

                ("278.Создание векторных индексов","CREATE INDEX имя ON table using ivfflat(embedding vector_cosine_ops) with (lists=10)\n"+
                                                   "vector_ip_ops - указание оператора\n"+
                                                   "USING hnsw - более точен, но требует больше ресурсов\n"),

                ("279. Нормалализация базы данных","Это процесс организации данных в базе для мимнимизации избыточности и зависимостей\n"+
                                                   "Она помогает избежать аномалий при вставке, обновлений, удалений\n"+
                                                   "и упрощает схему базы данных\n"),

                ("280. Обратная нормализация базы данных","Обратная нормализация - это баланс между идеальной нормализацией и реальной потребностью\n"+
                                                          "производительностью и удобством работы с данными\n"),

                ("281. Кеширование таблицы TRUNCATE","Создание таблицы для кеширования\n"+
                                                     "Периодическое обновление кеша\n"+
                                                     "TRUNCATE TABLE name\n"+
                                                     "INSERT INTO name(column1, column2)\n"+
                                                     "SELECT FROM WHERE\n"+
                                                     "Полезен для сложных запросов, где актуальность данных не так важна\n"),

                ("282. Триггеры","Специальные хранимые процедуры, которые автоматически выполняются\n"+
                                 "при наступлении определенных событий\n"+
                                 "CREATE TRIGGER trigger_name\n"+
                                 "{BEFORE | AFTER | INSTEAD OF} момент срабатывания до, после или вместо\n "+
                                 "{INSERT | UPDATE | DELETE} привязка к событиям\n"+
                                 "FOR EACH{ROW, STATEMENT} {выполняются для строки, для всего оператора}\n"+
                                 "EXECUTE FUNCTION nameFunction\n"+
                                 "Включение и отключение триггера {ENABLE, DISABLE}\n"+
                                 "DROP TRIGGER name - удаление триггера\n"),

                ("283. Основные подходы для денормализации","1. Добавление вычисляемых столбцов\n"+
                                                            "2. Дублирование данных из связанных таблиц\n"+
                                                            "3. Объединение таблиц\n "+
                                                            "4. Создание агрегированных таблиц\n"+
                                                            "5. Иерархические структуры в одном столбце техника\\телефоны\\модель\n"+
                                                            "6. Использование JSON/JSONB для сложных структур\n"+
                                                            "7. Создание копий таблиц для разных целей\n"),

                ("284. Виды планов выполения запросов","EXPLAIN показывает статистику, без выполнения\n"+
                                                  "EXPLAIN ANALYZE показывает статистику с выполнением\n"+
                                                  "EXPALAIN (VEBROSE TRUE) дополнительная информация Output столбцов(FALSE по умолчанию)\n"+
                                                  "EXPLAIN (COSTS FALSE) оценивает ожидаемую нагрузку на каждом шагу. по умолчанию TRUE\n "+
                                                  "EXPLAIN (ANALYZE BUFFERS) используется только с ANALYZE\n"+
                                                  "   состоит из 2 основных частей:\n"+
                                                  "   shared read разделяемых чтений - чтение с диска\n"+
                                                  "   shared hit разделяемых обращений - чтение с кэша\n"+
                                                  "EXPLAIN (ANALYZE TIMING) время на каждом узле. По умолчанию TRUE\n"+
                                                  "EXPLAIN (ANALYZE SUMMARY) включает итоговую информацию\n"+
                                                  "   может работать и с ANALYZE по умолчанию TRUE\n"+
                                                  "EXPLAIN (FORMAT JSON) возвращает в разных форматах(XML,JSON,YAML)\n"+
                                                  "   TEXT по умолчанию\n"),

                ("285. Шаги SQL при выполнении","1.Компиляция и преобразование оператора SQL в выражение,\n"+
                                           "состоящие из высокоуровневых логических операций, логический план\n"+
                                           "2.Оптимизирует логический план и преобразует его в план выполнения\n"+
                                           "3.Выполняет(интерпретирует) план и возвращает результаты\n"),

                ("286.Секционированная таблица", "Основные типы секционирования:\n"+
                                                 "1. RANGE по диапазону FOR VALUES FROM\n" +
                                                 "2.LIST по списку значений FOR VALUES IN\n   "+
                                                 "3. HASH по хеш функции \n"+
                                                 "Создаем основную (родительскую) таблицу\n "+
                                                 " CREATE TABLE sales(\n"+
                                                 " id\n"+
                                                 "sale_date DATE\n"+
                                                 ") PARTITION BY RANGE(sale_date)\n"+
                                                 "Создаем секции (партиции)\n"+
                                                 "CREATE TABLE sales_q1 PARTITION OF sales\n"+
                                                 "FOR VALUES FROM ('2023-01-01) TO ('2023-04-01')\n"),

                ("287.Временные таблицы","CREATE TEMP TABLE\n"),

                ("288. Что такое транзакция?","Это последовательность операций с базой данных,\n"+
                                              "которая рассматривается как единое целое\n"+
                                              "BEGIN TRANSACTION или START TRANSACTION\n"+
                                              "Действия\n"+
                                              "COMMIT сохранение, если все успешно\n"+
                                              "ROLLBACK отмена всех изменений в транзакции\n"+
                                              "для промежуточного сохранения можно использовать SAVEPOINT\n"+
                                              "для отката к точке сохранения ROLLBACK TO SAVEPOINT"),


                ("289.Характеристики транзакций ACID","1. Атомарность(Atomacity) - транзакция выполняется полностью или не выполняется вообще\n"+
                                                      "2. Согласованность(Consistency) - транзакции переводит БД из одного согласованного состояния в другое\n"+
                                                      "3. Изолированность(Isolation) - параллельные транзакции не влияют друг на друга\n"+
                                                      "4. Долговечность(Durability) -результаты завершенной транзакции сохраняются даже после сбоев\n"),

                ("290.Уровни изоляции транзакций","1. READ UNCOMMITED можно читать незафиксированные изменения других транзакций\n"+
                                                  "2. READ COMMITED читаются только зафиксированные данные\n"+
                                                  "3. REPEATABLE READ  гарантирует, что повторные чтения в одной транзакции дадут одинаковый результат\n"+
                                                  "4. SERIALIZABLE самый строгий уровень, выполняются так, если бы они шли последовательно\n"),

                ("291. ВИДЫ Аномалии SQL","1. Потерянное обновление(lost update)\n"+
                                          "   Возникает когда две транзакции делают обновления\n"+
                                          "   Обновления первой транзакции перетираются обновлениями второй транзакцией\n"+
                                          "2.Грязное чтение(Dirty Read)\n"+
                                          "    чтение одной транзакции, незафисированных значений другой транзакции\n"+
                                          "    Postgres не поддерживает Read Uncommitted\n"+
                                          "3.Неповторяющиеся чтение(Nonrepeatetable Read)\n"+
                                          "   Когда одна транзакция читает одну и ту строку дважды,\n"+
                                          "   а другая транзакция поменяла строку. В итоге в первой транзакции два разных результата\n"+
                                          "4.Фантомное чтение. (Phantom Read)\n"+
                                          "   Когда одна транзакция выбирает строки по условию дважды,а другая в промежутке добавляет новую строку по условию\n"+
                                          "   В итоге в у первой транзакции разные результаты\n"+
                                          ""),

                ("292. Что такое MongoDb","Это документоориентированная база данных с необходимыми вам маштабируемостью\n+" +
                                          "и гибкостью, запросами и индексированием\n"),

                ("293. Какие преимущества PostgreSQL по сравнению с MySQL и SQLite?","1. Сложные данные Полезовательские типы\n"+
                                                                                     "2. Высокие требования к надежности ASID гарантии\n"+
                                                                                     "3. Аналитика и оконные функции лучше оптимизированы\n"+
                                                                                     "4. Расширенная возможность с функциями и операторами\n"),

                ("294.Чем отличается клиент psql от GUI-инструментов?","psql - консольный клиент\n"+
                                                                        "GUI графический инструмент\n "),

                ("295.Как подключиться к БД через psql и посмотреть список таблиц?","psql -U имя пользователя -d имя базы_данных -h хост -p порт\n"+
                                                                                    "-h и -p необязательно\n"+
                                                                                    "\\dt - список таблиц\n"+
                                                                                    "\\dt+ - с дополнительной информацией\n"+
                                                                                    "\\dn просмотр схем"),

                ("296.Что такое схема в контексте PostgreSQL?","schema - это именованный контейнер для объектов базы данных(таблиц, представлений)\n"+
                                                               "которая позволяет:\n"+
                                                               "1. Логически группировать связанные объекты\n"+
                                                               "2. Разделять права доступа на уровне схемы\n"+
                                                               "3. Избегать конфликты имен могут существовать одинкавые имена таблиц в одной БД\n"+
                                                               "SELECT schema_name FROM - просмотр схем\n"+
                                                               "CREATE SCHEMA имя -схема отдела кадров\n "+
                                                               "ALTER TABLE table_name SET SCHEMA - перемещение таблицы в схему\n"+
                                                               "DROP SCHEMA schema_name CASCADE\n"),

                ("297.Как получить справку по командам в psql?","\\? все доступные команды\n"+
                                                                "\\h список всех доступных SQL команд\n"+
                                                                ""),

                ("298.Чем numeric отличается от float и в каких случаях использовать каждый?","numeric(decimal) это число с плавающей точкой и заданной точностью. Медленный\n"+
                                                                                              "float это число с плавающей точкой и приближенной точностью. Быстрые\n"),

                ("299.В чем разница между char, varchar и text?","char(n) фиксированная длина,недостающую длину заполняет пробелами\n"+
                                                                 "varchar(n) длина до n\n"+
                                                                 "text для большого текста\n"),

                ("300.Как работают check constraint и domain type?","CHECK проверяемое значение для столбца или таблицы\n"+
                                                                    "CONSTRAIN название CHECK для отображения\n"+
                                                                    "DOMAIN это пользовательский тип данных на основе существующего,\n"+
                                                                    "но с дополнительными проверками для многоразового использования\n"+
                                                                    "CREATE DOMAIN имя AS TEXT\n"+
                                                                    "CHECK (VALUE )\n"+
                                                                    ""),

                ("301.Как хранятся UUID и зачем он нужен?","это 128 битный индефикатор, который гарантирует уникальность без подключения БД\n"),

                ("302.Какие типы лучше использовать для хранения даты и времени?","DATE дата без точностей\n"+
                                                                                  "TIME только время\n"+
                                                                                  "TIMESTAMP для точности\n"+
                                                                                  "INTERVAL для промежутков\n"),

                ("303.В чем разница между json и jsonb?","json - текст, как есть\n"+
                                                         "jsonb - бинарный\n"),

                ("304.Как задать массив строк в таблице и получить второй элемент?","names TEXT[]\n"+
                                                                                    "names[2]\n"),

                ("305.Зачем нужны generated columns?","Это столбцы, значения которые автоматически вычисляются на основе других столбцов таблицы\n"+
                                                      "1.Автоматическое поддержание целосности данных\n"+
                                                      "2. Упрощение запросов\n"+
                                                      "3. Оптимизация производительности\n"+
                                                      "4. Сокращение кода приложения\n"),

                ("306.Что такое composite types и где их использовать?","Это пользовательские типы данных, которые объединяют несколько полей\n"+
                                                                        "разных типов в одну структуру\n"+
                                                                        "1. Структуированность данные логически связаны\n"+
                                                                        "2. Повторное использование в других таблицах\n"+
                                                                        "3. Удобство запросов доступ к полям через точечную нотацию\n"+
                                                                        "4. можно интегрировать в json и обратно\n"),

                ("307. Как работает exclusion constraint и чем он отличается от unique?","UNIQUE это проверка на уникальность с помощью =\n"+
                                                                                         "EXCLUSE это сложная проверка на уникальность\n"+
                                                                                         "требует специальных операторов и методов\n"+
                                                                                         "чаще всего индексов GiST и SP-GiST"),

                ("308.Как работает B-Tree индекс?","сбалансированное дерево\n "+
                                                   "Это структура данных, которую СУБД используют для эффективного поиска, вставки и удаления.\n"+
                                                   ""),

                ("309. В чем отличие между primary key и secondary index?","Primary key всегда уникален, не может быть NULL, один на таблицу\n"),

                ("310.Что такое index selectivity?"," Селективность индекса - это метрика, которая показывает\n"+
                                                    "насколько уникальны значения в столбце\n"+
                                                    "Высокая селективность - много уникальных значений\n"+
                                                    "Чем выше селективность тем вероятнее работу по индексу\n"),

                ("311.Как работают partial indexes?","Индекс создается только для строк соответсвующих условию WHERE\n"+
                                                     "Условие должно быть детерменированным\n"),

                ("312.Зачем использовать covering index?","Это индекс, который содержит в себе нужные столбцы из таблицы\n"+
                                                          "Что позволяет выдавать результат без обращения к таблице\n"+
                                                          "подходит для часто запращиваемых данных\n"),

                ("313.Что такое функциональный индекс?","Это индекс, который создается на функцию, содержащие столбцы таблицы\n"),

                ("314.Когда использовать hash index?","Это тип индекса которые используют хеш функцию для быстрого доступа\n"+
                                                      "только для = IN\n"),

                ("315.Почему дублирующие индексы — это плохо?","1.Нагрузка на запись INSERT\n"+
                                                               "2. Бесполезное расходование дискового пространства\n"+
                                                               "3. Перегрузка оптимизатора запросов\n"+
                                                               "4. Путаница при сопровождении\n"),

                ("316.Как назвать индекс, чтобы сразу было понятно его назначение?","idx_таблица_столбец_какой индекс\n"),

                ("317.Как PostgreSQL выбирает индекс при наличии нескольких?","1. Генерация планов выполнения\n"+
                                                                              "2. Оценка стоимости\n"+
                                                                              "3. Выбор оптимального плана\n"),

                ("318.Что показывает EXPLAIN?","Это команда, которая показывает план выполнения запроса,\n"+
                                               "но не выполняет сам запрос\n"),

                ("319.Чем отличается EXPLAIN от EXPLAIN ANALYZE?","1. Фактически выполняет запрос и показывает реальные запросы\n"+
                                                                  "2. Дает реальную статистику.фактическое время выполнения каждой операции,количество отработанных строк,затраты ресурсов\n"+
                                                                  "3. Показывает расхождения между реальным и ожидаемым результатам\n"),

                ("320.Что такое cost в EXPLAIN и как его читать?","Это параметр, представляющий собой оценочную стоимость\n"+
                                                                  "выполнения операции в условных единицах\n"+
                                                                  "cost x..y\n"+
                                                                  "x - стоимость первой строке\n"+
                                                                  "y - стоимость выдачи всех строк\n"),

                ("321. Что такое sequential scan и когда он возникает?","Операция полного чтения таблицы\n"+
                                                                        "Выполняется когда:\n"+
                                                                        "1. Отсутсвует индекс или он неэффективен\n"+
                                                                        "2. Запрос выполняет все или почти все записи\n"+
                                                                        "3. Маленькая таблица\n"+
                                                                        "4. Статистика устарела\n"),

                ("322. Как узнать, какой индекс используется в запросе?","использовать explain(можно вызвать нужный индекс принудительно)\n"+
                                                                         "SELECT * FROM pg_indexes\n"),

                ("323.Какие компоненты обязательны для базового SELECT-запроса?","SELECT 1;\n"+
                                                                                 "SELECT * FROM table\n"),

                ("324.Что делает оператор WHERE?","Фильтрация данных и сокращение обработки\n"),

                ("325.Что такое агрегатные функции и какие они бывают?","Выполняют вычисления над набором значений и выдают единственный результат\n"+
                                                                        "Часто используются с GROUP BY\n"+
                                                                        ""),
                ("326.Как использовать оператор GROUP BY в запросах?","Это оператор группировки данных,\n"+
                                                                      "который объединяет  строки с одинаковыми значениями в указанных столбцах\n "+
                                                                      "и позволяет использовать агрегатные функции\n"),

                ("327.Чем отличается оператор HAVING от WHERE?","WHERE используется до группировки\n"+
                                                                "HAVING фильтрует после группировки, может использовать агрегированные функции\n"+
                                                                ""),

                ("328.Что такое CROSS JOIN?","Этот операция соединения таблиц, которая возвращает декартово произведение\n"+
                                             "строк из обеих таблиц. Каждая строка первой таблицы соединяется с каждой строкой второй таблицы\n"),

                ("329.Когда может быть полезен CROSS JOIN?","1. Генерация всех возможных вариантов\n"+
                                                             "2. Создание таблицы умножения\n"),

                ("330.Чем отличается CROSS JOIN от других типов соединений?","Не требует условий соединения и редко используется\n"),

                ("331.Что происходит, если одна из таблиц в CROSS JOIN пуста?","Вернет 0 строк\n"),

                ("332.Как избежать использования CROSS JOIN, если нужно соединить таблицы по определенному условию?","использовать явные JOIN\n"),

                ("333.Что делает INNER JOIN?","Это оператор соединения таблиц, который возвращает только те строки,\n"+
                                              "где есть совпадения в обеих таблицах по указанному условию\n"),

                ("334.Как избежать дублирования строк при использовании INNER JOIN?","1. Точно указывать желаемые столбцы\n"+
                                                                                     "2.Использовать DISTINCT\n"+
                                                                                     "3. Использовать GROUP BY\n"+
                                                                                     "4. Использовать корректные условия соединения\n"),

                ("335.Когда лучше использовать INNER JOIN?","1. Связывание таблиц по ключу\n"+
                                                            "2. Фильтрация данных через соединение\n"+
                                                            "3. Агрегация связанных данных\n"+
                                                            "4. Многотабличные запросы с четкими связами\n"+
                                                            "5. Оптимизация производительности\n"),

                ("336.Что произойдет, если в одной из таблиц нет совпадений для строки из другой таблицы?","Не будет в выдаче результата\n" +
                ""),

                ("337.Как объединить несколько таблиц с помощью INNER JOIN","Последовательно составить соединения таблиц по условию"),

                ("338.Чем отличается LEFT OUTER JOIN от RIGHT OUTER JOIN?","Это два типа внешних соединений, которые отличаются направлением\n"+
                                                                           "сохранения данных при отсутствии совпадений\n"),

                ("339.Когда стоит использовать OUTER JOIN вместо INNER JOIN?","1. Когда нужно отобразить все данные из главной таблицы\n"+
                                                                              "2. Поиска записей без взаимных соответствий в двух таблицах\n"+
                                                                              ""),
                ("340.Что происходит, если в OUTER JOIN нет совпадений?","строки без совпадений не отбрасываются, а \n"+
                                                                         "сохраняются в результате с NULL значениями "),

                ("341.Как объединить несколько таблиц с использованием LEFT OUTER JOIN?","Сохраняются все строки первой таблицы\n"+
                                                                                         "Если в левой части NULL то и в правой будет NULL\n"),

                ("342. Что такое FULL OUTER JOIN?","Это операция соединения, которая сохраняет все строки из обеих таблиц\n"+
                                                   "заполняя NULL - значениями отсутвующие соответствия\n"),

                ("343.Что такое подзапрос?","это SQL запрос вложенный внутрь другого запроса\n"+
                                            "Он позволяет выполнять сложные операции с данными,\n"+
                                            "используя результаты одного запроса в другом\n"),

                ("344.Как использовать подзапрос в операторе WHERE?","Фильтрация на основе подзапроса"),

                ("345. В чем разница между подзапросом в SELECT и подзапросом в FROM?"," в SELECT возвращается одно значение\n"+
                                                                                       "в каждой строке запроса\n"+
                                                                                       "FROM возвращает целую таблицу\n"+
                                                                                       "выполняется один раз\n"+
                                                                                       "требует аллиас\n"),
                ("346. Как оптимизировать использование подзапросов?","Менять IN на EXIST и наоборот. Сделать фильтрацию внутри подзапроса\n"+
                                                                      "Использовать JOIN, CTE, оконные функции"),

                ("347.Что происходит, если подзапрос возвращает несколько строк?","Нужно использовать IN, ALL, EXISTS или LIMIT 1\n"+
                                                                                  "Иначе будет ошибка\n"),

                ("348.В чем основное отличие LATERAL JOIN от обычного JOIN?","Подзапрос справа выполняется для каждой строки левой таблицы,\n"+
                                                                             "с возможностью доступа к ней"),

                ("349. Когда использование LATERAL JOIN может быть полезным?","1. Когда подзапросу нужны данные из текущей строки внешней таблицы.\n"+
                                                                              "2. Когда нужно получить ограниченное количество записей для каждой группы\n"+
                                                                              "3. Для генерации данных на основе значений строк\n"+
                                                                              "4. Когда нужно применять к каждому элементу массива\\JSON\n"),

                ("350.Приведите пример применения LATERAL JOIN в запросе.","SELECT d.department_name, e.employee_name, e.salary\n"+
                                                                           "FROM departments d\n"+
                                                                           "CROSS JOIN LATERAL(\n" +
                                                                           "SELECT employee_name, salary\n"+
                                                                           "FROM employees\n" +
                                                                           "WHERE department_id=d.department_id\n"+
                                                                           "ORDER BY salary DESC\n"+
                                                                           "LIMIT 3) e\n"),

                ("351. В чем отличие ROWS FROM от обычного подзапроса?","Объединяет результаты несколько функций в одну таблицу\n"+
                                                                        "SELECT * FROM ROWS FROM(функции) AS алиас\n"),

                ("352.Когда стоит использовать ROWS FROM?","1. Параллельная обработка связанных наборов данных\n"+
                                                           "2. Обработка JSON/массивов с сохранением структуры\n"+
                                                           "3. Генерация согласованных временных рядов\n"+
                                                           "4. Комбинирование данных разной длины\n"),

                ("353.Приведите пример использования ROWS FROM.","SELECT * FROM ROWS FROM(\n"+
                                                                 "unnest(ARRAY[1,2,3,4]),\n"+
                                                                 "unnest(ARRAY['a','b'])\n"+
                                                                 ") AS t(num,letter);\n"),

                ("354.Как можно заполнить пропуски в последовательности дат в PostgreSQL?","WITH date_range AS\n"+
                                                                                           "SELECT generate_series(\n"+
                                                                                           "'2023-01-01'::date,\n"+
                                                                                           "'2023-01-31'::date,\n"+
                                                                                           "'1 day'::interval\n"+
                                                                                           ")::date AS full_date)\n"+
                                                                                           "SELECT dr.full_date AS date,\n"+
                                                                                           "COALESCE(d.amount, 0) AS amount\n"+
                                                                                           "FROM date_range dr\n"+
                                                                                           "LEFT JOIN daily_date d ON dr.fuul_date = d.date\n"+
                                                                                           "ORDER BY dr.full_date\n"),

                ("355.Что такое рекурсивный CTE и как он помогает при заполнении пропусков?","это специальная конструкция SQL,\n"+
                                                                "которая позволяет обрабатывать иерархические или последовательные данные\n"+
                                                                "путем повторяющегося выполнения запроса до достижения заданного уровня\n"),

                ("356.Приведите пример запроса для заполнения пропусков в последовательности Рекурсия.","WITH RECURSIVE date_range AS(\n"+
                                                                                "SELECT \n"+
                                                                                "'2023-01-01'::DATE AS date,\n"+
                                                                                "'2023-01-31'::DATE AS end_date\n"+

                                                                                "UNION ALL\n"+
                                                                                "SELECT\n"+
                                                                                " date +1,\n "+
                                                                                "end_date\n"+
                                                                                "FROM date_range\n"+
                                                                                "WHERE date < end_date\n"+
                                                                                ")\n" +
                                                                                "SELECT d.date AS missing_date\n"+
                                                                                "FROM date_range AS  d\n"+
                                                                                "LEFT JOIN events e  ON d.date=e.event_date\n"+
                                                                                "WHERE e.event_date IS NULL\n"+
                                                                                "ORDER BY d.date\n"),

                ("357.Почему важно избегать подзапросов в SQL?","Коррелированные подзапросы выполняются для каждой строки внешнего запроса\n"+
                                                                "Множественные вложености увеличивают время выполнения экспонтециально\n"),

                ("358.Какой эффект дает удаление подзапросов в запросах?","Улучшение производительности\n"+
                                                                          "Снижение нагрузки на СУБД\n"+
                                                                          "Улучшение читаемости кода\n"),

                ("359.Приведите пример запроса до и после удаления подзапросов.","SELECT * FROM orders\n"+
                                                      "WHERE customer_id IN(SELECT id FROM customers WHERE premium = true)\n"+
                                                      "SELECT o.*\n"+
                                                      "FROM orders o\n"+
                                                      "JOIN customers c ON 0.customer_id = c.id AND c.premium = true;"),

                ("360.Чем отличается UNION от UNION ALL?","UNION удаляет дубликаты,работает медленнее потому что делает для этого сортировку\n"),

                ("361.Когда лучше использовать INTERSECT?","Когда нужно найти общие элементы в двух таблицах\n"),

                ("362. Приведите пример запроса с использованием UNION ALL.","SELECT id FROM A --(1,2,3)\n"+
                                                                              "UNION ALL\n"+
                                                                              "SELECT id FROM B --(3,4,5)\n"+
                                                                              "1,2,3,3,4,5\n"),

                ("363.Что такое generate\\_series в PostgreSQL?","это встроенная функция генерации полседовательных значений\n"+
                                                                 "Особенно полезна для создания временных рядов и числовых последовательностей\n"),

                ("364. Когда стоит использовать set generating functions?","1. Работа с массивами и JSON\n"+
                                                                           "2. Генерация тестовых данных\n"+
                                                                           "3. Анализ временных рядов\n"+
                                                                           "4. Обработка иерархических данных\n"+
                                                                           "5. Разбор строковых данных\n"+
                                                                           "6. Создание матриц и кросс-соединений\n"+
                                                                           ""),

                ("365.Приведите пример использования generate\\_series.","INSERT INTO users(id, name, registration_date)\n"+
                                                                         "SELECT id,'user' || id,\n"+
                                                                         "generate_series('2023-01-01'::date, '2023-12-31'::date, '1 day'::interval)::date\n"+
                                                                         "FROM generate_series(1,1000) AS id"),

                ("366. Как индексы влияют на производительность JOIN-запросов?","Ускорение поиска совпадений\n"),

                ("367.Какие типы индексов лучше всего подходят для улучшения производительности JOIN-запросов?","B-tree и hash\n"),

                ("368.Когда использование индексов на соединениях может привести к ухудшению производительности? ","При работе с маленькими таблицами\n"+
                                                                                                       "низкой селективности\n"+
                                                                                                      ""),

                ("369.В чём отличие ROLLUP от GROUPING SETS?","GROUP BY ROLLUP(a,b,c)\n"+
                                                              "GROUP BY GROUPING SETS((a,b,c),(a,b),(a),())\n"+
                                                              ""),
                ("370.Что вернёт GROUPING SETS ((a), (b), ())?","GROUP BY a,GROUP BY b, итого"),
                ("371. Как определить, была ли строка сгенерирована ROLLUP?","GROUPING(столбец) возвращает 0, если является\n"+
                                                                             "1 - если нет\n"),
                ("372.В чём отличие ROW_NUMBER() и RANK()?","ROW_NUMBER уникальный номер,сплошная нумерация\n"+
                                                            "RUNK одинаковый ранг для одинаковых значений"),

                ("373.Как работает LAG(column, 1)?","Это оконная функция, которая позволяет получить значение из предыдущей строки, 1 -смещение\n"),

                ("374. SUM(value) OVER (PARTITION BY user_id ORDER BY date)?","1. Создает отдельные группы для каждого пользователя\n"+
                                                                              "2. Нарастающий итог рассчитывается в рамках одной группы\n"+
                                                                              "3. При смене user_id сумма сбрасывается\n"+
                                                                              "ORDER BY date\n"+
                                                                              "Определяет порядок расчета нарастающего итога\n"+
                                                                              "Сумма считается от первой до текущей строки в группе\n"),

                ("375.Что такое CTE и зачем он нужен?","это временный результат запроса, который можно использовать в последующих SQL опреациях\n"+
                                                       "Это именованный подзапрос, определяемый с помощью конструкции WITH\n"+
                                                       "разбитие сложных запросов на логические блоки\n"+
                                                       "рекурсивные запросы\n"+
                                                       "несколько раз обратится к одному результату\n"+
                                                       "замена временных таблиц. Материализация запроса\n"),


                ("376.Можно ли использовать CTE внутри CTE?","Можно через запятую сделать цепочку\n"),

                ("377. Отличие CTE от подзапроса в FROM?","У CTE лучшая читаемость, множественное использование,возможно будет быстрее\n"),

                ("378.Какие 2 части есть у рекурсивного CTE?","Якорная часть -> UNION ALL ->Рекурсивная часть\n"),

                ("379.Как ограничить количество итераций в рекурсивном CTE?","Через WHERE"),

                ("380.Что произойдёт, если рекурсивный CTE не имеет выхода?","Завершится с ошибкой\n"),

                ("381.Что делает COALESCE(a, b, c)? ","возвращает первое не NULL"),

                ("382.Почему a = NULL не работает как ожидалось?","Нельзя сравнить неизвестное с NULL"),

                ("383.Чем отличается IS DISTINCT FROM от !=?","DISTINCT возврашает TRUE и FALSE\n"),

                ("384.В чём разница между обычным и материализованным view?","Обычное это виртуальная таблица, хранит в себе запрос\n"+
                                                                             "возвращает актуальные данные, но может быть медленнее\n"+
                                                                             "материализованное содержит в себе физическую копию\n"+
                                                                             "данные могут быть устаревшими, требуется обновление\n"+
                                                                             "быстрее так как читает предварительно вычисленные записи\n "),

                ("385.Как обновить материализованное представление?","REFRESH MATERIALIZED VIEW \n"),

                ("386.Можно ли использовать ORDER BY в обычном VIEW","Можно, но лучше делать при создании. Без этого нет гарантий\n"),

                ("387.Как удалить дубликаты, оставив только одну строку?","DISTINCT"),

                ("388.Почему DISTINCT не всегда помогает при удалении дублей из таблицы?","оставит только один NULL\n"+
                                                                                          "нужно четко задавать столбцы по уникальности\n"),

                ("389.Как быстро найти дубликаты по нескольким колонкам?","DISTINCT ON(столбцы...)"),

                ("390.Что делает ON CONFLICT (id) DO UPDATE?","Делает другую заданную операцию в случае возникновения конфликта\n"),

                ("391.Что делает RETURNING * в INSERT?","Возвращает все строки вставленной таблицы\n"),

                ("392.Можно ли использовать RETURNING с UPDATE?","Да будет получена строка с обновлениями\n"),

                ("393.Как работает WHERE (a, b) IN ((1, 2), (3, 4))?","Возвращает true при полном совпадении\n"),

                ("394.Какие ограничения есть у row value comparisons в Postgres?","Сравнение строк значений\n"+
                                                                                  "(a,b LIKE a,b) - не работает\n"+
                                                                                  "NULL работает иначе\n"+
                                                                                  "Ограничение по количеству элементов\n"+
                                                                                  "Ограничение по типу и работе с агрегатными фуцнкциями"),

                ("395.Чем отличается VALUES (1,2), (3,4) от обычного INSERT ... VALUES?","VALUES это самостоятельная констукция:\n"+
                                                                                         "В подзапросах\n"+
                                                                                         "в составе CTE\n"+
                                                                                         "в JOIN\n"+
                                                                                         "как источник данных в INSERT и SELECT\n"),

                ("396.Что такое generated column и как её создать?","Это столбец который вычисляется на основе других столбцов\n"+
                                                                    "бывают STORED и VIRTUAL\n"+
                                                                    "имя тип GENERATED ALWAYS AS(выражение) STORED"),

                ("397.Как связаны COALESCE и generated column при создании дефолтных значений?","Coalesce позволяет избежать NULL значений"),

                ("398.Можно ли использовать выражение с COALESCE внутри GENERATED ALWAYS AS?","Да"),

                ("399.Почему ILIKE '%word%' работает медленно на больших таблицах?","B-tree индекс не поддерживает % в начале\n"+
                                                                                     "Регистронезависимый поиск\n"+
                                                                                     ""),

                ("400. Чем SIMILAR TO отличается от LIKE?","SIMILAR TO использует простые регулярные выражения\n"),

                ("401.Как ускорить LIKE 'abc%'?","B-Tree индекс\n"+
                                                 "функциональный индекс для регистронезависмого поиска\n"+
                                                 "GIN индекс\n"+
                                                 "частичный индекс\n"),

                ("402.Что делает to_tsvector('english', text)?","Разбивает текст на лексемы, убирает предлоги и артикулы на основе языка"),

                ("403.Что делает оператор @@?","Выполняет проверку на соответствие между tsvector(индексированым текстом)\n"+
                                               "tsquery(поисковым запросом)\n"),

                ("404.Почему rank может быть полезен при полнотекстовом поиске?","Это функция ранжирует релеватность результата\n "),

                ("405.Чем websearch_to_tsquery отличается от plainto_tsquery?","planto_tsquery не поддерживает OR NOT и не сохраняет порядок слов\n"),

                ("406.Как обработается запрос \"deep learning\" -neural в websearch_to_tsquery?","Точное совпадение на фразу DEEP LEARING с исключением NEURAL"),

                ("407.В чём отличие ts_rank и ts_rank_cd?","ts_rank базовый алгоритм оценивает количество совпадений без близкости слов к друг другу\n"+
                                                           "ts_rank_cd с учетом взаимного расположения\n"),

                ("408.Как ts_rank определяет, какой результат релевантнее?","Частота терминов, вес полей, длина документа\n"),

                ("409. Как улучшить сортировку результатов по релевантности?","Настройка весов\n"+
                                                                               "Выбор функции ранжирования\n"+
                                                                               "Нормальзация по длине документа\n"),

                ("410.Какой индекс нужен для tsvector?","GIN можно с опцией и без нее\n"+
                                                        "GiST\n"+
                                                        ""),

                ("411.Почему tsvector стоит выделить в отдельную колонку?","Предварительное вычисление\n"+
                                                                           "Индексирование оптимальное\n"+
                                                                           "Избегает многократногшо парсинга текста"),

                ("412.Как создать индекс для виртуального tsvector-выражения?","CREATE INDEX idx ON table_name\n"+
                                                                               "USING gin(to_tsvector('english', text_column))"),

                ("413.Что делает ts_headline?","Это инструмент для выделения найденных теминов в тексте\n"),

                ("414.Какие параметры можно настроить в ts_headline?","StartSel, StopSel начало и конец слова\n"+
                                                                      "MaxFragments количество возвращаемых фрагментов\n"+
                                                                      "MaxWords,MinWords - количестов слов во фрагменте\n"+
                                                                      "FragmentDemiliter разделить между фрагментами\n"+
                                                                      "HighLigthAll если true это выделение слов"),

                ("415. В чем ключевое различие между JSON и JSONB?","JSON хранится как есть, быстрый\n"+
                                                                    "JSONB хранит в бинарном формате, удаляет лишние пробелы и оставляет только последнее значение по ключу\n"),
                ("416.Почему JSONB предпочтительнее при поиске по ключам и значению?","Преобразование в бинарное дерево\n"+
                                                                                      "поддержка специальных операторов @>\n"+
                                                                                      "возможность индексирования\n"+
                                                                                      "оптимизированные функции доступа jsonb_path_query\n"),

                ("417.Можно ли преобразовать JSON в JSONB и наоборот?","::jsonb::json\n"+
                                                                       "to_jsonb() to_json()\n"),

                ("418.Что произойдет при попытке вставить невалидный JSON в колонку типа JSON?","Выкинет ошибку с описанием\n"),

                ("419.Можно ли явно валидировать JSON-строку до вставки?","Через функцию или TryCAST "),

                ("420.Чем опасна вставка \"валидного, но неожиданного\" JSON?","Проблема безопасности\n"+
                                                                               "нарушение структуры данных\n"+
                                                                               "проблемы производительности\n"+
                                                                               "логические ошибки\n"),

                ("421.Какие функции используются для создания JSON-объектов и массивов?","jsonb_build_object()\n"+
                                                                                         "jsonb_object()\n"+
                                                                                         "jsonb_build_array()\n"+
                                                                                         "jsonb_object_agg()\n"),

                ("422.В чем разница между row_to_json и json_build_object?","Преобразование строки таблицы\n"+
                                                                            "Ключи это название столбцов, а значение строки\n"+
                                                                            "json_build_object ручное создание. Требует явного указания ключ:значения\n"),

                ("423.Как создать массив JSON объектов из результата запроса?","jsonb_agg(row_to_json(таблица))\n"+
                                                                                "array_to_json(array_agg(row_to_json(таблица)))"),

                ("424.Чем отличаются операторы ->, ->> и #>>?","-> вложенный json\n"+
                                                               "->> преобразование вложенного json в text\n"+
                                                               "#>> путь"),

                ("425.Как получить элемент массива по индексу?","[номер], array_element(столбец, номер)\n"+
                                                                "json_column->'array_key'->1"),

                ("426.Как извлечь вложенное значение по пути?","#>,#>>, jsonb_path_query(столбец,путь), json_extract_path(json,что извлечь)\n"),

                ("427.Что делает оператор @>?","Содержит ли первый документ часть второго\n"),

                ("428.Сработает ли @> с JSON?","Нет. Можно проверить через преобразоание "),

                ("429.Как проверить, есть ли ключ \"status\" в JSONB?","? - простое наличие ключа\n"+
                                                                       "jsonb_exists(jsonb,'status') возвращает true или false\n"+
                                                                       "#? для вложенных ключей\n"+
                                                                       "jsonb_exists_path(путь)"),

                ("430.Как проверить наличие хотя бы одного из ключей?","?| OR"),

                ("431.Какая функция превращает JSON в табличное представление?","jsonb_to_recordsetjson)"),

                ("432.Зачем нужен LATERAL при работе с json_to_recordset?","1. Позволяет обратится к предыдущей таблице\n"+
                                                                           "2. Позволяет обрабатывать данные последовательно,когда следующий шаг зависит от предыдущего\n"+
                                                                           "3. Фильтрация и комбинирование с другими функциями"),

                ("433.Как указать схему (тип) возвращаемых полей? ","Явное указание внутри запроса"),

                ("434.Как обновить значение по ключу в JSONB?","UPDATE table_name\n "+
                                                               "SET jsonb_column = jsonb_column || {'key':'new_value'}::jsonb\n"+
                                                               "json_set()\n"),
                ("435.Что делает jsonb_set без параметра create_missing?","Создает ключи только из json"),

                ("436.Как удалить ключ из JSONB?","UPDATE table_name\n"+
                                                  "SET jsonb_column = jsonb_column - 'key_to_remove'\n"+
                                                  "#- удаление по пути\n"+
                                                  "jsonb_set(установить null)\n"+
                                                  "jsonb_delete(column, 'key')"),

                ("437.Какой тип индекса использовать для поиска по ключам в JSONB?","GIN GiST"),

                ("438.Почему неэффективен BTree для JSONB?","Потому что требуется  четкий порядок сортировки"),

                ("439.Что делает jsonb_path_ops?","специальный оператор для GIN индексов, оптимизированный для работы с JSON"),

                ("440.Что означает “Seq Scan” в плане выполнения запроса?","Последовательное сканирование таблицы\n"),

                ("441.Как узнать, какой шаг в EXPLAIN ANALYZE занимает больше всего времени?","actual time или rows * loops"),

                ("442.Чем отличается EXPLAIN от EXPLAIN ANALYZE?","EXPLAIN показывает предполагаемый план выполнения,а\n "+
                                                                  "EXPLAIN ANALYZE фактически выполняет запрос\n"),

                ("443.Почему индекс может не использоваться, даже если он есть?","Неселективность запроса\n"+
                                                                                 "Несоответствие типа данных\n"+
                                                                                 "использование функции в условиях\n"+
                                                                                 "маленькая таблица\n"),

                ("444.Какие типы индексов есть в PostgreSQL?","B_tree\n"+
                                                              "HASH\n"+
                                                              "GIN\n"+
                                                              "GiST\n"+
                                                              "SP-GiST\n"+
                                                              "BRIN\n"+
                                                              "Bloom для большого количества =\n"),

                ("445.Что такое селективность и как она влияет на выбор плана?","Это статистическая характеристика, показывающая,\n"+
                                                                                "какая доля строк таблицы удовлетворяет условию запроса\n"+
                                                                                "0- условие не выбирает ни одной строки. Высокая селективность\n"+
                                                                                "1 - условие выбирает все строки\n"),

                ("446.Чем опасны CTE с точки зрения производительности?","Неудачное пстроение запроса\n"+
                                                                         "Постоянное переиспользование с вычислением\n"),

                ("447.Когда лучше использовать оконные функции, а не подзапросы?","Аналитические вычисления над группами строк\n"+
                                                                                  "Вычисления с доступом к соседним строкам\n"+
                                                                                  "Агрегация без сворачивания строк\n"+
                                                                                  "Накопительные итоги\n"+
                                                                                  "Разбиение на страницы\n"),

                ("448.Что делает ROW_NUMBER() OVER (PARTITION BY ...)?","Это оконная функция которая присваивает уникальный последовательный номер,\n"+
                                                                        "каждой строке в пределах группы\n"),

                ("449. Что такое атомарность транзакции?","Гарантия что транзакция либо выполняется полность или вообще не выполняется"),

                ("450.В чём отличие COMMIT и ROLLBACK?","Commit фиксация изменений\n"+
                                                        "ROLLBACK отмена всех изменений\n"),

                ("451. Как транзакции взаимодействуют с блокировками?","Блокировки обеспечивают изоляцию транзакций\n"+
                                                                       "согласованость данных\n"),

                ("452.Какие уровни изоляции поддерживает PostgreSQL?","Read Uncommitted, Read Committed, Repeatable Read, Serializable\n "),

                ("453.Что такое phantom read и при каком уровне оно возможно?","Одна транзакция видит новые строки после добавления другой транзакцией после начала первой\n"+
                                                                               "Read Committed\n"),

                ("454. В чём отличие Repeatable Read и Serializable?","Работают оба по снимку, но serializable прервет пересекающиеся транзакцию\n"),

                ("455. Какие типы блокировок есть в PostgreSQL?","Блокировки таблиц\n"+
                                                                 "Блокировки строк\n"+
                                                                 "Блокировка страниц(операции с индексами)\n"+
                                                                 "Транзакционные блокировки\n"+
                                                                 "Предикатные блокировки(блокируют условия)\n"+
                                                                 ""),

                ("456.Как посмотреть текущие блокировки в базе?","SELECT locktype, relation::regclass, mode, transactionid AS tid,\n"+
                                                                 "virtualtransaction AS vtid, pid, granted\n"+
                                                                 "FROm pg_locks"),

                ("457.Что делать, если транзакция повисла в состоянии блокировки?","Находим блокировку через большой код\n"+
                                                                                   "SELECT pg_terminate_backend(pid)\n"+
                                                                                   "FROM pg_stat_activity\n"+
                                                                                   "WHERE pid =[blocking_pid]"),

                ("458.Что такое 3-я нормальная форма (3NF)?","это этап нормализации реляционной базы данных, при котором таблица\n"+
                                                             "уже находится во второй нормальной форме(2NF), и в ней отсутствуют транзитивные зависимости\n"+
                                                             "между неключевыми атрибутами\n"),

                ("459.Зачем нужна нормализация?","это огранизация данных в базе для минимизации избыточности и аномалий\n"+
                                                 "Одинаковые данные хранятся в нескольких местах\n"+
                                                 "Избегать аномалий вставки и удаления\n"+
                                                 "Нормализация проще в обслуживании(изменения вносятся в одном месте, меньше риск неодназначных данных)\n"+
                                                 "повышение целосности за счет внешних ключей\n"+
                                                 ""),

                ("460.В чём минусы чрезмерной нормализации?","Чем больше таблиц тем болше JOIN\n"+
                                                             "данные которые должны быть вместе разделены\n"+
                                                             "падает скорость вставки\n"),

                ("461.Когда денормализация — это нормально?","Частые чтения и редкие обновления\n"+
                                                             "Критична производительность(OLTP,аналитика)\n"+
                                                             "Данные статичны(справочники, архивные записи)\n"+
                                                             "Система масштабируется горизонтально(NoSQL, кеши)\n"),

                ("462.Что можно использовать вместо денормализации? ","Материализированные представления\n"+
                                                                       "Индексирование и кеширование\n"),

                ("463.В чём риск денормализации? ","Риск нарушения целости данных\n"+
                                                   "Усложение обновлений\n"+
                                                   "Увеличение объема данных\n"+
                                                   "Изменение структуры данных становится труднее\n"),
                ("464.Чем MongoDB отличается от реляционных баз данных в плане структуры хранения данных?",""+
                                                   "1. Данные хранятся в документах(JSON-подобные BSON-структуры)\n"+
                                                   "2. Нет JOIN\n"+
                                                   "3. Схема не обязательна - разные документы в одной коллекции\n"+
                                                   "могут иметь разные поля\n"+
                                                   "4. Поддерживает массивы и вложенные объекты прямо в документе\n"+
                                                   "5. масштабирование(sharding) встроенно и работает из под коробки\n"),

                ("465. Что такое BSON, и чем он отличается от JSON?","это бинарный формат хранения данных,\n"+
                                                                     "используемый в MongoDB для эффективной работы с документами.\n"+
                                                                     "По сути, это улучшенная бинарная версия JSON с доплнительными возможностями\n"+
                                                                     "Поддержка специфических типов(ObjectId, ISODate, BinData)\n"+
                                                                     "Быстрый парсинг. не нужно преобразовать даты и числа в текст\n"),

                ("466.  Как документы могут быть организованы внутри коллекции в MongoDB?","1. Плоская структура(Flat Documents) минимальная вложенность\n"+
                                                                                           "2. Вложенные документы(Embedded Documents)\n "+
                                                                                           "      Документы содержат другие документы как значения полей\n"+
                                                                                           "      Естественно отражает отношения 'один-ко-многим' в пределах одного документа\n"+
                                                                                           "3. Ссылочная модель(Document References)\n"+
                                                                                           "      Документы ссылаются на другие документы через индефикаторы\n"+
                                                                                           "      Аналог отношений в реляционных базах\n"+
                                                                                           "4. Гибридный подход\n"+
                                                                                                  "Комбинация вложенных документов и ссылок\n"+
                                                                                                  "Часто используемые данные встраиваются, редко используемые - выносятся\n"+
                                                                                           "5. Денормализованные структуры\n"+
                                                                                               "Намеренное дублирование данных для ускорения запросов\n"+
                                                                                               "Часто используется в аналитических системах "),

                ("467.Как создать индекс на поле в MongoDB?","db.users.createIndex({username: 1})\n"+
                                                             "db.users.createIndex({username:1, age:-1})\n"+
                                                             "db.users.createIndex({username:1},{unique:true})\n"+
                                                             "db.users.createIndex({username: text})\n"+
                                                             "db.users.createIndex({username:1},{partialFilterExpression:{isActive:true}})\n"+
                                                             "db.users.createIndex({\"address.city\":1}) - на вложенное поле\n"+
                                                             "db.users.createIndex({tags:1})"),
                ("468.Как индексы могут улучшить производительность запросов?","Индексы в MongoDB работают аналогично оглавлению в книге\n"+
                                                                               "они позволяют быстро находить данные без полного сканирования всей коллекции\n"+
                                                                               "Замена COLLSCAN(полное сканирование) на IXSCAN(сканирование по индексу B-tree) "),

                ("469.Что такое агрегатные запросы в MongoDB?","Это аналог GROUP BY, JOIN и оконных функций, но с более гибким синтаксисом\n"+
                                                               "$match Фильтрация документов\n"+
                                                               "$group группировка\n"+
                                                               "$sort\n"+
                                                               "$project аналог SELECT\n"+
                                                               "$lookup аналог Left Join\n"+
                                                               "$unwind разворачивание массивов\n"+
                                                               "$count\n"+
                                                               "$limit"),

                ("470. Как можно выполнить группировку данных в MongoDB?","db.collection.aggregate([\n"+
                                                                          "{\n"+
                                                                          "$group: {\n"+
                                                                          "  _id: \"$группируемое_поле\", //Поле для группировки \n"+
                                                                          "  поле_результата: {$оператор: \"$поле\"} // вычисляемые значения\n "+
                                                                          "}\n"+
                                                                          "}\n"+
                                                                          "])\n"),
                ("471.Как работает оператора $match в агрегации? ","Оператор $match в агрегационных пайплайнах MongoDB выполняет фильтрацию документов\n"+
                                                                   "аналогично методу find(). Он отбирает только те документы,\n"+
                                                                   "которые соответсвуют заданным условиям, и передает их следующим стадиям пайплаина\n"+
                                                                   "db.collection.aggregate([\n"+
                                                                   "{\n"+
                                                                   "$match: {\n"+
                                                                   "поле: условие\n"+
                                                                   "}\n"+
                                                                   "}\n"+
                                                                   "])"),

                ("472.Что такое OLAP-куб?","Это многомерная структура данных, оптимизированная для быстрого анализа\n"+
                                           "больших объемов информации\n"),

                ("473.В чем отличие между OLAP и OLTP?","    OLAP это анализ больших исторических данных для\n"+
                                                        "Оптимизирован для быстрого чтения и анализа больших наборов данных\n"+
                                                        "Денормализованные схемы(звезда, снежинка) или многомерные кубы\n"+
                                                        "Анализирует большие исторические архивы\n"+
                                                        "ClickHouse,Amazon Redshift, snowflake\n"+
                                                        "Аналитики, руководители\n"+
                                                        "Данные загружаются периодически, изменяются редко\n"+
                                                        "   OLTP обработка операционных транзакций в реальном времени\n"+
                                                        "Короткие, простые (вставка,обновление, удаление)\n "+
                                                        "Высокая скорость записи и чтения отдельных записей\n"+
                                                        "Нормализованные таблицы(минимизация избыточности)\n"+
                                                        "Работает с текущими, часто изменяемыми данными\n"+
                                                        "PostgreSQL\n"+
                                                        "Данные постоянно обновляются"),
                ("474.Какой основной принцип отличается OLAP от OLTP в плане архитектуры?","Архитектура OLTP: \"Быстрые транзакции\""+
                                                                                           "1. Нормализованные таблицы(3NF и выше)\n"+
                                                                                           " Данные разбиты на множество связанных таблиц для минимизации дублирования\n"+
                                                                                           "2. ACID гарантии\n"+
                                                                                           "   Каждая транзакция должна быть атомарной и согласованной\n"+
                                                                                           "3. Высокая конкуренция за запись\n"+
                                                                                           "Архитектура OLAP: \"Анализ больших данных\""+
                                                                                           "1. Денормализованные схемы: Звезда и снежинка\n"+
                                                                                           "2. Колоночное хранение(вместо строчного)\n"+
                                                                                               "Данные хранятся по столбцам,что ускоряет агрегацию(SUM)\n"+
                                                                                           "3. OLAP кубы заранее вычисляют суммы\\средние для ускорения запросов\n"),

                ("475.Почему OLAP-системы часто требуют сложной инфраструктуры?","1.Обработка огромных данных\n"+
                                                                                 "2. Специфические модели хранения: колоночные базы данных, многомерные кубы, распределенные хранилища\n"+
                                                                                 "3. Высокие вычислительные затраты:сканирование миллионов строк,множественные GROUP BY. \n"+
                                                                                 "4. ETL - конвейры. Данные должны извлекаться из OLTP источников, очищаться и трансфармироваться, загружаться в оптимизированное хранилище\n"+
                                                                                 "5. Масштабируемость OLAP системы часто строятся на кластерах из сотен узлов, репликации данных между дата-центрами\n"+
                                                                                 "6. Оптимизации для аналитики. Предварительные агрегаты, индексы для ускорения запросов, кэширование результатов\n"),

                ("476.Формы нормализации","1NF\n"+
                                          "Каждый элемент в столбце имеет свой первичный ключ\n"+
                                          "2NF\n"+
                                          "Отсутствие частичных зависимостей от первичного ключа у каждой сущности свой первичный ключ. Деление на таблицы\n"+
                                          "3NF\n"+
                                          "неключивые атрибуты незвисят от других не ключевых атрибутов\n"+
                                          "BCNF\n"+
                                          "у каждой функциональной зависимости X->Y, X должен быть суперключом\n"+
                                          "4NF\n"+
                                          "нет нетравиальных многозначных зависимостей\n"+
                                          "5NF\n"+
                                          "нет нетравиальных зависимостей\n"),

                ("477. Стандартные опрерации PostgreSQL","Создание таблицы:\n"+
                                                         "CREATE TABLE [IF NOT EXISTS] table_name(\n"+
                                                         "column name\n"+
                                                         ")[WITH допы]\n"+"" +
                                                         "Изменение таблицы:\n"+
                                                         "ALTER TABLE table_name ADD COLUMN column_name data_type\n"+
                                                         "ALTER TABLE table_name DROP COLUMN [IF EXISTS] column_name [CASCADE]\n"+
                                                         "ALTER TABLE table_name RENAME COLUMN old_name TO new_name\n"+
                                                         "ALTER TABLE table_name ALTER COLUMN column_name TYPE new_data_type\n"+
                                                         "ALTER TABLE table_name ALTER COLUMN column_name SET DEFAULT value\n"+
                                                         "ALTER TABLE table_name ALTER COLUMN column_name DROP DEFAULT\n"+
                                                         "ALTER TABLE table_name ADD CONSTRAINT constraint_name constraint_definition\n"+
                                                         "ALTER TABLE table_name DROP CONSTRAINT [IF EXISTS] constraint_name [CASCADE]\n"+
                                                         "Удаление таблицы:\n"+
                                                         "DROP TABLE [IF EXISTS] table_name [CASCADE | RESTRICT]\n"+
                                                         "TRANCATE [TABLE] [ONLY] table_name [RESTART IDENTITY | CONTINUE IDENTITY] [CASCADE | RESTRICT]\n"),

                ("478.Операторы сравнения в MongoDB","1. $eq: = \n"+
                                                     "2. $ne: !=\n"+
                                                     "3. $gt: >\n"+
                                                     "4. $gte: >=\n"+
                                                     "5. $lt: <\n"+
                                                     "6. $lte: <=\n"+
                                                     "7. $in: равно любому из\n"+
                                                     "8. $nin: неравно любому значению\n"+
                                                     "9. $exists: true есть ли такое поле\n "+
                                                     "10. $type проверка типа данных"),

                ("479. Проекция C#","Позволяет преобразовать объект одного типа в объект другого типа\n"+
                                    "с помощью оператора Select\n"+
                                    "var names= from p in people select p.name\n"+
                                    "SELECT(Func<TSourse>,<TResult> selector)\n"+"" +
                                    "var personel = from p in people\n"+
                                    "select new\n "+
                                    "{\n"+
                                    "FirstName=p.Name\n"+
                                    "Year=DateTime.Now.Year - p.Age\n"+
                                    "}\n"),

                ("480.Переменные let","var personnel = from p in people\n"+
                                      "let name = $\"MR.{p.Name }\"\n"+
                                      "let year = DateTime.Now.Year - p.Age\n"+
                                      "select new\n"+
                                      "{\n"+
                                      "Name = name,\n"+
                                      "Year = year\n"+
                                      "};\n"),

                ("481. SelectMany","SelectMany(Func<TSource, IEnumerable<TResult>> selector)\n"+
                                   "SelectMany(Func<TSource, IEnumerable<TCollection>> collectionSelector, Func<TSource, TCollection,TResult>resultSelector)\n"+
                                   ""),
                ("482. Where","Where<TSourse>(Func<TSource,bool>predicate)\n"+
                              "var selectedPeople = from p in people\n"+
                              "where p.Age>25\n"+
                              "select p\n"+
                              ""),
                ("483.фильтрация по типу\n","var students=peiople.OfType<Student>()\n"),

                ("484. Методы агрегации","Aggregate((x,y)=>x+y сложит все значения\n"+
                                         "Count(), Sum(), Min(), Max(), Average()\n"),
                ("485. Функции генераторы","Enumerable.Range(), Enumerable.Repeat()\n"+
                                           "()=>T[]"),
                ("486. Статические функции","Возвращают либо число либо логическое значение\n"+
                                            "Any(), Count(), Single()\n"+
                                            "T[]=>число, T[]=>bool\n"),
                ("487.Функции проекторы","Принимают коллекцию T возвращают коллекцию U\n"+
                                         "Select(), SelectMany(), Cast<T>()\n"+
                                         "T[]=>U[]"),
                ("488. Функции фильтры","T[]=>T[]\n"+
                                        "T[]=>T\n"+
                                        "Where(), First(), Last()\n "),

                ("489. Советы по LINQ","1. Избегать проецирования ToList ToArray\n"+
                                       "2. Все возможные фильтры в одно Where\n"+
                                       "3. Использовать TrueOfAll() в IList<T> вместо All()\n"+
                                       "4. Использовать OrderBy() вместо Sort()\n+" +
                                       "5. Не использовать Contains как лямбду. Если необходимо то HashSet.Contains\n"+
                                       "6. Лучше Count>0 чем Any()\n"+
                                       "7. Нежелательно использовать ElementAt на индексируемые коллекции. Если нужно то можно преобразовать\n"+
                                       "8. Неиспользовать ElementAt на dictionary. При необходимости использовать List<KeyValuePair<T,U>>\n"+
                                       "9. Предпочитайте обработку исключений методам ElementAtOrDefault(), FirstOrDefault() или SingleOrDefault().\n"+
                                       "10. Не имеет смысла использовать First(), Last() вместо индекса 0 и Count-1\n"+
                                       "11. Использовать IEnumerable<T> как можно чаще\n"+
                                       "12. Sum и Average медленнее чем простой цикл\n"+
                                       "13. Создайте свой собственный ForEach(Action<T>), который может работать с экземпляром IEnumerable<T>\n"+
                                       "14. Лучше Select<T> вместо Cast<T>\n"+
                                       "15. Если поддерживается Count==0 вместо любого ()\n "+
                                       "16. Aggregate работает медленнее for\n"+
                                       "17. FirstOfDefault лучше не использовать в циклах. Решение это HashSet Dictionary\n"),

                ("490.Объект Lookup"," это последовательность групп, в которую можно получать доступ на прямую к ключу\n"+
                                      "это словарь последовательностей, котрый способен принимать множество элементов для одного ключа\n"),

                ("491. IEnumerable<T>","IEnumerable<T> содержит в себе GetEnumerator. Возвращает IEnumerator<T> \n"+
                                       "1. ленивая загрузка. Данные загружаются по мере необходимости\n"+
                                       "2. Работает в памяти(In-Memory). Все операции на стороне клиента\n "+
                                       "3. LINQ to object(запросы к коллекциям)\n"+
                                       "4. Не может напрямую транслироваться в SQL\n"),

                ("492.IQuerayble<T>","IQuerayble<T>\n"+
                                     "Содержит методы:\n"+
                                     "AsQueryably() преобразует IEnumerable в IQueryably\n"+
                                     "Provider дает доступ к провайдеру запросов\n"+
                                     "Expression возвращает дерево выражений запросов\n"+
                                    "1. Ленивая загрузка, Запрос строится, но выполняется только при перечеслении\n"+
                                    "2. Может транслироваться в SQL\n"+
                                    "3. LINQ to Entities, LINQ to SQL\n"+
                                    "4. Фильтрация, сортировка и другие операции выполняются на стороне сервера\n"),
                ("493.ICollection<T>","ICollection<T>\n"+
                                      "Базовый интерфейс для изменяемых коллекций\n"+
                                      "Поддерживает проверку, добавление, удаление элементов\n"+
                                      "List<T>, HashSet<T>, Queue<T>\n"),

                ("494. IList<T>","IList<T>\n"+
                                 "Добавляет индексированный доступ list[0]\n"+
                                 "Поддерживает вставку и удаление по индексу\n"+
                                 "List<T>, Array\n"),

                ("495. IReadOnlyCollection<T> IReadOnlyList<T> ","Представляют только доступ к чтению\n"+
                                                                 "Не поддерживает изменение коллекции\n "+
                                                                 "Полезны для безопасного возврата данных из метода\n"),

                ("496. Итератор","Итератор это объект позволяющий перемещаться по элементам коллекции\n"),

                ("497. GetEnumerator","Это метод, который возвращает итератор(объект, реализующий IEnumerator или IEnumerator<T> ),\n"+
                                      "позволяющий последовательно перебирать элементы коллекции\n"),
                ("498. Разница между операторами запроса и методами расширения","Запросы похожи на SQl запросы и более понятны для сложного синтаксиса\n"+
                                                                                "расширения имеют больше методов и можно комбинировть с обычным кодом\n"),

                ("499. Семейства запросов","1. Фильтрование Where(), OfType()\n"+
                                           "2. Проекция Select(), SelectMany()\n"+
                                           "3. Селекционирование Skip(),SkipWhile(), Take(), TakeWhile()\n "+
                                           "4. Соединение Join GroupJoin\n"+
                                           "5. Конкатенация Concat\n"+
                                           "6. Упорядочивание OrderBy(), Reverse()\n"+
                                           "7. Группировка GroupBy, ToLookUp()\n"+
                                           "8. Набор Disticnt, Intersect,Except\n"+
                                           "9. Преобразование AsEnumerable, AsQuerably,Cast, ToArray()\n"+
                                           "10. Равенство SequanceEqual\n"+
                                           "11. Элемент ElementAt, First, Last, FirstOfDefault()\n"+
                                           "12. Генерация DefaultIfEmpty, Empty, Range, Repeat\n"+
                                           "13. Квантификаторы все содержат\n"+
                                           "14. Aggragate, Average, Max, Min\n"),

                ("500. Выражение запросов LINQ","from [type] id in source\n"+
                                                "join [type] id in source on expr equals expr [into id]\n"+
                                                "from [type] id in source let id =expr |where condition\n" +
                                                "orderby ordering\n"+
                                                "select expr group expr by key\n" +
                                                "into id query\n"),
                ("501. Пространство имен","System.Linq\n"+
                                          "System.Linq.Expressions позволяет использовать деревья выражений\n"+
                                          "System.Data.Linq для баз\n"+
                                          ""),

                ("502. Сборщик мусора определение","Это процесс автоматического управлению памятью в куче,\n"+
                                                   "заключается в поиске неиспользуемых участков памяти\n"+
                                                   "которыt ранее использовались программой\n"),

                ("503. что такое Span<T>","Это структура, которая представляет собой типобезопасное и безопасное \n"+
                                          "с точки зрения памяти представление непрерывной области памяти,\n "+
                                          "независимо откуда эта память взята(управляемый массив, стэк или неуправляемая память)\n"+
                                          "нельзя хранить в куче\n"+
                                          "нельзя использовать в async методах так как ref struct\n"),

                ("504. что такое Memory<T>","Это структура C#, предстовляющие безопасное и гибкое хранение непрерывной области памяти\n"+
                                            "аналогично Span, но без ограничений ref struct\n"+
                                            "Это значит что Memory<T> можно использовать в асинхронных методах, хранить в куче\n"+
                                            "и передавать между методами\n"+
                                            "Управляемые массивы\n"+
                                            "Память выделенную с помощью MemoryPool<T>\n"+
                                            "неуправляемую память через Marshal или unsafe\n"),

                ("505.Запахи кода","Раздувание(Bloaters) - 5 запахов\n"+
                                   "Нарушители ООП(Object-Orientation-Abusers) - 4 типа \n"+
                                   "Припятствия для изменений(Change Preventers) - 3 типа\n"+
                                   "Диспенсеры(Dispensables) - 5 типов\n"+
                                   "Связаность(Couplers) - 5 типов\n"),

                ("506. Раздувание методов","Если метод становится большим и появляется необходимость комментировать нужно его разделить\n"+
                                   "1. Извлечение метода\n"+
                                   "2. Замена временной переменной вызова методом\n"+
                                   "3. Замена параметров объектом и передача всего объекта\n"+
                                   "4. Замена метода классом с  методами \n"+
                                   "5. Разбиение условного оператора на методы\n"),

                ("507. Раздувание класса","Если класс содержит множество полей, методов\n"+
                                          "Извлечение класса\n"+
                                          "Извлечение подкласса, если есть альтернативное использование класса\n"+
                                          "Извлечение интерфейса\n"),

                ("508. Одержимость элементарными типами","Использование констант и элементарных типов\n"+
                                                         "Замена простого поля объектом\n"+
                                                         "Замена массива объектом\n"),

                ("509. Длинный список параметров","Если параметров больше 3 -4\n"+
                                                  "Замена параметра вызовом метода\n"+
                                                  "Передача объекта целиком или частично\n"),

                ("510. Группы данных запах","Если одно значение удалить, а другие потеряют свой смысл, то группу нужно объединить\n"+
                                            "Извлечение класса\n"+
                                            "замена параметов объектом\n"+
                                            "передача всего объекта\n"),

                ("511. Нарушители объектно - ориентированного дизайна","1. Сложный switch или последовательность if\n"+
                                                                       "2. Временнные поля - это поля, которые нужны только при определенных обстоятельствах\n"+
                                                                       "     заполняются значениями только, когда нужны. остальное время пустые\n"+
                                                                       "3. Если подкласс использует лишь малую часть унаследованных методов и свойств суперкласса,\n"+
                                                                        "   это является признаком неправильной иерархии\n"+
                                                                        "    При этом ненужные методы могут просто не использоваться или быть переопределенными и выкидывать ошибку\n"+
                                                                        "4. Два класса выполняют одинаковые функции, но имеют разные названия методов\n"),

                ("512.Утяжелители изменений ","При внесений изменений в одну часть программы, приходится делать много изменений в другой\n"+
                                              "1. При внесении в класс приходится изменять большое число различных методов\n"+
                                                   "Извлечение класса, извлечение суперкласса, подкласса\n"+
                                               "2. При выполнений любых модификаций приходится вносить много мелких изменений в большое число классов\n"+
                                               "    Перемещение метода или поля в класс, где метод или поле используется чаще\n"+
                                               "    Встраивание класса, чтоб избавится от пустых классов\n"+
                                               "3. Параллельные иерархии наследования. При создании одного подкласса приходится создавать подкласс другого класса\n"+
                                               "    Перемещение методов и полей в класс, который использует их чаще\n"+
                                               ""),
                ("513. Замусориватели ","Что то бесполезное и лишнее\n"+
                                        "1. Метод содержит много комментариев\n"+
                                        "    Извлечение переменной, извлечение метода, переименнование метода, введение утверждения\n"+
                                        "2. Дублирование кода\n"+
                                         "    Извлечение метода с последующим подъемом полей\n"+
                                         "    Если общий конструктор то подъем конструктора\n"+
                                         "   Если участки кода похожи, но не совпадают полностью то создание шаблонного метода\n"+
                                         "   Если оба метода делают одно и тоже но с помощью разных алгоритмов, то нужна замена алгоритма\n"+
                                         "2.1 Дублирующийся код находится в двух разных классах\n"+
                                         "   Извлечение суперкласса, если не допустимо то извлечение класса\n"+
                                         "2.2 Присутствует череда условных операторов\n"+
                                         "    объединение условных операторов, а также применять извлечение метода, чтоб вынести это условие в отдельный метод\n"+
                                         "2.3 Один и тот же код выполняется во всех ветках условного оператора\n"+
                                         "    Вынести код за пределы условного оператора с помощью объединения дублирующихся фрагментов в условных операторах\n "+
                                         "3. Ленивый класс если класс делает не достаточно много, то он должен быть уничтожен\n"+
                                          "  бесполезные компонеты должны быть подвергнуты встраиванию класса\n"+
                                          " При наличии подклассов с недостаточными функциями свертывание иерахии\n"+
                                          "4. Классы данных это классы, которые содержат только поля и простейшие методы для доступа к ним геттеры и сеттеры\n"+
                                          "    Приминение инкапсуляции к полям, инкапсуляция для коллекции\n"+
                                          "    Создание функциональности с помощью перемещения метода и извлечение метода\n"+
                                           "После добавления методов возможно стоит удалить сеттер и сокрыть метод\n "+
                                           "5. Мертвый код. Встраивание класса, схлопавние иерархии, удаление параметров\n"+
                                           "6. Теоритическая общность. Код, который предполагалось использовать, но так и не был использован \n"+
                                           "сворачивание иерархии, встраивание класса, встраивание метода, удалению параметров\n "+
                                           ""),
                ("514.Опутыватели связи","1. Завистливые функции. Метод чаще обращается к данным чужого объекта чем своим\n"+
                                          "  Если метод нужно перенести в другой метод то использовать перемещение метода\n +" +
                                          "   Если только часть метода обращается к данным другого объекта, примените извлечение метода к этой части\n "+
                                          "   Если обращения в разные объекты то перемещение также в разные\n"+
                                          "2. Неуместная близость. Один класс использует служебные поля и методы другого класса\n "+
                                          "     Самый простой способ перемещение метода и поля, если оригинальный класс их не использует\n"+
                                          "     Извлечение зависимых частей в отдельный класс или сокрытие делегирования\n"+
                                          "     Замена двунаправленной связи однонаправленной\n"+
                                          "     Замена делегирования наследованием\n"+
                                          "3. Цепочка вызовов. Клиент запрашивает у одного объекта другой объект\n"+
                                          "      Для удаления цепочки используют сокрытие делегирования\n"+
                                          "        Возможно имеет смысл извлечь нужный метод и переместить в самое начало цепи\n"+
                                          "4. Посредник. Класс выполняет единственное действие это делегация другому классу\n"+
                                          "    Может быть результатом фанатичной борьбы с цепочкой вызовов\n"+
                                          "      Можно просто удалить класс посредник\n"),

                ("515. Неполнота библиотечного класса","Единственное решение изменение библиотеки\n"+
                                                       "Введение внешнего метода\n"+
                                                       "Введение локального расширения\n"),

                ("516. SOLID","S\n"+
                          "Принцип единственной ответственности(single resposability) - принцип ООП, обозначающий что каждый объект должен иметь одну ответственность\n"+
                          "и эта ответственность должна быть полностью инкапсулирована в класс.\n"+
                          "Все его поведение должно быть направлены исключительно на обеспечение этой ответственности\n\n"+
                          "O\n"+
                          "Принцип открытости-закрытости(open-closed principale) - принцип ООП, устанавливающий следующее положение:\n"+
                          "програмные сущности должны быть открыты для расширения, но закрыты для изменения\n\n"+
                          "L\n"+
                          "Принцип подстановки Лисков(Liskov substition principle) - в объекто-ориентируемом программировании является\n"+
                          "специфичным определением подтипа, предложенным Барбарой Лисков в 1987 году на конференции в основном докладе под\n"+
                          "названием Абстракция данных и иерархия. Роберт Мартин определил этот тип: \n"+
                          "Функция, которая использует базовый тип, должна иметь возможность использовать подтипы базового типа не зная об этом\n\n"+
                          "I\n"+
                          "Принцип разделенения интерфейса(interface segregation principle)\n "+
                          "Програмнные сущности не должны зависеть от методов, которые они не используют. Принцип разделения интерфейсов говорит,\n"+
                          " о том, что слишком толстые интерфейсы должны быть разделены на более мелкие и специфические, чтоб\n"+
                          "програмные сущности маленьких интерфейсов знали только о методах, которые необходимы им в работе\n"+
                          "В итоге, при изменении метода интерфейса не должны меняться программные сущности, которые этот метод не используют\n\n"+
                          "D\n"+
                          "Принцип инверсии зависимостей(dependency inversion principle) - важный принцип объекто - ориентированного программирования,\n "+
                          "используемый для уменьшения зацепления в компьютерных программах\n"+
                          "Модули верхних уровней не должны импортировать сущности модулей нижних уровней. Оба типа модулей должны зависеть от абстракций\n "+
                          "Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракции\n\n"),

                ("517. Чтот такое SOLID","SOLID в программировании, это мнемонический акроним, введенный Майклом Фэзерсом\n"+
                                         "для первых пяти принципов, названных Робертом Мартином в 2000-х,\n"+
                                         "которые означали 5 основных принципов объекто ориентированного программирования и проектирования\n"),

                ("518. Для чего нужен SOLID","При создании программных систем использование принципов SOLID\n"+
                                             "способствует созданию такой системы, которую будет легко поддерживать\n"+
                                             "и расширять в течение долгого времени\n"),

                ("519. что такое  YANGI","YANGI это процесс и принцип проектирования ПО, при котором\n"+
                                         "в качестве основной цели или ценности декларируется отказ \n"+
                                         "от избыточной функциональности, - то есть отказ добавления функциональности\n"+
                                         "в которой нет непосредственной надобности\n"),

                ("520. Недостатки YANGI","1. Трататися время на добавление, тестирование и улучшение необходимой функциональности\n"+
                                          "2. Новые функции должны быть отлажены, задокументированы и сопровождаться\n"+
                                          "3. Новая функциональность ограничивает то, что может быть сделано в будущем,\n"+
                                          "- ненужные новые функции могут впоследствии помешать добавить новые нужные\n"+
                                          "4. Пока новые функции действительно не нужны, трудно полностью предугадать\n"+
                                          "что они должны делать и протестировать их. Если функции тщательно не протестированы\n"+
                                          "они могут неправильно работать, когда впоследствии понадобятся\n"+
                                          "Это приводит к тому, что программное обеспечение становится более сложным\n"+
                                          "5. Если функциональность не документирована, она может так и остаться неизвестной пользователю\n"+
                                          "что может создать различные риски для безопасности пользовательской системы\n"+
                                          "6. Добавление новой функциональности может привести к добавлению еще новой функциональности\n"+
                                          "и это создаст снежный ком\n"),
                
                ("521. Принцип KISS","Принцип KISS утверждает, что большинство систем работают лучшего всего\n"+
                                     "если они остаются простыми, а не усложняются\n"+
                                     "Практически все принципы проектирорвания направлены на достижения понятности кода\n"+
                                     "Нарушая какой либо принцип проектирования, вы уменьшаете понятность кода.\n"+
                                     "Непонятный код автоматически вызывает у человека ощущение того, что код сложный,\n"+
                                     "так как его сложно понимать и модифицировать. При нарушении любого из этих принципов\n"+
                                     "также и нарушается и принцип KISS. Поэтому можно считать что принцип KISS включает\n"+
                                     "почти все остальные принципы проектирования. Паттерны проектирования описывают\n"+
                                     "наиболее удачные, простые и понятные решения некоторых проблем.\n"+
                                     "если вы используете паттерн проектирования там, где нет проблемы\n"+
                                     "которую решает данный паттерн - то вы нарушаете KISS, внося ненужные усложнения в код\n"+
                                     "Если вы не используете паттерн проектирования там, где  есть проблема, соответствующая паттерну\n"+
                                     "- то вы опять нарушаете KISS делая код сложнее, чем он мог быть\n "),

                ("522. Принцип DRY","Don,t repeat yourself - это принцип разработки, нацеленный на снижение повторений информации\n"+
                                    "различного рода, особенно в системах со множеством слоев абстрагирования.\n"+
                                    "Принцип DRY формулируется как <<<Каждая  часть знаний должна иметь единственное, непротиворечивое и\n"+
                                    "авторитетное представление в рамках системы.>>> Когда принцип DRY применяется успешно\n"+
                                    "изменение единственного элеметна не требует внесения изменений в другие, логически не связанные\n"+
                                    "То есть элементы логически связанные, изменяются предсказуемо и единообразно\n"+
                                    "Дублирование кода - это пустая трата времени и ресурсов\n"+
                                    "Вам придется поддерживать одну и ту же логику и тестировать в двух местах сразу\n "+
                                    "при чем если вы измените код в одном месте, его будет нужно изменить в другом месте\n"+
                                    "В большинстве случаев дублирование кода происходит из - за не знания системы\n"+
                                    "Прежде чем писать код убедитесь что где реализована такая функция или бизнес логика\n"),

                ("523.Основные приницы ООП","1. Инкапсуляция\n"+
                                            "2. Наследование\n"+
                                            "3. Полиморфизм\n"),


                ("524. Инкапсуляция","Это принцип ООП,который заключается в:\n" +
                                      "объединении данных(полей) и методов (функций), работающих с этими данными\n"+
                                      "в единый компонент(класс) и ограничении прямого доступа к внутреннему состоянию объекта извне\n"+
                                      "Ключевые аспекты:\n"+
                                      "1. Сокрытие реализации\n"+
                                      "    Внутренние детали работы объекта скрыты от внешнего кода.\n"+
                                      "Пользователь класса взаимодействует с ним только через публичный интерфейс(методы и свойства),\n"+
                                      "не зная как устроена внутренняя логика\n"+
                                      "2. Использование контроля доступа(public, private)\n"+
                                      "3. Управление состоянием объекта\n"+
                                      "Инкапсуляция позволяет гарантировать, что состояние объекта всегда будет корректным,\n"+
                                      "благодаря проверкам в методах(сеттеры свойств)\n"),

                ("525. Наследование","Это механизм ООП, при котором один класс(производный или дочерний) может\n"+
                                     "наследовать поля, свойства и методы другого класса(базового, родительского)\n"+
                                     "Это позволяет повторно использовать код и создавать иерархии классов\n"+
                                     "Плюсы наследования: " +
                                     "1. Повторное использование кода\n"+
                                     "2. Упрощение архитектуры\n"+
                                     "3. Поддержка полиморфизма(переопределение методов через virtual, override)\n"+
                                     "Минусы:\n"+
                                     "1. Жесткая связь между классами(изменение базового класса влияет на наследников)\n"+
                                     "2. Невозможность множественного наследования\n"+
                                     "3. Риск создания сложных иерархий\n"),

                ("526. Полиморфизм","Это принцип ООП, который позволяет одному и тому же коду работать c разными типами данных,\n"+
                                    "обеспечивая гибкость и расширяемость программы\n"+
                                    "Полиморфизм реализуется через:\n"+
                                    "1. Переопределение методов(virtual и override)\n"+
                                    "2. Абстрактные методы и классы(abstract)\n"+
                                    "3. Интерфейсы\n"+
                                    "4. Перегрузку методов(method overloading)\n"),

                ("527. Модификаторы доступа C#","1. public - везде\n"+
                                                "2. private только внутри класса\n"+
                                                "3. protected класс и наследники\n"+
                                                "4. internal в пределах сборки\n"+
                                                "5. protected internal Класс+наследники+сборка\n"+
                                                "6. private protected только наследники в текущей сборке\n"),

                ("528. Record ","Они предназначены для упрощения работы с неизменяемыми данными и \n"+
                                 "и представляют удобные возможности для сравнения,копирования и работы с объектами\n"+
                                 "== в record сравнивает по значению\n"+
                                 "автоматические методы ToString(), Equals(), GetHashCode() на основе свойств\n"+
                                 "with для создания копии, но с изменениями\n"+
                                 "можно объявлять как классы с конструктором и деконстуктором\n"+
                                 ""),

                ("529. Sealed","запечатывает класс и от него нельзя наследоваться\n"),

                ("530. Методы object","1. Equals()\n"+
                                       "Возвращает true если объекты ссылаются на один и тот же объект в памяти\n"+
                                       "Чаще всего метод переопеределяется. Если Equals переопределен, то и GetHashCode должен быть переопределен\n"+
                                       "так как данные методы используются внутренними типами Hashtable для извлечения подъектов из контейнера\n "+
                                       "2. Finalize()\n"+
                                       "Вызывается когда переопределен для освобождения любых выделенных ресурсов перед уничтожением объекта\n"+
                                       "3. GetHashCode\n возвращает int который идентифицирует конкретный объект\n"+
                                       "4. ToString()\n"+
                                       "Этот метод возвращает строковое представление объекта в формате <пространство имен>.<имя типа>\n" +
                                       "Чаще всего переопределяется\n" +
                                       "5. GetType()\n"+
                                       "Этот метод возвращает объект Type, полностью описывающий объект,\n"+
                                       "на который в текущий момент производится ссылка\n"+
                                       "идентификатор типа объекта\n"+
                                       "6. MemberwiseClone\n"+
                                       "метод возвращает копию текущего объекта\n"+
                                       "7. статические члены ReferenceEquals и Equals\n"+
                                       "безопасно обрабатывают null при переопределенном методе Equals статический сравнивает ссылки\n"),

                ("531. Анти паттерны","1. Копи паста\n"+
                                       "2. Спаггети код\n"+
                                       "Это слабо структуированная и плохо спроектированная система,\n"+
                                       "запутанная и сложная для понимания\n"+
                                       "3. Золотой молоток\n"+
                                       "Уверенность в полной универсальности решения. Использование одного решения для всех задач возможных и не возможных задач\n "+
                                       "4. Магические числа\n"+
                                       "константа, использованная в коде для чего либо\n "+
                                       "5. Жесткое кодирование\n"+
                                       "Внедрение различных данных об окружении в реализацию\n"+
                                       "Различные пути к файлам, имена процессов, устройств\n"+
                                       "Главная опасность такой код непереносим\n "+
                                       "6. Мягкое кодирование\n"+
                                       "Параноидальная боязнь захаркодить. Это приводит к тому, что настравивается абсолютно все.\n"+
                                       "и это делает конфигурацию сложной и непрозрачной\n"+
                                       "7. Ненужная сложность\n"+
                                       "Заумность решения. Ненужная сложность может быть внесена в решение любой задачи\n"+
                                       "Это может быть ненужные проверки, части кода с мягким кодированием, отсутствии оптимизации\n"+
                                       "8. Лодочный якорь\n"+
                                       "Сохранение неиспользуемых частей системы, которые остались после рефакторинга или оптимизации\n"+
                                       "9.Изобретение велосипеда\n"+
                                       "программист разрабатывает собственное решение для задачи, у которой уже есть решение\n"+
                                       "10. Изобретение одноколесного велосипеда\n"+
                                       "Изобретение плохого велосипеда\n"+
                                       "11. Поток лавы\n"+
                                       "часть кода, которая давно не менялась и не понятно как она вообще работает\n"+
                                       "12. Программирование перебором\n"+
                                       "Подбор параметров в функции. +-1 и подобные штуки\n"+
                                       "13. Слепая вера\n"+
                                       "Недостаточная проверка корректности входных данных, исправления ошибки или результатов работы кода\n"+
                                       "14. Безумное комментрирование\n"+
                                       "Большое и не нужное количество лишних и бессмысленных комментариев\n"+
                                       "15. Божественный объект\n"+
                                       "Объект берет на себя много функций или хранит в себе много данных\n"),

                ("532. Виды паттернов","1. Порождающие это паттерны, которые абстрагируют процесс инстанцирования или\n "+
                                       "иными словами процесс пораждения классов и объектов\n"+
                                       "2. Структурные паттерны - группа паттернов рассматривает, как классы и объекты\n"+
                                       "образуют более крупные структуры. Более сложные по характеру классы и объекты\n"+
                                       "3. Поведенческие паттерны - определяют алгоритмы и взаимодействие между классами и объектами\n"+
                                       "то есть их поведение\n"),

                ("533.Хранитель(memento) или снимок. Паттерн","Поведенческий паттерн\n"+
                                            "Он позволяет определять, сохранять, а также востанавливать предыдущие состояния без нарушения инкапслуляции\n"
                                            ),

                ("534. Цепочка обязанностей.(chain of responsibility) Паттерн  ","Поведенческий шаблон проектирования, который позволяет избежать жесткой привязки отправителя запроса к получателю\n"+
                                                         "Каждый объект в этой цепочке при получении запроса выбирает\n"+
                                                         "либо закончить обработку запроса, либо передать запрос на обработку следующему по цепочке объекту\n"),

                ("535. Наблюдатель.(observer)(Издатель подписчик) Паттерн","Представляет поведенческий шаблон проектирования\n"+
                                             "который использует отношение один ко многим\n"+
                                             "В этом отношении есть один наблюдаемый объект и множество наблюдателей\n"+
                                             "И при изменение наблюдаемого объекта происходит оповещение всех наблюдателей\n"),

                ("536. Команда.(command) Паттерн","Позволяет инкапсулировать запрос на выполнение определенного действия в виде отдельного объекта\n"+
                                         "Этот объект запроса на действие и называется командой\n "+
                                         "При этом объекты, инициирующие запросы на выполнение действия,\n"+
                                         "отделяются от объектов, которые выполняют это действие\n"),

                ("537. Состояние(state) паттерн","шаблон проектировани, который позволяет объекту изменять свое поведение\n "+
                                          "в зависисмости от внутреннего состояния\n"),

                ("538. Интепретатор.(interpreter) Паттерн","определяет представление для данного языка и интепретатор предложений\n"+
                                              "этого языка. Как правило данный шаблон применяется для часто повторяющихся операций\n"+
                                              ""),

                ("539. Стратегия(strategy) Паттерн","представляет шаблон проектирования, который определяет набор алгоритмов,\n"+
                                          "инкапсулирует каждый из них и обеспечивает их взаимозаменяемость\n"+
                                          "В зависимости от ситуации один используемый алгоритм можем заменить другим\n"),

                ("540. Итератор.(iterator) Паттерн","представляет абстрактный интерфейс для последовательного доступа ко всем\n"+
                                          "элементам составного объекта без раскрытия его внутренней структуры\n"),

                ("541. Шаблонный метод.(template method) Паттерн","определяет общий алгоритм поведения подклассов,\n"+
                                                 "позволяя им переопределить отдельные шаги этого\n"+
                                                 "алгоритма без изменения его структуры\n"),

                ("542.Посредник(mediator) ","Представляет такой шаблон проектирования,\n"+
                                            "который обеспечивает взаимодействие множества объектов\n"+
                                            "без необходимости ссылаться друг на друга\n"+
                                            "Тем самым достигается слабосвязанность взаимодействующих объектов\n "),

                ("543.Посетитель(visitor)","позволяет опеределить операцию для объектов других классов\n"+
                                           "без изменения этих классов. При использовании паттерна определяются две иерархии классов:\n"+
                                           "одна для элементов, для которых надо определить новую операцию,и\n"+
                                           "вторая иерархия для посетителей, описывающих данную операцию\n"),

                ("544. Абстрактная фабрика(abstract factory)","предоставляет интерфейс для создания семейств взаимосвязанных объектов\n"+
                                                              "с определенными интерфейсами без указания конкретных типов данных объектов\n"),

                ("545. Строитель(builder) паттерн","шаблон проектирования, который инкапсулирует создание объекта и позволяет разделить его на различные этапы\n"+
                ""),

                ("546.Фабричный метод","это паттерн, который определяет интерфейс для создания объектов\n"+
                                       "некоторого класса, но непосредственное решение объект какого класса решается в подклассах\n"+
                                       "то есть паттерн предполагает что базовый класс делегирует создание объекта наследникам\n"),

                ("547. Прототип.(prototype) Паттерн","позволяет создавать объекты на основе уже раннее созданных объектов-прототипов\n"+
                                                     "по сути данный паттерн предлагает технику клонирования объектов\n"),

                ("548. Одиночка(singeton) ","порождающий паттерн, который гарантирует,что для определенного класса будет создан только один объект,\n "+
                                            "а также предоставит к этому объекту точку доступа\n"),

                ("549. Адаптер(adapter)","предназначен для преобразования интерфейса одного класса в интерфейс другого\n"+
                                         "Благодаря реализации данного паттерна мы можем использовать вместе все классы с несовместимыми интерфейсами\n"),

                ("550. Прокси(proxy) заместитель","предоставляет объект-заместитель,который управляет доступом к другому объекту\n"+
                                             "объект суррогат, который может выступать в роли другого объекта и замещать его\n"),

                ("551. Мост.(Bridge)","структурный шаблон проектирования, который позволяет отделить абстракцию от реализации таким образом,\n "+
                                      "чтобы и абстракцию, и реализацию можно было изменить независимо друг от друга\n"),

                ("552. Компоновщик(composite). Паттерн","объединяет группу объектов в древовидную структуру по принципу часть-целое\n"+
                                                        "и позволяет клиенту одинаково работать как с отдельными объектами, так и с группой объектов\n"+
                                                        "образно реализацию паттерна можно представить в виде меню, которое имеет различные пункты\n"),

                ("553. Декоратор(decorator) Паттерн","представляет структурный шаблон проектирования, который позволяет динамически подключать к объекту\n"+
                                                     "дополнительную функциональность.Для определения функциональности обычно используют наследование"),

                ("554. Фасад(facade)","представляет собой шаблон проектирования, который позволяет скрыть сложность системы\n"+
                                      "с помощью предоставления упрощенного интерфейса для взаимодействия с ним\n"),

                ("555. Приспособленец(flyweight)","структурный шаблон проектирования, который позволяет использовать разделяемые объекты\n"+
                                                  "сразу в нескольких контекстах. Данный паттерн используется преимущественно для оптимизации работы с памятью\n"),

                ("556. GRASP","это шаблоны, используемые в ООП проектировании для решения общих задач по назначению\n"+
                              "ответственостей классам и объектам\n"),

                ("557. виды GRASP","1. Информационный эксперт(information Expert)\n"+
                                    "Шаблон определяет базовый принцип ответственностей:\n"+
                                    "Ответсвенность должна быть назначена тому, кто владеет максимум необходимой информации для исполнения\n"+
                                    "информационному эксперту\n"+
                                    "2. Создатель(Creator)\n"+
                                    "Класс должен создавать экземпляры тех классов, которые может\n "+
                                    "3. Контроллер(Controller)\n"+
                                    "Отвечает за операции, запросы на которые приходят от пользователя\n"+
                                    "и может выполнять сценарии одного или нескольких вариантов использования\n"+
                                    "4. Слабое зацепление\n"+
                                    "степень зацепления - мера неотрывности от других элементов\n"+
                                    "слабое зацепление - распределение ответственностей и данных, обеспечивающие независимость классов\n"+
                                    "5. Высокая связаность(High Cohesion) \n"+
                                    "Высокая связаность класса - это оценочная модель, направленная на удержание объектов должным образом сфокусироваными\n"+
                                    "управляемыми и понятными. Высокая сзязаность обычно используется для низкого зацепления\n"+
                                    "разбиение программ на классы и подсистемы является примером деятельности, которая увеличивает связаность системы\n"+
                                    "6. Полиморфизм(Polymorphism) Устройство и поведение системы:\n"+
                                    "Определяется данными и задано полиморфными операциями её интерфейса\n"+
                                    "7. Чистое изготовление(Pure Fabrication) уменьшает зацепление, повышает связанность, упрощает повторное использование\n"+
                                    "8. Перенаправление(inderection)\n"+
                                    "Слабое зацепление между элементами системы( и возможность повторного использования) обеспечивается назначением \n"+
                                    "промежуточного объекта их посредником\n"+
                                    "9. Устойчивость к изменениям(Protected Variations)\n"+
                                    "Шаблон защищает элементы от изменения другими элементами(объектами или подсистемами ) с помощью вынесения\n"+
                                    "взаимодействия в фиксированный интерфейс, через который(и только через который) возможно взаимодействие между элементами\n"+
                                    "поведение может варьироваться лишь через создание другой реализации интерфейса\n"),

                ("558. Синхронная программная модель","это программная модель, когда потоку назначается одна задача\n"+
                                                      "и начинается выполнение. Когда завершено выполнение задачи тогда появляется возможность заняться другой задачей\n "),

                ("559. Однопоточность","если мы имеем несколько задач, которые надлежит выполнить, и текщая система предоставляет один поток\n "+
                                       "который может работать со всеми задачами, то он берет поочередно одну за другой\n"),
                ("560. Многопоточность","это способ выполнения нескольких потоков команд в рамках однопроцесса,\n"+
                                        "позволяющий эффективно использовать ресурсы процессора и выполнять задачи параллельно\n"),

                ("561. Асинхронная модель программирования","в отличии от синхронной програмнной модели\n"+
                                                            "здесь поток однажды начав выполнение задачи может приостановить выполнение, сохранив\n"+
                                                            "текущее состояние и между тем начать выполнение другой задачи\n"),
                ("562. Параллелизм","это свойство системы, при котором несколько вычислений выполняются одновременно в течение определенного периода времени\n"),

                ("563. SynchronizationContext","это абстракция, которая перенаправляет вызовы(обычно колбеки или продолжения)\n"+
                                               "в нужный контекст синхронизации(поток, очередь)\n"+
                                               "Переносит выполнение кода в правильный поток\n"),

                ("564. ConfigureAwait(false)","это оптимизация, которая говорит механизму продолжения задач\n"+
                                              "не возвращаться в исходный контекст синронизации\n"+
                                              "отменяет привязку продолжения к исходному потоку, позволяя продолжить\n"+
                                              "выполнение в любом доступном потоке из пула\n"+
                                              "улучшение производительности\n"+
                                              "предотвращение дедлоков\n"+
                                              "Оптимизация библиотечного кода\n"+
                                              "Использовать в библиотечном коде, где не важен контекст.\n"+
                                              "Не использовать в UI коде или где нужен исходный контекст\n"),
                ("565. async\\await","это паттерн для неблокирующего выполнения асинхронных операций\n"+
                                     "async помечает метод как асинхронный\n"+
                                     "await приостанавливает выполнение до завершение задачи, не блокируя поток\n"),

                ("566. Ошибки в асинхронном методе","если ошибка в состоянии Canceled то OperationCanceledExpeption\n"+
                                                    "если в Faulted вызывается конкретная ошибка\n"),

                ("567. CancellationTokenSource","Источник маркера отмены. Свойство источника Token\n"+
                                                "вызов метода Cancel"),

                ("568. методы Task","Task, Task<TResult>\n"+
                                    "await Task.Run(()=>{return x});\n"+
                                    "await Task.Run(async()=>\n"+
                                    "return Task.FromResult() возвращает уже выполненую задачу\n "+
                                    "Task.WhenAll для ожидания нескольких операций\n"+
                                    "Task.WhenAny для ожидания одной из нескольких операций\n"),
                ("569. для чего нужны TaskContinue.With","используется для создания продолжений(continuations) задач\n"+
                                                         "Это механизм, который позволяет выполнить код сразу после завершения\n"+
                                                         "предыдущей задачи.Независимо с ошибкой завершилось или нет\n"),

                ("570. что такое Task.Yield()","этот метод, который принудительно делает текущий метод асинхронным,\n+" +
                                               "заставляя его немедленно вернуть управление вызывающему коду, даже если он\n"+
                                               "выполниться синхронно\n"),

                ("571. что такое await Task.Run()","это операция, которая позволяет выполнить синронный код в фоновом потоке\n"+
                                                   "и ожидать его завершение асинхронно\n"),

                ("572. что такое Task.FromResult()","это метод, который создает уже завершенную задачу с указанным результатом\n"+
                                                    "Это полезно для симуляции асинхронных операций,которые на самом деле\n"+
                                                    "выполняются синхронно\n"),
                ("573. что такое Task.WhenAll()","это метод, который создает задачу, ожидающую завершения всех переданных задач.\n"+
                                                 "Это мощный инструмент для параллельного выполнения асинхронных операций\n "),

                ("574. что такое Task.WhenAny()","это метод, который создает задачу, ожидающую завершения любой из переданнных задач\n"+
                                                 "Он возвращается как только одна из задач завершается с ошибкой или без\n"),

                ("575.что такое Task.Delay()","это метод,который создает задачу, завершающиеся через определенный промежуток времени без блокировки потока\n"),

                ("576.что такое ThreadPool","это архитектурный паттерн программирования, представляющий собой коллекцию(пул)\n "+
                                            "заранее созданных и простаивающих потоков, готовых к выполнению задач\n"),

                ("577. виды потоков в ThreadPool","Рабочие потоки(worker threads) для вычислительных задач\n"+
                                                  "Потоки завершения ввода вывода(I/O completion threads) - обрабатывают завершение асинхронных операций ввода - вывода\n"),

                ("578.методы ThreadPool","1. QueueUserWorkItem самый простой способ поместить задачу в пул потоков\n"+
                                         "2. GetMaxThreads/SetMaxThreads получение/установка максимального количества потоков\n "+
                                         "3. GetMinThreads/SetMinThreads получение/установка минимального количества потоков\n"+
                                         "4. GetAvailableThreads определение числа свободных потоков\n"+
                                         "5. RegisterWaitForSingleObject регистрация объекта ожидания с заданным таймаутом\n"),

                ("579. инструменты синхронизации ThreadPool","1. Блокировки lock(object)\n"+
                                                             "2. Атомарные операции\n"+"" +
                                                             " ThreadPool.QueueUserWorkItem(_=>{\n"+
                                                             "Interlocked.Increment(ref _counter)\n"+
                                                             "})\n"+
                                                             "3. ReaderWriterLockSlim когда чтений больше,чем записей\n"),

                ("580. Паттерны для использования ThreadPool в микросервисах","Circuit Breaker(Предохранитель) для предотвращения каскадных отказов\n"+
                                                                              "BulkHead(Переборка) для изоляции ресурсов между подсистемами\n"),

                ("581. Альтернативы для управления потоками","1. Dataflow(TPL Dataflow) для обработки потока данных\n"+
                                                             "2. Channels для высокопроизводительных сценариев производитель- потребитель\n" +
                                                             "3. Reactive Extansions(Rx) для реактивных потоков данных и обработки событий"),

                ("582. что такое Parallel.Invoke()","это метод который позволяет запускать несколько операций параллельно\n"+
                                                    "и ожидать их завершения\n"),

                ("583. что такое TaskFactory.StartNew()","это фабричный метод, который создает и немедленно запускает объект Task\n"+
                                                         "для выполнения в фоновом потоке из пула потоков"),

                ("584. Task.AsyncState","это свойство которое позволяет сохранить объект состояние вместе с задачей\n"+
                                        "и затем получить его обратно\n"),

                ("585 что такое AggregateException","это специальный тип исключения в Net, который действует как контейнер\n"+
                                                    "для одного или нескольких исключений,\n"+
                                                    "произошедших в параллельных или асинхронных операциях\n"),

                ("586. что такое TaskFactory","это класс, представляет собой фабрику для создания и настройки задач\n"+
                                              "Он предоставляет методы для создания и запуска задач с различными параметрами и настройками\n"),

                ("587. что такое System.Threading.Channels.Channel<T>","это высокопроизводительный и безопасный для многопоточного использования\n"+
                                                                       "способ организации асинхронного обмена данными между\n"+
                                                                       "производителями(producers) и потребителями(consumers)\n"+
                                                                       "Channel<T> сам канал\n"+
                                                                       "ChannelWriter<T> для записи данных\n"+
                                                                       "ChannelReader<T> для чтения данных\n"),

                ("588.что такое Open.ChannelExtensions","это популярный open sourse пакет, который представляет \n +" +
                                                        "набор методов для работы с каналами. это как LINQ для object\n"+
                                                        "но для асинхронных потоков данных в каналах\n"),

                ("589. что такое WriteAsync","это метод отправки данных в канал\n"+
                                             "асихронный метод класса ChannelWriter<T>,\n"+
                                             "который добавляет элемент в канал\n"),

                ("590. что таое ReadAsync ","это асинхронный метод класса ChannelReader<T>, который читает один элемент из канала\n"),

                ("591. TryWrite","это синхронная альтернатива асинхронному WriteAsync для работы с каналами в C#\n "+
                                 "TryWrite это  метод класса ChannelWriter<T>, который пытается немеделенно записать элемент в \n"+
                                 "канал без блокировки. Не бросает исключения и возвращает bool"),

                ("592. TryRead","это синхронная альтернатива ReadAsync\n "+
                                "метод который пытается прочитать элемент из канала потока без блокировки\n"),

                ("593. что такое Completion","это свойстов которое возвращает Task\n"+
                                             "заверщаюйся когда канал больше недоступен для чтения и записи\n"+
                                             "Завершается успешно когда канал полностью отработан\n"+
                                             "Завершается с ошибкой если произошла ошибка\n"+
                                             "Не завершается никогда если канал еще активен"),

                ("594. емкость канала ","Channel.CreateBounded - ёмкость\n"+
                                        "Channel.CreateUnbounded - неограниченное количество читателей и писателей\n"),

                ("595. пайплаины обработки(Processing pipelines)","Эта последовательности операций, где выход одной операции становится входом для следующей\n"+
                                                                   "   Каналы позволяют организовать эффективный поток данных между этапами обработки\n"+
                                                                   "    Пример: конвейер обработки изображений, где одна операция выполняет масштабирование\n"+
                                                                   "     другая фильтрацию\n"),
                ("596.  Очереди задач(Task queues)",                                                   
                                                                   "   использование каналов для создания очереди задач,\n"+
                                                                   "   которые должны быть выполнены асинхронно\n"+
                                                                   "   один или несколько потоков могут добавлять задачи(производители)\n"+
                                                                   "   а другие потоки могут их выполнять(потребители)\n"+
                                                                   "   Пример: очередь запросов к внешнему API с ограничением частоты,\n"+
                                                                   "    где задачи добавляются по мере необходимости, а обрабатываются с контролируемой скоростью\n"
                                                                   ),
                
                ("597. реализация event loop","Организация цикла обработки событий,\n"+
                                              "где события помещаются в канал и последовательно обрабатываются\n"+
                                              "Позволяет создавать неблокирующие обработчики событий\n"+
                                              "Пример: приложение, которое получает события из разных источников\n"+
                                              "(UI,сеть,файловая система) и должна их обрабатывать в определенном порядке\n"+
                                              "в одном потоке\n"),

                ("598. Полезность каналов в сценариях ","1. Предоставляют встроенную синхронизацию между потоками\n"+
                                                        "2. Поддерживают асинхронные операции(async/await)\n"+
                                                        "3. Обеспечивает контроль потока данных(особенно в bounded каналах)\n"+
                                                        "4. Предлагают высокопроизводительную альтернативу традиционным коллекциям с блокировками\n "),

                ("599. Чем отличается Select от Where?","Select это преобразование (проекция). Он преобразует каждый элемент коллекции в новую форму\n "+
                                                         "Where это фильтрация. Оставляет только те элементы которые удовлетворяют условию\n"),

                ("600. Какие методы отвечают за агрегацию в LINQ?","Это семейство методов. Их цель вычислить одно результирующее значение\n"+
                                                                   "на основе всей коллекции(или ее части)\n"+
                                                                   "Aggregate 1+2+3+4+5\n"+
                                                                   "SUM(),Average() среднее, Min,Max,Count, LongCount, First/FirstOfDefault,\n"),

                ("601. Что произойдет, если к IEnumerable-запросу не применить методы вроде ToList()?","1. Отложенное выполнение\n"+
                                                                                                       "2. Повторное выполнение\n"+
                                                                                                       "3. Чуствительность к изменению данных\n"),

                ("602. В чем разница между IEnumerable и IQueryable?","IEnumerable работает с данными в памяти (клиентская сторона)\n"+
                                                                      "IQueryable работает с поставщиком запросов(серверная сторона)\n"),

                ("603.Как можно предотвратить повторное выполнение LINQ-запроса?","Использовать методы материализации\n"+
                                                                                  "в EF метод AsNoTracking\n"),

                ("604.Что такое deferred execution?","Запрос не выполняется немедленно в момент его определения,\n"+
                                                     "а лишь сохраняется как план выполнения\n"+
                                                     "фактическое выполнение откладывается до момента, когда реально нужны данные\n"),

                ("605.Как yield return реализует отложенное выполнение?"," Генерирует класс итератор компилятором\n"+
                                                                         "и машину состояния которая запоминает текущую позицию выполнения\n"),

                ("606. Как deferred execution помогает с производительностью?","1. Избегание ненужных вычислений\n"+
                                                                               "2. экономия памяти при генерации больших последовательностей\n"+
                                                                               "3. Оптимизация в запросах к базе данных\n"+
                                                                               "4. Ленивая загрузка больших файлов (построчное чтение файлов)\n"+
                                                                               "5. Цепочка отложенных операций\n"+
                                                                               "6. Динамическое построение запросов\n"+
                                                                               "7. Генерация по требованию\n"),

                ("607. Что может пойти не так при использовании deferred execution?","1. Неожиданные многократные использования\n"+
                                                                                     "2. Доступ к disposed объектам\n"+
                                                                                     "3. Изменения данных во время выполнения\n"+
                                                                                     "4. Побочные эффекты\n"+
                                                                                     "5. Производительность при многократном использовании\n"+
                                                                                     "6. Позднее обнаружение ошибок\n"+
                                                                                     "7. Разное выполнение методов с анонимными типами при схожей логике\n"+
                                                                                     "8. Пробелемы с параллельным выполнением\n"+
                                                                                     "9. Случайное создание бесконечного цикла\n"+
                                                                                     "10. Сложность отладки ленивых вычислений\n"),

                ("608. Как можно заставить deferred-запрос выполниться немедленно?","1. Методы материализации\n"+
                                                                                    "ToList(), ToArray(), ToDictionary(), ToLookUp(),ToHashSet()\n"+
                                                                                    "2. Методы агрегации\n"+
                                                                                    "Count(), Sum(), Min()\n"+
                                                                                    "3. Методы получения элементов\n"+
                                                                                    "First(), FirstOrDefault(), Single(), SingleOrDefault(), Last()\n"+
                                                                                    "4. Методы проверки\n"+
                                                                                    "Any(), All(), Contains(),\n"+
                                                                                    "Явное пречисление\n"),

                ("609.Когда рефакторинг в LINQ может ухудшить читаемость кода? ","1. Чрезмерные цепочки\n"+
                                                                                 "2. Много логики в Select\n"+
                                                                                 "3. Сложные анонимные типы\n"+
                                                                                 "4. Использование LINQ где простой цикл более читаем\n"+
                                                                                 "5. Смещение бизнес логики с Linq\n"+
                                                                                 "6. Использование динамических типов\n"+
                                                                                 "7. Сложная группировка\n"),

                ("610.Какой LINQ-метод эквивалентен вложенному foreach?","SelectMany "),

                ("611. Как заменить проверку всех элементов на условие?","All() все элементы удовлетворяют условию\n"+
                                                                         "Any() хотя бы один удовлетворяет условию\n"),

                ("612. Почему важно избегать побочных эффектов в LINQ-выражениях?","нарушение принципов функционального программирования\n"+
                                                                                   "неопределенное поведение при отложенном выполнении\n"+
                                                                                   "Многократное выполнение побочных эффектов\n"+
                                                                                   "Сложность тестирования и отладки\n"+
                                                                                   "Проблемы с параллельным вычислениями\n"),

                ("613. Что делает yield return в C#?","это ключевые слова для создания итераторов и ленивого вычисления\n"+
                                                      "они позволяют генерировать последовательности элементов по одному,\n"+
                                                      "по мере необходимости\n"),

                ("614. Чем yield return отличается от обычного return?","1.return возвращает готовую коллекцию yield return возвращает по одному\n"+
                                                                        "2. retrun жадное выполнение Выделяется вся память, yield память только для текущего элемента\n"+
                                                                        "3. один return один возврат, yield много возвратов\n"+
                                                                        "4. return состояние между вызовами сбрасывается yield сохраняется\n"+
                                                                        "5. return не имеет ограничений на контекст, yield нельзя в catch блоке, анонимных методах\n"+
                                                                        "6. ошибка return сразу yield по достижению итерации"),

                ("615. В каких случаях имеет смысл использовать yield return?","1. Работа с большими данными\n"+
                                                                               "2. Генерация бесконечных последовательностей\n"+
                                                                               "3. Ленивая загрузка данных\n"+
                                                                               "4. Кастомные итераторы и фильтры\n"+
                                                                               "5. Для данных которые поступают медленно\n"+
                                                                               "6. для посторения цепочек обработки\n"+
                                                                               "7. Отладка и логирование процесса\n"+
                                                                               "8. Экономия памяти в Linq цепочках\n"+
                                                                               "9. Создание собственных Linq методов\n"+
                                                                               "10. обработка деревьев и иерархических стурктур\n"),

                ("616. Что возвращает метод с yield return?","возвращает не обычную коллекцию, а специальный итератор - объект,\n"+
                                                             "который реализует интерфейсы IEnumerable<T> или IEnumerator<T>\n"),


                ("617. Чем отличается стек от кучи по способу хранения данных?","1.Структура и организация"+
                                                                                "Стек (LIFO Last In First Out)\n"+
                                                                                "Куча произвольный доступ\n"+
                                                                                "2. скорость и производительность\n"+
                                                                                "Стек(быстро) и куча(медленно)\n"+
                                                                                "стек освобождение при выходе из метода\n"+
                                                                                "куча сборщик мусора\n"+
                                                                                "3. Размер и ограничения\n"+
                                                                                "Стек(ограниченный)\n"+
                                                                                "Куча(большой размер)\n"+
                                                                                "4. Время жизни переменных\n"+
                                                                                "Стек(автоматическое управление)\n"+
                                                                                "Куча(управление через GC)\n"+
                                                                                "5. Типы данных\n"+
                                                                                "Стек(значимые типы)\n"+
                                                                                "Куча(ссылочные типы)\n"),

                ("618.Что произойдёт при переполнении стека?","возникает исключение StackOverflowException,\n"+
                                                              "которое является критическим и обычно приводит к аварийному завершению программы\n"),

                ("619.Почему доступ к стеку быстрее, чем к куче?","структура LIFO и близкость располпожения данных, автоматическое управление компилятором\n "),

                ("620. Какие типы в C# по умолчанию размещаются в стеке, а какие — в куче?","В стеке по умолчанию размещаются экземпляры типы значений,\n"+
                                                                                            "обьявленные как локальные переменные или параметры методов\n"+
                                                                                            "В куче по умолчанию размещаются все экземпляры ссылочных типов,а\n"+
                                                                                            "также типы значений, которые являются полями внутри ссылочных типов или упакованы(boxing)\n"),

                ("621. Что такое boxing в C#?","Это процесс преобразования типа значения в ссылочный тип(object или интерфейс который реализует этот тип).\n"+
                                               "При упаковке значение копируется из стека в управляемую кучу,\n"+
                                               "и вокруг него создается обертка, которая позволяет обращаться к нему как обьекту\n"+
                                               "int number =42; object boxedNumber = number;"),

                ("622. Что такое unboxing?","это операция извлечения типа значения из объекта, в который он был ранее упакован\n"+
                                            "Это процесс преобразования ссылочного типа обратно в тип значения\n"+
                                            "при распаковке значение копируется из кучи обратно в стек\n"+
                                            "можно распоковывать только этот же тип или его nullable"),

                ("623. Почему частое использование boxing/unboxing нежелательно?","Частое использование boxing и unboxing это антипаттерн\n"+
                                                                                  "1. Значительные накладные расходы на производительность\n"+
                                                                                  "2. Повышенное давление на garbage collect\n"+
                                                                                  "3. Риск ошибок времени выполнения\n"+
                                                                                  "4. Потеря семантики типов значений\n"),

                ("624. Как избежать boxing при работе с коллекциями?","что бы избежать boxing нужно использовать обобщенные коллекции\n"+
                                                                      "и generic интерфейсы"),

                ("625.Как Equals ведёт себя при сравнении значимого типа и object?","1. object.Equals(object)Если один тип то сравнивается побитово\n"+
                                                                                    "если разный то false;если null то false\n"+
                                                                                    "2. ValueType.Equlas(object) если не соместимый тип то false\n"+
                                                                                    "если совместимый то провреяет все поля"),

                ("626. Что такое поколение в контексте GC?","идея поколения основана на двух эмперических наблюдениях,\n "+
                                                            "известных как гипотезы поколений:\n"+
                                                            "молодые объекты умирают быстро\n"+
                                                            "старые объекты ссылаются на молодые\n"),

                ("627.Когда запускается GC?","Не следует четкому набору правил и условий. Нет расписания\n"+
                                             "Триггеры для запуска:\n"+
                                             "1. Недостаточно памяти для выделения нового объекта(самая частая причина)\n"+
                                             "2. Прямой вызов GC.Collect()\n"+
                                             "3. Нехватка системной памяти\n"+
                                             "4. Вызов API, влияющего на память\n"+
                                             "5. Завершение работы приложения\n"),

                ("628.Почему вручную вызывать GC — плохая практика?","1. Нарушение самооптимизирующейся логики GC\n"+
                                                                     "2. Преждевременное движение объектов\n"+
                                                                     "3. Снижение производительности из  за очистки 2 поколения\n"+
                                                                     "4. Иллюзия решения проблем\n"),

                ("629. Как узнать, в каком поколении находится объект?","метод GC.GetGeneration(object obj)"),

                ("630.Какой метод можно использовать для освобождения неуправляемых ресурсов?","интерфейс IDisposable и шаблон Dispose\n"+
                                                                                               "использование using гарантирует вызов Dipose()\n"+
                                                                                               "Деструктор\n"),

                ("631.Что такое Span<T> и его главное преимущество?","Это стурктура, предоставляет безопасное и безкопируемое представление\n"+
                                                                     "непрерывной области памяти, независимо от того, откуда эта память взята\n"+
                                                                     "откуда может быть память:\n"+
                                                                     "1. Управляемые массивы\n"+
                                                                     "2. Стек(stackalloc)\n"+
                                                                     "3. Неуправляемая память unsafe\n"+
                                                                     "4. Строки(только для чтения, с помощью ReadOnlySpan<char>)"),

                ("632.Чем отличается Span<T> от Memory<T>?","Это родственные типы, решающие схожие задачи, но с важными различиями в семантике\n"+
                                                            "и применении. Понимание их отличий критически важно для правильно использования\n"+
                                                            "Span<T> для синхронного низкоуровнего кода,\n"+
                                                            "который работает только на стеке\n"+
                                                            "Memory<T> асинхронного и высокоуровневого кода, который может находится в куче\n"),

                ("633. Почему Span<T> не может быть полем класса?","Span<T> это ref struct. Может находится только в стеке\n"+
                                                                   "Предотвращение использования после освобождения\n"+
                                                                   "Не касается GC\n"+
                                                                   "Производительность\n"),

                ("634. Как Span<T> помогает избежать выделения памяти?","Span<T> не требует копирования, он просто является окном на эту память\n"+
                                                                        "создает кратковременный буфер в стеке с прямым доступом"),

                ("635.Где Span<T> особенно полезен?","1. Парсинг строк без выделения памяти\n"+
                                                     "2. Сетевое программирование и обработка пакетов\n"+
                                                     "3. Работа с файлами или потоком\n"+
                                                     "4. Криптография и математические выделения\n"+
                                                     "5. Высокопроизводительные API и библиотеки\n"+
                                                     "6. Микроконтроллеры и ресурсо-ограниченные среды\n"),

                ("636. Что означает принцип единственной ответственности (SRP)?","Один класс должен решать только одну задачу и \n"+
                                                                                 "и быть отвестенен только за одну часть функциональности\n"),

                ("637. Что нарушает принцип открытости/закрытости (OCP)?","1. явные проверки типа\n"+
                                                                          "2. проверка состояний\n"+
                                                                          "3. жесктие зависимости\n"),

                ("638.Как понять, что нарушен принцип подстановки Лисков (LSP)?","1. Код требует проверики на тип\n"+
                                                                                 "2. Подкласс усиливает предусловия\n"+
                                                                                 "3. Подкласс ослабляет постусловия\n"+
                                                                                 "4. Подкласс генерирует исключения\n"+
                                                                                 ""),

                ("639. В чём суть принципа разделения интерфейса (ISP)?","Лучше иметь много маленьких и точных интерфейсов,\n"+
                                                                         "чем один большой\n"+
                                                                         "интерфейсы должны реализовать только нужные классы\n"),

                ("640.Как реализовать инверсию зависимостей (DIP)?","1. Выделяем абстракции(интерфейсы)\n"+
                                                                    "2. Внедряем зависимость() передаем зависимость классу извне, а не создаем ее внутри\n"+"" +
                                                                    "внедрение через конструктор предпочтительнее\n"+
                                                                    "3. Компоновка приложения\n"+
                                                                    "Создаем конкретную модель и внедряем ее в сервис\n"),

                ("641.Что означает KISS?","Keep it simple stupid\n"+
                                          "1. Простые и понятные названия\n"+
                                          "2. Короткие методы и классы с одной ответственностью\n"+
                                          "3. Отказ от преждевременной реализации и золотых молотков\n"+
                                          "4. Использование простых алгоритмов\n"+
                                          "5. Читаемость важнее крутизны\n"+
                                          ""),

                ("642.В чем суть DRY?","Dont Repeat YourSelf не повторяйся\n"+
                                       "не копируй один и тот же код, а вынеси этот код в отдельное место и используй\n"+
                                       "1. Дублирование кода\n"+
                                       "2. Дублирование логики\n"+
                                       "3. Дублирование данных и конфигурации\n"),

                ("643.Почему принцип YAGNI может сэкономить ресурсы?","You Aint Gonna need It Вам это не понадобится\n "+
                                                                      "1. Экономия времени разработки\n"+
                                                                      "2. Экономия умственных ресурсов и концепции\n"+
                                                                      "3. Снижение технического долга и затрат на поддержку\n"+
                                                                      "4. Экономия ресурсов бизнеса\n"),

                ("644.Как понять, что код нарушает DRY?","1. Буквальное дублирование кода\n"+
                                                         "2. Дублирование логики\n"+
                                                         "3. Дублирование данных и констант\n"+
                                                         "4. Нарушение принципа единственной ответственности\n"+
                                                         "5. Почти одинаковый код\n"+
                                                         ""),

                ("645. Почему KISS и YAGNI конфликтуют с overengineering?","Они не конфликтуют они напрвлены на его предотвращение\n"),

                ("646. Чем отличается инкапсуляция от сокрытия реализации?","Инкапслуляция это упаковка в один ящик\n"+
                                                                            "Сокрытие реализации - это решение какие грани ящика сделать прозрачными, \n"+
                                                                            "а какие нет\n"),

                ("647. Как работает наследование в C#?","это механизм, позволяющий одному классу(наследнику), перенимать\n"+
                                                        "(наследовать) поля, свойства и методы другого класса\n"+
                                                        "При этом класс наследник может добавлять новую функциональность или изменять наследуемую\n"),

                ("648. Что такое полиморфизм?","Полиморфизм это способность объектов с одинаковой спецификацией\n"+
                                               "иметь различную реализацию и вести себя по-разному в ответ на один и тот же вызов метода\n"+
                                               "Полиморфизм вовремя выполнения. Наследование virtual и override методы\n"+
                                               "Полиморфизм во время компиляции. Достигается через перегрузку методов\n"),

                ("649. Что такое virtual, override и new?","virtual - это метод в базовом классе,который можно переопределить\n"+
                                                           "override - позволяет классу наследнику предоставить свою собственную реализацию\n"+
                                                           "new скрывает унаследованный метод. Это непереопределение а создание своего метода с таким же названием\n"),

                ("650. В чём разница между абстрактным классом и интерфейсом?","1. Абстрактный класс может содержать:\n"+
                                                                               "реализованные методы с телом\n"+
                                                                               "поля, констукторы\n"+
                                                                               "может наследоваться от абстрактного класса\n"+
                                                                               "2. Интерфейсы могут содержать методы с реализации по умолчанию в зависимости от версии\n"+
                                                                               "свойства, события с реализации или без в зависимости от версии\n"+
                                                                               "множественное наследование\n"+
                                                                               "статические поля в зависимости от версии\n"),

                ("651. В чем отличие паттернов \"Стратегия\" и \"Шаблонный метод\"?","Стратегия использует композицию и делегирование\n"+
                                                                                     "Он выносит изменяемое поведение в отдельную иерархию классов и позволяет менять его на лету\n"+
                                                                                     "Шаблонный метод использует наследование. Он фиксирует скелет алгоритма в базовом классе, позволяя подклассам переопеределять отдельные шаги\n"),

                ("652. Когда следует применять паттерн \"Фабричный метод\"?","1. Когда заранее неизвестны конкретные типы объектов\n"+
                                                                             "2. Когда вы хотите дать возможность подклассам определять какой объект создавать\n"+
                                                                             "3. Когда нужно отделить код создания от кода использования\n"+
                                                                             "4. Когда вы планируете расширяемую архитектуру\n"+
                                                                             "5. Когда объект требует сложной настройки которую не стоит дублировать\n"+
                                                                             ""),

                ("653. Как реализуется паттерн \"Одиночка\" в многопоточной среде?","Наивная реализация паттерна небезопасна в многопоточной среде\n"+
                                                                                     "1. использовать блокировку\n"+
                                                                                     "2. статический конструктор\n"+
                                                                                     "3. Lazy<T>\n"+
                                                                                     ""),

                ("654.Чем \"Декоратор\" отличается от \"Адаптера\"?","Адаптер меняет интерфейс объекта, чтобы он стал совместим с другим кодом\n" +
                                                                      "Он решает проблему несовместимости\n"+
                                                                      "Декаратор добавляет новое поведение объекту, не меняя его интерфейса.\n"+
                                                                      "Он решает проблему расширения функциональности\n"),

                ("655.Какие задачи решает паттерн \"Наблюдатель\"?","1. Создает отношение один ко многим\n"+"" +
                                                                    " где один объект(subject) уведомляет множество наблюдателей об изменениях своего состояния\n"+
                                                                    "2. Слабосвязанная архитектура\n"+
                                                                    "Позволяет объектам взаимодействовать без жестких зависимостей.\n"+
                                                                    "наблюдатели знают только об интерфейсе Subject, а Subject знаеи об интерфейсе Observer\n"+
                                                                    "3. автоматическое распространение изменений\n"+
                                                                    "При изменений состояния Subject автоматически уведомляет всех подписанных наблюдателей\n"+
                                                                    "4. Динамическое добавление удаление зависимостей\n"+
                                                                    "Наблюдаетели могут подписываться и отписываться во время выполнения программы"),

                ("656.Что такое \"Информационный эксперт\"?","Information expert\n"+
                                                              "Ответственность должна быть назначена тому классу,\n"+
                                                              "который обладает необходимой информацией для ее выполнения\n"),

                ("657.Как работает \"Создатель\"?","определяет какой класс должен отвечать за создание объектов другого класса\n"),

                ("658.В чем суть принципа \"Низкая связанность\"?","классы должны быть максимально независимы друг от друга и иметь минимальные возможности\n"),

                ("659.Чем полезна \"Высокая связность\"?","Класс с высокой связаностью содержит только те методы и данные, которые\n"+
                                                          "непосредственно относятся к его основной ответственности\n "+
                                                          "Все элементы класса работают вместе для выполнения одной четкой задачи\n"),

                ("660.Что делает \"Контроллер\" в GRASP?","Служить посредником между UI(пользовательским интерфейсом) и бизнес-логикой\n"+
                                                          "обрабатывая входящие запросы и делегируя их выполнение соответсвующим объектам доменной области\n"),

                ("661. Что такое \"Божественный объект\"?","это антипаттерн, при котором один класс или модуль\n"+
                                                           "берет на себя слишком много задач и становится сложным и монолитным\n"),

                ("662. Почему \"Дублирование кода\" считается запахом?","Потому что оно создает серьезные проблемы для поддержки\n"+
                                                                        "расширения и надежности\n"+
                                                                        ""),

                ("663.Как \"Примитивная одержимость\" влияет на качество кода?","это антипаттерн, когда разработки используют примитивные типы\n"+
                                                                                "вместо создания специализированных классов\n +" +
                                                                                "Потеря семантики и смысла. Сложность рефакторинга и изменений\n"),

                ("664.Чем опасен запах \"Флаги как параметры методов\"?","1. Нарушение принципа единственной ответственности\n"+
                                                                          "2. Нарушение принципа низкой связаности\n"+
                                                                          "3. Ухудшение читаемости\n"+
                                                                          "4. Сложность тестирования\n"),

                ("665.Что означает запах \"Формальные параметры не используются\"?","метод обьявлен с параметрами, которые неиспользуются в его реализации"),

                ("",""),


                ("667.Что делает ключевое слово await на уровне IL?","1. Создание класса стейт машины\n"+
                                                                     "класс реализует интерфейс IAsyncStateMachine\n"+
                                                                     "Хранит все состояние метода\n"+
                                                                     "2. Преобразование тела метода\n"+
                                                                     "Исходное тело вашего async-метода полностью переписывается в метод MoveNext\n"+
                                                                     "у сгенерированного класса стейт машины\n"+
                                                                     "3. Механизм продолжений который автоматически возобновляет выполнение метода после завершения awaited задачи\n"+
                                                                     "4. билдер который отвечает за создание и управление возвращаемой Task"),

                ("668. Может ли async метод возвращать void?","можно но есть ограничения:"+
                                                              "1. невозможность ожидания await\n"+
                                                              "2. ошибки в async void не могут быть пойманы вызывающим кодом\n"+
                                                              "3. Нарушение принципов композиции\n"+
                                                              "4. Сложность тестирования\n"),

                ("669.Что произойдет, если не использовать await внутри метода, помеченного как async?","если просто нет await выполнится метод синхронно,\n"+
                                                                                                        "если будут асинхронные операции без await то будет неопределенное поведение\n"),

                ("670.Чем отличается await SomeAsyncMethod() от return SomeAsyncMethod()?","await ожидает завершения задачи,возвращаемой SomeAsyncMethod()\n"+
                                                                                           "и только потом продолжает выполнение текущего метода\n"+
                                                                                           "return немедленно возвращает задачу, полученную от SomeAsyncMethod(),\n"+
                                                                                           "вызывающему коду.Текущий метод не ждет ее завершения\n"),

                ("671.Что вернёт метод с сигнатурой async Task<int>, если в нем произойдёт исключение?","статус Fauted и исключение"),


                ("672.В чем разница между Task.Run и Task.Factory.StartNew?","Task.Run это обертка над Task.Factory.StartNew\n"+
                                                                             "Task.Factory.StartNew это низкоуровневый метод с большим количеством параметров\n"+
                                                                             "для тонкой настройки. Его гибкость и является главной опасностью\n "+
                                                                             "лучше всего использовать Task.Run, Task.Factory.StartNew для специфических задач\n "),

                ("673. Нужно ли использовать Task.Run внутри ASP.NET контроллеров?","Нет это создает пул в пуле. Нужно использовать async"),

                ("674. В каком случае Task.Run может пригодиться в UI-приложении?","Основная задача оставлять интерфейс отзывчивым\n"+
                                                                                   "а логику отправялть в фон через Task.Run()\n"),

                ("675.Что произойдёт, если вызвать Task.Run внутри Task.Run?","Ничего не сломается.Код выполнится корректно\n"+
                                                                              "Скорее всего антипаттерн. В 95% случаев вложенный Task.Run внутри другого Task.Run\n"+
                                                                              "не нужен и только добавляет лишние накладные расходы на планирование задач без реальной выгоды\n"+
                                                                              "Есть редкие исключения, когда это может быть оправдано для изоляции особенно тяжелой и\n"+
                                                                              "блокирующей операции внутри уже фоновой задачи\n"),

                ("676. Как Task.Run использует ThreadPool?","Task.Run это диспетчер который дает работу ThreadPool\n"+
                                                            "1. Создается объект Task,Task<int>\n"+
                                                            "2. код делегата выполняется не сразу, а как освободится очередь пула потоков\n"+
                                                            "3. когда делегат завершает свою работу, поток освобождается и возвращается в пул\n"+
                                                            "Task переходит в состояние RanToCompletion или Faulted"),

                ("677. Что делает ConfigureAwait(false)?"," ConfigureAwait(false) сообщает механизму await что не обязательно\n"+
                                                          "возобновлять выполнение в исходном контексте синхронизации\n"+
                                                          "Это может предотвратить взаимоблокировки и немного улучшить производительность\n"+
                                                          "желательно использовать в библиотеках и неиспользовать в коде обнавляющего UI\n "),

                ("678. В каких проектах особенно важно использовать ConfigureAwait(false)?","1. В библиотечном коде (Library Code)\n"+
                                                                                             "2. Для микро-оптимизации в коде приложения\n"+
                                                                                             "3.Главная суперсила: Предотвращение взаимоблокировок (Deadlocks)\n"),

                ("679. Почему ConfigureAwait(false) может ускорить выполнение кода?","1. Устранение накладных расходов на переключение контекста\n"+
                                                                                      "2. Улучшение масштабируемости за счет избежания \"очередей к контексту\"\n"
                                                                                      +"3. Устранение лишних переходов между потоками"),

                ("670. Что произойдёт, если не использовать ConfigureAwait(false) в UI-приложении?","Все будет работать правильно\n"),

                ("671. Работает ли ConfigureAwait(false) в .NET 6+ внутри ASP.NET Core?","Больше не требуется так как в .NET 6+ по умолчанию оптимизирован контекст синхронизации\n"),

                ("672. Что делает cancellationToken.ThrowIfCancellationRequested()?","Это ключевой метод для корректной обработки отмены операции в Net\n"+
                                                                                     "это метод проверяет был ли запрос на отмену операции для данного токена\n"+
                                                                                     "Если запрос был, метод немедленно бросает исключение OperationCanceledException\n"+
                                                                                     "Где то создается источник отмены CancellationTokenSourse\n"+
                                                                                     "Токен отмены (CancellationToken) из этого источника передается в метод, который должен поддерживать отмену\n"+
                                                                                     "Внутри долгой операции периодически вызывается cancellation.ThrowIfCancellationRequasted()\n"+
                                                                                     "когда внешний код  вызывает Cancel() на источнике, все токены, выданные этим источником получают сигнал отмены\n"+
                                                                                     "при следующим вызове ThrowIfCancellationRequasted() метод видит этот сигнал и бросает OperationCanceledException\n"+
                                                                                     "Вместо ThrowIfCancellationRequested() можно использовать свойство IsCancellationRequested для более гибкого поведения\n"+
                                                                                     "cancelationToken.IsCancellationRequested если true вызвать логику отмены вручную\n"),

                ("673. Как можно отменить Task.Delay?","1.Создаем источник токена var cts = new CancellationTokenSource()\n"+
                                                        "2. Запускаем задержку с возможностью отмены Task delayTask = Task.Delay(TimeSpan.FromSeconds(10), cts.Token)\n"+
                                                        "3.await Task.Delay(2000);cts.Cancel() отменяем и обрабатываем результат через try catch"),

                ("674. Что произойдёт, если CancellationToken отменится, но в методе его не проверяют?","Если сам метод не проверяется и методы,которые он вызывает не проверяются ничего не пройзойдет\n"+
                                                                                                        "если в вызываемом метода будет проверка то будет выброшен OperationCanceledException\n"),

                ("675.Как отменить цепочку задач?","Создать один CancellationTokenSource() и передавать cancellationToken всем методам\n"),

                ("676. Можно ли повторно использовать CancellationTokenSource?","Нет после отмены нужно создавать новый\n"),

                ("677. Что произойдёт, если исключение выбрасывается после await внутри async Task метода?","1. Исключение захватывается механизмом async/await\n"+
                                                                                                            "2. Задача завершается с состоянием Faulted(а не RanToCompletion)\n"+
                                                                                                            "3. Исключение оборачивается в AggregateException внутри задачи\n"+
                                                                                                            "4. Исключение пробрасывается при ожидании задачи(await) или обращении к .Result\n"),

                ("678. Как поймать исключение из async void метода?","никак. Можно только сделать try catch внутри метода и залогитровать\n"+
                                                                     ""),

                ("679.Можно ли использовать try/catch вокруг await SomeAsyncMethod()?","да, можно и нужно\n"),

                ("680. Как работают исключения в цепочке .ContinueWith(...)?","нужно проверять каждый вызов через свойство IsFaulted\n"+
                                                                              "можно собрать все ошибки в continueWith, TaskContinuationOptions.OnlyOnFaulted в Exception.InnerException\n"),

                ("681. Почему async void считается антипаттерном?","1. Невозможность обработки исключений\n"+
                                                                   "2. Невозможность ожидания: на работает await,.Wait(), cancellationToken\n"+
                                                                   "3. проблемы с тестированием\n"+
                                                                   "4. Не возможно работать в цепочке\n"+
                                                                   "5. Сложность отладки\n"),

                ("682. Что такое TAP и какие ключевые преимущества он даёт по сравнению с APM/EAP?","TAP(Task-based Asynchronous Pattern) это современный асинхронный шаблон в Net\n"+
                                                                                                    "основанный на типах Task и Task<T>, примел на смену APM/EAP\n"+
                                                                                                    "TAP представляет асинхронную операцию одним методом,\n "+
                                                                                                    "который возвращает Task и Task<TResult> и обычно имеет суффикс async\n"+
                                                                                                    "1. Единая модель TAP подходит для решения APM и EAP\n"+
                                                                                                    "2. Просто использования и читаемость\n"+
                                                                                                    "3. TAP легко поддерживает отмену, APM/EAP отмена была сложной или невозможной\n"+
                                                                                                    "4. Естественная обработка исключений. TAP выбрасываются в точке await.\n"+
                                                                                                    "APM/EAP ошибки обрабатывались в колбеках или событиях часто теряя контекст\n"+
                                                                                                    "5. Композиции и цепочки вызовов\n"+
                                                                                                    "6. await вместо callback\n"+
                                                                                                    "7. TAP легче тестировать\n"+
                                                                                                    ""),

                ("683.Что вернёт метод, реализующий TAP, если его не дожидаться с await?","1. вернет объект Task, а не результат\n"),

                ("684. Обязательно ли использовать async и await, чтобы следовать TAP?","Нет может реализоваться без async/await"),

                ("685. В чём плюсы TAP по сравнению с Begin/End-методами?","1. Простота использования\n"+
                                                                           "2. Естественный поток выполнения. Последовательный код\n"+
                                                                           "3. Композиция задач. Позволяет легко комбинировать операции\n"+
                                                                           "4. единая точка обработки исключений\n"+
                                                                           "5. Отмена операций с CancellationToken\n"+
                                                                           "6. Производительностью TAP оптимизирован\n"+
                                                                           "7. TAP универсален\n"),

                ("686. Что происходит на уровне исполнения при вызове await?","1. Трансформация кода компилятором\n"+
                                                                              "2. создание State Machine\n"+
                                                                              "3. Этапы выполения await\n"+
                                                                               " Проверка завершенности await\n"+
                                                                               "сохранение контекста\n"+
                                                                               "возврат управления вызывающему коду\n"+
                                                                               "4. Синхронизация и обработка исключений\n"),

                ("687. Какой тип возвращает метод, в котором используется await?","Task<TResult>, Task, void"),

                ("688. Что произойдёт, если вызвать await на уже завершённой задаче?","это оптимизированный синхронный путь\n"+
                                                                                      "без накладных расходов асинхронности\n"+
                                                                                      "Компилятор эффективно обрабатывает этот случай"),

                ("689. Можно ли вызывать await вне метода с модификатором async?","Нет будет ошибка компиляции\n"),

                ("690.  Как использовать await в цикле?","можно написать await метод прям в условии\n"),

                ("691.Что такое SynchronizationContext?","это абстракция NET, которая представляет контекст синхронизации для \n"+
                                                         "выполнения кода в определенном потоке или контексте\n"+
                                                         "Это механизм, который управляет тем, в каком потоке продолжается выполнение после await\n"+
                                                         "Управляется через ConfigureAwait . Отсутствует в консольных приложениях и ASP.Net\n "),

                ("692.  Чем TaskScheduler отличается от SynchronizationContext?","Это два разных механизма планирования выполнения в net.\n"+
                                                                                 "SynchronizationContext привязка к потоку, а TaskScheduler управлениями задач\n"),

                ("693. Как влияет SynchronizationContext на await?","1. Определяет где код выполняется после await\n"+
                                                                    "2. Как происходит возврат в исходный текст\n"+
                                                                    "3. Производительность и потокобезопасность\n"),

                ("694.Как отключить возврат в SynchronizationContext?","использует метод ConfigureAwait(false)\n"),

                ("695.  Какой контекст используется в консольном приложении .NET?","В консольном приложении нет нет специального SynchronizationContext по умолчанию\n"+
                                                                                    "Это означает что продолжение после await выполняются в произвольном потоке\n"),

                ("696. Как обрабатываются исключения, если await отсутствует?","Исключение выбрасывается сразу при вызове,\n"+
                                                                                "отработает также как синхронный метод\n"+
                                                                                "вернет Faulted Task"),

                ("697. Что произойдёт, если async void метод выбросит исключение?","получится не контроллируемое исключение\n"+
                                                                              ""),

                ("698. Как проверить, завершилась ли Task с ошибкой?","1. свойство IsFaulted()\n"+
                                                                      "2. проверка свойства Status. Task.Status==TaskStatus.Faulted\n"+
                                                                      "3. использование свойства Exception task.Exception!=null\n"+
                                                                      ""),

                ("699. Как обработать исключения из нескольких задач, например через Task.WhenAll?","1. Базовый подход через try catch\n"+
                                                                                                    "2. получение из AggregateException. allTask.Exception.InnerException\n"+
                                                                                                    "3. обработка на успешные и неуспешные через Where и Isfaulted\n"),

                ("700. Какой тип исключения генерируется при отмене через CancellationToken?","OperationCancelledException(ручная проверка) или его наследник TaskCancelledException(при отмене асинхрооных операций)\n"),

                ("701.Что делает Task.Yield() в async методе?","Это специальный метод, который заставляет асинхронный метод\n "+
                                                               "немедленно вернуть управление вызывающему коду, даже если он мог\n"+
                                                               "бы продолжить синхронное выполнение\n"+
                                                               "Использовать для предотвращения блокировки, тестирования и многозадачности\n"),

                ("702.Task.CompletedTask","это статическое свойство которое возвращает уже завершенную успешную задачу\n "),

                ("703. В каких случаях Task.Yield() может быть полезен?","1. Предотвращение блокировки UI потоков\n"+
                                                                         "2. Многозадачность в циклах\n"+
                                                                         "3. Тестирование асинхронного поведения\n"),

                ("704. Что происходит, если использовать await Task.Yield() в начале метода?","Возврат управления вызываему коду\n"+
                                                                                              "создание асинхронной точки\n"+
                                                                                              ""),

                ("705. Можно ли использовать Task.Yield() в обычных не-UI приложениях?","можно\n"+
                                                                                         "1. Кооперативная многозадачность в циклах\n"+
                                                                                         "2. Предотвращение stack overflow в рекурсии\n"+
                                                                                         "3. Fair scheduling в высоконагруженных сервисах\n"+
                                                                                         "4. Тестирование асинхронного поведения.\n" +
                                                                                         "" +
                                                                                         " "),

                ("706. Что делает ConfigureAwait(false) на практике?","отключает захват и восстоновление контекста синхронизации\n"+
                                                                      "при продолжении выполнения после await\n"),

                ("707. Почему ConfigureAwait(false) важен в библиотечном коде?","1.Может быть получится deadlock\n"+
                                                                                "2. Независимость от констекста вызова\n"+
                                                                                "3. Улучшенная производительность\n"+
                                                                                "4. Предсказуемость поведения\n"),
                ("708. Где ConfigureAwait(false) может быть вреден?","1. UI элементы\n"+
                                                                     "2. устаревший ASP.Net HttPContext\n"+
                                                                     "3. код требующий определенного контекста\n"),

                ("709. Как ConfigureAwait(false) влияет на производительность?","существенно влияет, но неодназначно\n"+
                                                                                "1. Снижение нагрузки на контекст сихронизации\n"+
                                                                                "2. Избегание лишних переключений контекста\n"+
                                                                                "3. Уменьшение аллокаций памяти\n"+
                                                                                "снижение за счет проверок\n"),
                ("710. Что такое IProgress<T> и зачем он нужен?","Интерфейс для безопасной передачи прогресса и промежуточных результатов\n"+
                                                                 "из асинхронных операций в UI или другой контекст\n"+
                                                                 "интерфейс void Report(T value)\n"),

                ("711. Какой класс обычно реализует IProgress<T>?","Progress<T> стандартный класс, который реализующий IProgress<T>\n"+
                                                                   "Он представляет готовую реализацию для безопасной передачи прогресса\n"),

                ("712. Как IProgress<T> обеспечивает потокобезопасность?","обеспечивает потокобезопасность через автоматическую маршрутизацию вызовов  в правильный контекст\n"),

                ("713.  Можно ли использовать IProgress<T> в консольных приложениях?","Можно, но нет синхронизации и нет гарантии порядка вывода\n"),

                ("714. Почему нельзя использовать обычный Action<T> вместо IProgress<T>?","Action<T> потоконебезопасен и выполняется в том же потоке\n"+
                                                                                          ""),

                ("715.","")






















































            };
        }

        public int GetNumber()
        {
            Random random = new Random();
            //0-130 git
            //131-478 sql
            //479     продвинутый C#
            return random.Next(0, listQA.Count - 1);
        }

        public void PrintQA()
        {
            int number = GetNumber();
            Console.WriteLine($"Вопрос номер {number}");
            Console.WriteLine(listQA[number].Item1);
            Console.WriteLine("\n");
            Console.ReadKey();
            Console.WriteLine($"Ответ номер {number}");
            Console.WriteLine(listQA[number].Item2);
            Console.WriteLine("\n");

        }
    }
}
